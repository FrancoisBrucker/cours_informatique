<!DOCTYPE html>
<html lang="fr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>DS 1 : mines-ponts 2017</title>

    <link href="/cours_informatique/assets/node_modules/prismjs/themes/prism-solarizedlight.min.css" rel="stylesheet">
    <link href="/cours_informatique/assets/node_modules/prismjs/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet">

    <link href="/cours_informatique/assets/stylesheets/main.css" rel="stylesheet">

  </head>
  <body>
    <script>
      window.MathJax = {
        tex: {
          inlineMath: [
            [
              '$', '$'
            ],
            [
              '\\(', '\\)'
            ]
          ]
        },
        svg: {
          fontCache: 'global'
        }
      };

      function goTop() {
        window.scrollTo({top: 0});
      }
      function goBottom() {
        window.scrollTo({top: document.body.scrollHeight});
      }
    </script>
    <script type="text/javascript" id="MathJax-script" src="/cours_informatique/assets/node_modules/mathjax/es5/tex-svg-full.js"></script>

    <header class="border-b-2 border-gray-200 mb-4">
      <div class="max-w-[1200px] mx-auto px-4 relative">
        <div class="min-h-[50px] flex justify-between items-center">
          <a class="mx-2" href="/cours_informatique/">Home</a>
        </div>

        <div class="min-h-[50px] flex justify-center items-center absolute right-0 top-0">
          <a class="mx-2" href="/cours_informatique/about">About</a>
          <button onclick="goTop()" id="myBtn" title="Go to top">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
              <path stroke-linecap="round" stroke-linejoin="round" d="M15 11.25l-3-3m0 0l-3 3m3-3v7.5M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
            </svg>
          </button>

          <button onclick="goBottom()" id="myBtn" title="Go to top">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
              <path stroke-linecap="round" stroke-linejoin="round" d="M9 12.75l3 3m0 0l3-3m-3 3v-7.5M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
            </svg>
          </button>
        </div>

      </div>
    </header>

    <main class="max-w-[1200px] mx-auto px-4">
      
<article>

  <h1>DS 1 : mines-ponts 2017</h1>
  <div>
    

    
  </div>

  

  <div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
</svg>
<div class="pl-8  mb-2 mr-8">
<p><strong>Sujet</strong></p>
</div><div class="pl-8 mr-8">
<p>Le sujet du DS 1 est <a href="../mines-info-2017-sujet.pdf">L'épreuve commune d'informatique mines/ponts 2017</a> (sans la partie VI).</p>
<p>Durée du contrôle : 3h.</p>
</div>
</div>
<p>La durée du contrôle était de 3h, le double de celui normalement alloué à l'épreuve. Le but était de se concentrer sur la justesse de vos raisonnement et de vos justifications avant de travailler la rapidité. On reprend ainsi la célèbre maxime de Kent Beck sur l'ordre de développement d'un bon code (un bon code doit avoir les 3, mis en œuvre dans cet ordre) :</p>
<ol>
<li>make if work</li>
<li>make it right</li>
<li>make it fast</li>
</ol>
<p>Si vous avez bien compris et réussi le sujet, il vous faut travailler la rapidité en L2 et L3.</p>
<h2>Barème</h2>
<ul>
<li>Questions Q1 à Q20 : 1 point par question</li>
<li>Questions Q21 à Q25 : 1/2 point par question</li>
<li>Total : Noté sur 22.5 points</li>
</ul>
<p>Statistiques descriptives du contrôle :</p>
<ul>
<li>moyenne : 13,68</li>
<li>écart-type : 4,41</li>
<li>min : 0,00</li>
<li>max : 20,00</li>
</ul>
<p>La moyenne d'un examen devrait être de 12 avec un écart type de 2. Ici elle est bien trop élevée (13.7) et l'écart-type est également bien trop important (4.5). Ceci signifie que : 1 - l'examen était trop facile (<em>ie.</em> vous aviez trop de temps pour faire un examen de 1h30) et 2 - la population est hétérogène (<em>ie.</em> il y a trop de personnes ayant plus de 18).</p>
<p>Ventilation des notes :</p>
<ul>
<li>$N &lt; 10$ : 10 personnes</li>
<li>$10 \leq N &lt; 14$ : 12 personnes</li>
<li>$14 \leq N &lt; 18$ : 13 personnes</li>
<li>$18 \leq N$ : 7 personnes</li>
</ul>
<p>Si vous avez moins de 12, vous ne pouvez vous contenter de votre note, il faut encore progresser pour avoir un niveau acceptable en informatique et si vous avez moins de 14 vous êtes dans la deuxième moitié de la promo.</p>
<p>A votre niveau, progresser signifie principalement :</p>
<ul>
<li><strong>se relire</strong> pour supprimer les erreurs bêtes qui font perdre des quart de points</li>
<li><strong>relire la question</strong> avant de répondre pour vérifier que l'on ne va pas répondre à côté</li>
<li>et surtout <strong>tester ses algorithmes</strong> sur une feuille de brouillon avec de petits exemples pour vérifier qu'ils font bien ce que l'on pense qu'ils font</li>
</ul>
<h2>Correction</h2>
<h3>Q1</h3>
<p>Une suite de $n$ cases successives se modélise par une liste de longueur $n$. Comme les voitures sont indifférenciées et qu'il n' peut y avoir qu'une voiture au maximum par case, on peut modéliser une file de voiture par une liste $A$ :</p>
<ul>
<li>de longueur $n$</li>
<li>s'il y a une voiture dans la case $i$ de la file on note <code class="language-">A[i] = True</code></li>
<li>s'il n'y a pas de voiture dans la case $i$ de la file on note <code class="language-">A[i] = False</code></li>
</ul>
<h3>Q2</h3>
<pre class="language-python " style="counter-reset: linenumber 0"><code class="language-python">A <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token boolean">True</span><span class="token punctuation">,</span> <span class="token boolean">False</span><span class="token punctuation">,</span> <span class="token boolean">True</span><span class="token punctuation">,</span> <span class="token boolean">True</span><span class="token punctuation">,</span> <span class="token boolean">False</span><span class="token punctuation">,</span> <span class="token boolean">False</span><span class="token punctuation">,</span> <span class="token boolean">False</span><span class="token punctuation">,</span> <span class="token boolean">False</span><span class="token punctuation">,</span> <span class="token boolean">False</span><span class="token punctuation">,</span> <span class="token boolean">False</span><span class="token punctuation">,</span> <span class="token boolean">True</span><span class="token punctuation">]</span>
</code></pre>
<p>Ou si on veut la créer :</p>
<pre class="language-python " style="counter-reset: linenumber 0"><code class="language-python">A <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token boolean">False</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">]</span>

<span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    A<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">True</span>
</code></pre>
<p>La complexité de l'algorithme précédent est en $\mathcal{O}(1)$ car il ne fonctionne <strong>que</strong> pour $A$ qui est de taille $11$.</p>
<h4>Remarques suite à la correction des copies</h4>
<ul>
<li><code class="language-">1 != True</code> les booléens prennent 2 valeurs <code class="language-">True</code> et <code class="language-">False</code> pas 0 ou 1 qui sont des entiers. On peut interpréter des entiers comme des booléens (0 est faux et tous les autres entiers sont vrais) mais ce n'est pas la même chose.</li>
<li>Comme la liste <code class="language-">A</code> que l'on vous demande de construire est une constante, la complexité de son calcul est en $\mathcal{O}(1)$. puisqu'il ne fonctionne que pour <code class="language-">A</code> par pour une autre liste.</li>
</ul>
<h3>Q3</h3>
<pre class="language-python " style="counter-reset: linenumber 0"><code class="language-python"><span class="token keyword">def</span> <span class="token function">occupe</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">return</span> L<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
</code></pre>
<p>La complexité de fonction <code>occupe(L, i)</code> est $\mathcal{O}(1)$ puisque'il suffit accéder à un élément d'une liste. Elle donne bien le résultat attendu si $L$ est conforme à Q1.</p>
<h4>Remarque suite à la correction des copies</h4>
<p>On ne teste pas la véracité des booléens, on l'utilise. On remplace donc tous les <code class="language-">if L[i] == true return True else return False</code> par <code class="language-">return L[i]</code> qui est équivalent.</p>
<h3>Q4</h3>
<p>Chaque case pouvant être occupée ou non, il y a deux possibilités pour chacune des $n$ cases d'une liste : il y a $2^n$ possibilités.</p>
<h3>Q5</h3>
<p>Les deux solutions suivantes sont équivalentes :</p>
<pre class="language-python " style="counter-reset: linenumber 0"><code class="language-python"><span class="token keyword">def</span> égal<span class="token punctuation">(</span>L1<span class="token punctuation">,</span> L2<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>L1<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>L2<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token boolean">False</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>L1<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> L1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> L2<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token boolean">False</span>
    <span class="token keyword">return</span> <span class="token boolean">True</span>
</code></pre>
<p>et</p>
<pre class="language-python " style="counter-reset: linenumber 0"><code class="language-python"><span class="token keyword">def</span> égal<span class="token punctuation">(</span>L1<span class="token punctuation">,</span> L2<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">return</span> L1 <span class="token operator">==</span> L2
</code></pre>
<p>Les deux fonctions vérifient que les longueurs des deux listes sont égales et que leurs éléments coïncident.</p>
<h4><span id="rq-q5"></span> Remarque suite à la correction des copies</h4>
<p>Attention aux tailles des listes.</p>
<pre class="language-python " style="counter-reset: linenumber 0"><code class="language-python"><span class="token keyword">def</span> <span class="token function">compare</span><span class="token punctuation">(</span>L1<span class="token punctuation">,</span> L2<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>L1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> L1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> L2<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token boolean">False</span>
    <span class="token keyword">return</span> <span class="token boolean">True</span>
</code></pre>
<p>Produit une erreur si <code class="language-">len((L2)) &lt; len(L1)</code> et est faux si <code class="language-">len((L2)) &gt; len(L1)</code> (par exemple <code class="language-">L1= [1, 2]</code> et <code class="language-">L2 = [1]</code>).</p>
<h3>Q6</h3>
<p>A part la boucle <code class="language-">for</code> toutes les autres opérations de la méthode <code class="language-">égal</code> sont en $\mathcal{O}(1)$. Si les deux listes à comparer sont égales, il faut parcourir tous les éléments de la liste : la complexité est donc en $\mathcal{O}(n)$ où $n$ est la longueur de la liste <code class="language-">L1</code>.</p>
<div class="quote relative py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-red-500 bg-red-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-red-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"></path>
</svg>
<div class="pl-8 mr-8">
<p>Les complexités des deux fonctions <strong>sont les mêmes</strong>. La comparaison de deux listes en python avec l'opérateur <code>==</code> est de complexité égal à la taille de la plus petite des listes.</p>
</div>
</div>
<h3>Q7</h3>
<p>Le retour de la fonction <code class="language-">égal</code> est un booléen.</p>
<h4><span id="rq-q7"></span> Remarque suite à la correction des copies</h4>
<p>Le terme demandé est <em><strong>booléen</strong></em>. Dire juste <code class="language-">True</code> ou <code class="language-">False</code> n'est pas suffisant.</p>
<h3>Q8</h3>
<p>Procédons par étape. Position initiale <code class="language-">A = [True, False, True, True, False, False, False, False, False, False, True]</code> :</p>
<pre><code>A  : ⇨▢⇨⇨▢▢▢▢▢▢⇨
</code></pre>
<p>L'instruction <code class="language-">P2 = avancer(avancer(A, False), True)</code> revient à exécuter <code>avancer(P1, True)</code> où <code class="language-">P1=avancer(A, False)</code>. Il faut donc commencer par déterminer <code>P1</code> avant de calculer <code>avancer(P1, P2)</code>.</p>
<p>On a que <code class="language-">P1 = avancer(A, False)</code> vaut <code class="language-">[False, True, False, True, True, False, False, False, False, False, False]</code>.</p>
<pre><code>A  : ⇨▢⇨⇨▢▢▢▢▢▢⇨
P1 : ▢⇨▢⇨⇨▢▢▢▢▢▢
</code></pre>
<p>De là, <code class="language-">avancer(P1, True)</code> vaut alors : <code class="language-">[True, False, True, False, True, True, False, False, False, False, False]</code></p>
<pre><code>A  : ⇨▢⇨⇨▢▢▢▢▢▢⇨
P1 : ▢⇨▢⇨⇨▢▢▢▢▢▢
P2 : ⇨▢⇨▢⇨⇨▢▢▢▢▢
</code></pre>
<h3>Q9</h3>
<p>En python :</p>
<ul>
<li>$L[:m]$ correspond aux $m$ premiers éléments de la liste, donc ceux allant de l'indice 0 à l'indice $m-1$</li>
<li>$L[m:]$ correspond aux derniers éléments de la liste en commençant par celui d'indice $m$.</li>
</ul>
<p>Il faut faire avancer les dernier éléments de la liste (avec <code class="language-">avancer</code>) sans toucher au  premiers éléments :</p>
<pre class="language-python " style="counter-reset: linenumber 0"><code class="language-python"><span class="token keyword">def</span> <span class="token function">avancer_fin</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> m<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">return</span> L<span class="token punctuation">[</span><span class="token punctuation">:</span>m<span class="token punctuation">]</span> <span class="token operator">+</span> avancer<span class="token punctuation">(</span>L<span class="token punctuation">[</span>m<span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token boolean">False</span><span class="token punctuation">)</span>
</code></pre>
<p>La complexité de la fonction précédente est en $\mathcal{O}(n)$ où $n$ est la taille de la liste. Car la créations<br>
des listes partielles et la fonction avancer sont toutes de complexités égales à la longueur des listes qu'elles manipulent.</p>
<h4><span id="rq-q9"></span> Remarques suite à la correction des copies</h4>
<ul>
<li>Le sujet donne des fonctions à coder, il faut les utiliser. Ne recodez pas tout à chaque fois. En plus, les algorithmes deviennent plus simple.</li>
<li>Attention aux complexité : la concaténation crée une nouvelle liste, sa complexité est égale à la somme des tailles des 2 listes.</li>
</ul>
<h3>Q10</h3>
<p>La case $L[m]$ étant inoccupée, faire avancer le début de la liste ne va pas faire <em>déborder</em>de voiture. On peut alors procéder exactement de la même manière que pour la question précédente (en faisant attention à l'indice de fin du découpage), ce qui donne une complexité égale à $\mathcal{O}(n)$.</p>
<pre class="language-python " style="counter-reset: linenumber 0"><code class="language-python"><span class="token keyword">def</span> <span class="token function">avancer_debut</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> b<span class="token punctuation">,</span> m<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">return</span> avancer<span class="token punctuation">(</span>L<span class="token punctuation">[</span><span class="token punctuation">:</span>m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token operator">+</span> L<span class="token punctuation">[</span>m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span>
</code></pre>
<h4><span id="rq-q10"></span> Remarques suite à la correction des copies</h4>
<p>Idem que pour la question précédente :</p>
<ul>
<li>Le sujet donne des fonctions à coder, il <strong>faut</strong> les utiliser. Ne recodez pas tout à chaque fois. En plus, les algorithmes deviennent plus simple.</li>
<li>Attention aux complexité : la concaténation crée une nouvelle liste, sa complexité est égale à la somme des tailles des 2 listes.</li>
</ul>
<h3>Q11</h3>
<p>On remonte la liste de l'indice $i=m-1$ à $i=0$ jusqu'à trouver une case non occupée. Une fois celle ci trouvée on utilise <code class="language-">avancer_debut</code> de la question précédente.</p>
<p>Si aucune case n'est libre (on arrive à la fin de la boucle <code class="language-">for</code>),une telle case n'existe pas on rend uniquement une copie de la liste puisque rien ne peut bouger.</p>
<p>La remontée de l'indice $i$ prenant au maximum $\mathcal{O}(m)$ opérations et comme <code class="language-">avancer_debut</code> est de complexité proportionnelle à la taille de sa liste en entrée, la complexité totale est en $\mathcal{O}(m)$.</p>
<pre class="language-python " style="counter-reset: linenumber 0"><code class="language-python"><span class="token keyword">def</span> <span class="token function">avance_debut_bloque</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> b<span class="token punctuation">,</span> m<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token keyword">not</span> occupe<span class="token punctuation">(</span>L<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> avancer_debut<span class="token punctuation">(</span>L<span class="token punctuation">,</span> b<span class="token punctuation">,</span> i<span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token builtin">list</span><span class="token punctuation">(</span>L<span class="token punctuation">)</span> <span class="token comment"># copie de la liste</span>
</code></pre>
<p>Il y a aussi la version récursive qui se rappelle s'il n'est pas possible de résoudre le problème directement :</p>
<pre class="language-python " style="counter-reset: linenumber 0"><code class="language-python"><span class="token keyword">def</span> <span class="token function">avance_debut_bloque</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> b<span class="token punctuation">,</span> m<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> m <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token builtin">list</span><span class="token punctuation">(</span>L<span class="token punctuation">)</span> <span class="token comment"># copie de la liste    </span>
    <span class="token keyword">elif</span> <span class="token keyword">not</span> occupe<span class="token punctuation">(</span>L<span class="token punctuation">,</span> m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> avancer_debut<span class="token punctuation">(</span>L<span class="token punctuation">,</span> b<span class="token punctuation">,</span> m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token keyword">else</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> avance_debut_bloque<span class="token punctuation">(</span>L<span class="token punctuation">,</span> b<span class="token punctuation">,</span> m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>
</code></pre>
<div class="quote relative py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-red-500 bg-red-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-red-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"></path>
</svg>
<div class="pl-8 mr-8">
<p>Le sujet demande de rendre une <strong>copie</strong> de la liste.</p>
</div>
</div>
<h4><span id="rq-q11"></span> Remarque suite à la correction des copies</h4>
<p>Pour cette question en particulier, utiliser les questions et les algorithmes précédents rend le code bien plus clair et facile à lire.</p>
<h3>Q12</h3>
<p>On procède comme indiqué dans le sujet :</p>
<ol>
<li>on avance la file $L1$ et la file $L$2 à partir du croisement, aucun blocage ne peut arriver</li>
<li>la case du croisement est forcément libre pour $L1$ et $L2$ après la première étape, on peut donc avancer le début de la file $L1$</li>
<li>si le croisement est libre (la case m n'est pas occupée pour $L1$) on peut avancer le début de $L2$, sinon on effectue un avancement avec le début bloqué.</li>
</ol>
<p>Comme il y a un nombre constant de fonction dépendant de la taille des listes en entrée, on en déduit que la complexité totale est en $\mathcal{O}(n)$ où $n$ est la taille des listes.</p>
<pre class="language-python " style="counter-reset: linenumber 0"><code class="language-python"><span class="token keyword">def</span> <span class="token function">avancer_files</span><span class="token punctuation">(</span>L1<span class="token punctuation">,</span> b1<span class="token punctuation">,</span> L2<span class="token punctuation">,</span> b2<span class="token punctuation">)</span><span class="token punctuation">:</span>
    m <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>L1<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span>
    
    R1 <span class="token operator">=</span> avancer_fin<span class="token punctuation">(</span>L1<span class="token punctuation">,</span> m<span class="token punctuation">)</span>
    R2 <span class="token operator">=</span> avancer_fin<span class="token punctuation">(</span>L2<span class="token punctuation">,</span> m<span class="token punctuation">)</span>
    
    R1 <span class="token operator">=</span> avance_debut<span class="token punctuation">(</span>R1<span class="token punctuation">,</span> b1<span class="token punctuation">,</span> m<span class="token punctuation">)</span>

    <span class="token keyword">if</span> occupe<span class="token punctuation">(</span>R1<span class="token punctuation">,</span> m<span class="token punctuation">)</span><span class="token punctuation">:</span>
        R2 <span class="token operator">=</span> avance_debut_bloque<span class="token punctuation">(</span>R2<span class="token punctuation">,</span> b2<span class="token punctuation">,</span> m<span class="token punctuation">)</span>
    <span class="token keyword">else</span><span class="token punctuation">:</span>
        R2 <span class="token operator">=</span> avance_debut<span class="token punctuation">(</span>R2<span class="token punctuation">,</span> b2<span class="token punctuation">,</span> m<span class="token punctuation">)</span>
    
    <span class="token keyword">return</span> <span class="token punctuation">[</span>R1<span class="token punctuation">,</span> R2<span class="token punctuation">]</span>
</code></pre>
<h4><span id="rq-q12"></span> Remarque suite à la correction des copies</h4>
<p>La liste étant de longueur impaire, l'indice du milieu est au choix :</p>
<ul>
<li><code class="language-">m = (len(L) - 1) / 2</code></li>
<li><code class="language-">len(L) // 2</code></li>
</ul>
<p>Mais aucune autre formule. Si vous aviez fait un test de votre formule avec un petit exemple, ne nombreuses fautes auraient pu être évitées.</p>
<h3>Q13</h3>
<p>Position initiale :</p>
<pre><code>    E
    ▢
    ⇩ 
D ▢⇨⇩⇨▢
    ▢
    ▢
</code></pre>
<p>Après utilisation de la fonction <code class="language-">avancer-files(D, False, E, False)</code> on obtient :</p>
<pre><code>    E
    ▢
    ⇩ 
D ▢▢⇨▢⇨
    ⇩
    ▢
</code></pre>
<p>Ce qui donne comme listes :</p>
<ul>
<li><code class="language-">D = [False, False, True, False, True]</code></li>
<li><code class="language-">E = [False, True, False, True, False]</code></li>
</ul>
<h3>Q14</h3>
<p>Si la file $L1$ est pleine et qu'à chaque étape on ajoute une voiture, le croisement (d'indice $m$) sera toujours occupé par une voiture de $L1$ : aucun voiture de la file $L2$ ne pourra dépasser le croisement. Si la file $L2$ est pleine jusqu'à l'indice précédent le croisement, aucune ce ces voitures ne pourra se déplacer.</p>
<pre><code>     L2
     ⇩
     ⇩ 
L1 ⇨⇨⇨⇨⇨
     ▢
     ▢
</code></pre>
<h3>Q15</h3>
<p>Position initiale :</p>
<pre><code>      L2
       ⇩
       ⇩
       ⇩
       ⇩ 
L1 ⇨⇨⇨⇨▢▢▢▢▢
       ▢
       ▢
       ▢
       ▢
</code></pre>
<p>La file $L1$ étant prioritaire, les voitures de la file $L2$ ne peuvent avancer pendant les 4 premières étapes.  Puis il faut les déplacer, donc encore au moins 5 étapes. Le nombre minimal d'opérations est ainsi d'au moins 4 + 5 = 9 opérations.</p>
<p>Ceci est suffisant :</p>
<p>On commence par faire 5 fois <code class="language-">avancer_files(L1, False, L2, False)</code>. Les 4 voitures de $L1$ ont dépassé le croisement et la première voiture de $L2$ est sur le croisement :</p>
<pre><code>      L2
       ▢
       ⇩
       ⇩
       ⇩ 
L1 ▢▢▢▢⇩⇨⇨⇨⇨
       ▢
       ▢
       ▢
       ▢
</code></pre>
<p>Puis on ajoute les nouvelles voitures de $L1$ en faisant 4 fois <code class="language-">avancer_files(L1, True, L2, False)</code> :</p>
<pre><code>      L2
       ▢
       ▢
       ▢
       ▢
L1 ⇨⇨⇨⇨▢▢▢▢▢
       ⇩
       ⇩
       ⇩
       ⇩ 
</code></pre>
<h3>Q16</h3>
<p>Cette étape finale est impossible à obtenir car la file $L1$ est prioritaire. A l'étape précédente il y a forcément une voiture de la file $L1$ sur le croisement, ce qui laisse un <em>trou</em> au croisement sur la file $L2$ :</p>
<pre><code>      L2
       ▢
       ▢
       ▢
       ⇩
L1 ▢▢▢▢⇨⇨⇨⇨?
       ⇩
       ⇩
       ⇩
       ? 
</code></pre>
<p>Ce <em>trou</em> ne peut être comblé en une étape : la position de l'étape (c) est impossible à obtenir.</p>
<h3>Q17</h3>
<p>La liste étant triée, un doublon est tel que $L[i] = L[i+1]$. On peut alors supprimer les doublons en parcourant la liste $L$ et en ne considérant que les éléments tels que $L[i] &gt; L[i-1]$. Ceci donne l'algorithme suivant :</p>
<pre class="language-python line-numbers" style="counter-reset: linenumber 0"><code class="language-python"><span class="token keyword">def</span> élimine_double<span class="token punctuation">(</span>L<span class="token punctuation">)</span><span class="token punctuation">:</span>
    L2 <span class="token operator">=</span> <span class="token punctuation">[</span>L<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
    
    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">(</span>L<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> L<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> L<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span>
            L2<span class="token punctuation">.</span>append<span class="token punctuation">(</span>x<span class="token punctuation">)</span>
    <span class="token keyword">return</span> L2
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>Comme la complexité de la méthode de liste <code class="language-">append</code> est en $\mathcal{O}(1)$, la complexité du corps de la boucle for (lignes 5-6) est en $\mathcal{O}(1)$. Le nombre d'itération de cette boucle est en $\mathcal{O}(n)$, avec $n$ la taille de la liste, donc la complexité totale de l'algorithme est en $\mathcal{O}(n)$.</p>
<h4><span id="rq-q17"></span> Remarques suite à la correction des copies</h4>
<ul>
<li><code class="language-">del L[i]</code> n'est <strong>pas</strong> en $\mathcal{O}(1)$, il faut décaler tout ce qui est à droite de l'indice $i$ d'une case vers la gauche. Sa complexité est donc en taille de la liste.</li>
<li><code class="language-">L + [a]</code> n'est <strong>pas</strong> en $\mathcal{O}(1)$, il faut créer une nouvelle liste contenant tous les éléments. Sa complexité est donc en taille de la liste.</li>
</ul>
<p>Une erreur récurrente qui fait des bug difficile à trouver : on ne modifie pas ce sur quoi on itère. Donc les choses du style :</p>
<pre class="language-python " style="counter-reset: linenumber 0"><code class="language-python"><span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>L<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> truc<span class="token punctuation">:</span>
        <span class="token keyword">del</span> L<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
</code></pre>
<p>Vont rater car $i$ va à un moment aller plus loin que la liste actuelle. Si vous voulez faire ce genre de chose il faut utiliser un <code class="language-">while</code> :</p>
<pre class="language-python " style="counter-reset: linenumber 0"><code class="language-python">i <span class="token operator">=</span> <span class="token number">0</span>
<span class="token keyword">while</span> i <span class="token operator">&lt;</span> <span class="token builtin">len</span><span class="token punctuation">(</span>L<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> truc<span class="token punctuation">:</span>
        <span class="token keyword">del</span> L<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
    <span class="token keyword">else</span><span class="token punctuation">:</span>
        i <span class="token operator">+=</span> <span class="token number">1</span>
</code></pre>
<p>Enfin, on ne modifie par l'itérateur, ça ne sert à rien :</p>
<pre class="language-python " style="counter-reset: linenumber 0"><code class="language-python"><span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>L<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> truc<span class="token punctuation">:</span>
        i <span class="token operator">+=</span> <span class="token number">1</span>
</code></pre>
<p>Est inutile, lorsque l'on va recommencer la boucle $i$ reprendra son court normal, car il va prendre la valeur suivante du range. Pour incrémenter plusieurs fois l'itérateur il faut utiliser un <code class="language-">while</code> :</p>
<pre class="language-python " style="counter-reset: linenumber 0"><code class="language-python">i <span class="token operator">=</span> <span class="token number">0</span>
<span class="token keyword">while</span> i <span class="token operator">&lt;</span> <span class="token builtin">len</span><span class="token punctuation">(</span>L<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> truc<span class="token punctuation">:</span>
        i <span class="token operator">+=</span> <span class="token number">1</span>
    <span class="token keyword">else</span><span class="token punctuation">:</span>
        i <span class="token operator">+=</span> <span class="token number">1</span>
</code></pre>
<h3>Q18</h3>
<p>La fonction <code class="language-">doublons</code> rend une liste triée sans doublons de la liste triée passée en paramètre. Cette fonction étant récursive, nous allons le prover par récurrence sur la taille $n$ de la liste.</p>
<p>Si $n \leq 1$ on rend la liste en entrée, Ok. On suppose la propriété pour $n \geq 1$. A $n+1$.</p>
<p>Si $L[0] \neq L[1]$, $L[0]$ est le 1er élément de la liste triée sans doublons issue de $L$ et comme :</p>
<ul>
<li>tous les éléments de $L[1:]$ sont strictement plus grand que $L[0]$</li>
<li>par hypothèse de récurrence, <code class="language-">doublons(L[1:])</code> rendra la liste sans doublons de la liste triée $L[1:]$</li>
</ul>
<p>La liste triée sans doublons issue de $L$ est bien égale à $[L[0]] + doublons(L[1:]).</p>
<p>Si $L[0] \neq L[1]$ la liste triée sans doublons de $L$ est égale à la liste triée sans doublons de la liste $L$ privée de son élément $L[1]$. Ok</p>
<p>On a démontrée que <code class="language-">doublons</code> est une fonction qui rend une liste triée sans doublons de la liste triée passée en argument. Donc elle rendra <code class="language-">[1, 2, 3, 5]</code> pour la liste triée <code class="language-">[1, 1, 2, 2, 3, 3, 3, 5]</code> passée en paramètre.</p>
<h3>Q19</h3>
<p>Non, car elle rendrait $[1, 2, 1]$ pour la même liste en entrée.</p>
<h4>Pour aller plus loin</h4>
<p>La fonction <code class="language-">doublons(L)</code> est affreuse !</p>
<p>Déjà, sa complexité est de l'ordre de$\mathcal{O}(n^2)$ si la liste passée en entrée est triée et sans doublons.</p>
<p>Mais de façon bien plus affreuse, elle n'est pas cohérente sur son retour. Parfois elle rend la liste passée en paramètre (si $n \leq 1$), parfois elle rend une copie (si $L[0] &lt; L[1]$) et parfois elle rend une copie <strong>et</strong> modifie la liste passée en paramètre (si $L[0] == L[1]$). Bref, c'est du très mauvais code. Il faut <strong>toujours</strong> être consistant. Soit on modifie les paramètre en entrée et dans ce cas là on ne rend rien, <strong>soit</strong> on rend quelque chose et dans ce cas là on ne modifie pas les paramètres d'entrée.</p>
<h3>Q20</h3>
<ul>
<li>la fonction <code class="language-">recherche</code> rend un booléen</li>
<li><code class="language-">but</code> est une liste de deux éléments formant le croisement. Il correspond à l'état qe l'on cherche à atteindre</li>
<li><code class="language-">espace</code> est une liste de croisements (qui sont des listes à deux éléments). Cette liste correspond à tous les états que l'on peut atteindre à partir de init(qui est une liste de 2 liste formant un croisement)</li>
<li><code class="language-">successeurs</code> rend une liste de croisements (qui sont des listes à deux éléments).</li>
</ul>
<h3>Q21</h3>
<p><code class="language-">in2</code> correspond à une recherche dichotomique, dont la complexité est de l'ordre de $\mathcal{O}(log_2(n))$, alors que <code class="language-">in1</code> est une recherche linéaire dont la complexité est de l'ordre de $\mathcal{O}(n)$.</p>
<p>Il est donc <strong>beaucoup</strong> plus judicieux de d'utiliser <code class="language-">in2</code> plutôt que <code class="language-">in1</code>.</p>
<h3>Q22</h3>
<p>un entier $x$ se représente de façon binaire par l'équation :</p>
<p>$$<br>
x = \sum_{i=0}^{i = \log_2(x)} x_i 2^i<br>
$$</p>
<p>Où les $x_i$ valent soit $1$ soit $0$. L'entier $x$ est représenté par $\log_2(x)$ bits valant chacun $x_i$.</p>
<p>On peut alors associer à une liste $L$ de $n$ booléens les $x^L_i$ valant $1$ si <code class="language-">L[n-1-i] == True</code> et 0 si <code class="language-">L[i] == False</code>. La représentation binaire de $L$ est alors représentée par le nombre :</p>
<p>$$<br>
N(l) = \sum_{i=0}^n x^L_i 2^i<br>
$$</p>
<p>Pour $L = [True, False, False]$ on a $0 \cdot 2^0 + 0 \cdot 2^1 + 1 \cdot 2^2$, ce qui correspond au nombre binaire $100$ qui vaut 4.</p>
<p>L'algorithme ci-après en est un calcul. Sa complexité est en $\mathcal{O}(n)$</p>
<pre class="language-python " style="counter-reset: linenumber 0"><code class="language-python"><span class="token keyword">def</span> <span class="token function">versEntier</span><span class="token punctuation">(</span>L<span class="token punctuation">)</span><span class="token punctuation">:</span>
    entier <span class="token operator">=</span> <span class="token number">0</span>
    puissance_2 <span class="token operator">=</span> <span class="token number">1</span>
    
    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>L<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> L<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span>
            entier <span class="token operator">+=</span> puissance_2 

        puissance_2 <span class="token operator">*=</span> <span class="token number">2</span>
    
    <span class="token keyword">return</span> entier  
</code></pre>
<p>Ou dans l'autre sens (vu dans une copie) :</p>
<pre class="language-python " style="counter-reset: linenumber 0"><code class="language-python"><span class="token keyword">def</span> <span class="token function">versEntier</span><span class="token punctuation">(</span>L<span class="token punctuation">)</span><span class="token punctuation">:</span>
    entier <span class="token operator">=</span> <span class="token number">0</span>
    
    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>L<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        entier <span class="token operator">*=</span> <span class="token number">2</span>

        <span class="token keyword">if</span> L<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span>
            entier <span class="token operator">+=</span> <span class="token number">1</span>
    
    <span class="token keyword">return</span> entier  
</code></pre>
<h4><span id="rq-q22"></span> Remarques suite à la correction des copies</h4>
<p>Le calcul de $2^i$ ne compte pas pour $\mathcal{O}(1)$. On a vu en cours qu'il faut toujours au minimum $\log_2(i)$ opérations pour cela. La complexité de la fonction suivante est donc en $\mathcal{O}(n\log(n))$ et <strong>pas</strong> en $\mathcal{O}(n)$ :</p>
<pre class="language-python " style="counter-reset: linenumber 0"><code class="language-python"><span class="token keyword">def</span> <span class="token function">f</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>
    s <span class="token operator">=</span> <span class="token number">0</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>
        s <span class="token operator">+=</span> <span class="token number">2</span> <span class="token operator">**</span> i
    
    <span class="token keyword">return</span> s
</code></pre>
<h3>Q23</h3>
<p>Il faut que la taille de <code class="language-">L</code> soit au minimum égal à la valeur entière du $\log_2(n)$.<br>
Il faut que <code class="language-">i &gt;= 0</code> pour que la boucle de fasse pas d'erreur lors de l'affectation à <code class="language-">res[i]</code>.</p>
<h3>Q24</h3>
<p>Comme on supprime les doublons et que l'on s'arrête si l'espace de solutions n'a pas grossi, au pire, l'algorithme s'arrêtera lorsque tous les croisements possibles seront vus, comme il y en a un nombre fini (borné par $2 * 2^n$ listes de 2 files au maximum) l'algorithme va s'arrêter.</p>
<h3>Q25</h3>
<p>A chaque étape, les nouvelles solutions sont trouvées à partir d'éléments obtenus à l'étape précédente, sinon elles seraient déjà présent dans l'ensemble des solutions.</p>
<p>Le nombre minimum d'étape pour trouver une solution est donc le nombre de fois où l'on a bouclé sur le <code class="language-">while</code> de la fonction recherche.</p>


</article>
    </main>

    <footer class="min-h-[50px] border-t-2 border-gray-200 mt-4">
      <div class="max-w-[1200px] mx-auto px-4 relative">
        <div class="min-h-[50px] flex justify-center items-center">
          <p>
            Cours d'informatique à l'école centrale Marseille
          </p>
        </div>
        <div class="min-h-[50px] flex justify-center items-center absolute right-0 top-0">
          <button onclick="goTop()" id="myBtn" title="Go to top">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
              <path stroke-linecap="round" stroke-linejoin="round" d="M15 11.25l-3-3m0 0l-3 3m3-3v7.5M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
            </svg>
          </button>

          <button onclick="goBottom()" id="myBtn" title="Go to top">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
              <path stroke-linecap="round" stroke-linejoin="round" d="M9 12.75l3 3m0 0l3-3m-3 3v-7.5M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
            </svg>
          </button>
        </div>

      </div>
    </footer>

    <script>
      MathJax
        .startup
        .document
        .getMathItemsWithin(document.body);
    </script>

  </body>
</html>