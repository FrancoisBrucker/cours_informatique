<!DOCTYPE html>
<html lang="fr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>DS 1</title>

    <link href="/cours_informatique/assets/node_modules/prismjs/themes/prism-solarizedlight.min.css" rel="stylesheet">
    <link href="/cours_informatique/assets/node_modules/prismjs/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet">

    <link href="/cours_informatique/assets/stylesheets/main.css" rel="stylesheet">

  </head>
  <body>
    <script>
      window.MathJax = {
        tex: {
          inlineMath: [
            [
              '$', '$'
            ],
            [
              '\\(', '\\)'
            ]
          ]
        },
        svg: {
          fontCache: 'global'
        }
      };

      function goTop() {
        window.scrollTo({top: 0});
      }
      function goBottom() {
        window.scrollTo({top: document.body.scrollHeight});
      }
    </script>
    <script type="text/javascript" id="MathJax-script" src="/cours_informatique/assets/node_modules/mathjax/es5/tex-svg-full.js"></script>

    <header class="border-b-2 border-gray-200 mb-4">
      <div class="max-w-[1200px] mx-auto px-4 relative">
        <div class="min-h-[50px] flex justify-between items-center">
          <a class="mx-2" href="/cours_informatique/">Home</a>
        </div>

        <div class="min-h-[50px] flex justify-center items-center absolute right-0 top-0">
          <a class="mx-2" href="/cours_informatique/about">About</a>
          <button onclick="goTop()" id="myBtn" title="Go to top">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
              <path stroke-linecap="round" stroke-linejoin="round" d="M15 11.25l-3-3m0 0l-3 3m3-3v7.5M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
            </svg>
          </button>

          <button onclick="goBottom()" id="myBtn" title="Go to top">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
              <path stroke-linecap="round" stroke-linejoin="round" d="M9 12.75l3 3m0 0l3-3m-3 3v-7.5M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
            </svg>
          </button>
        </div>

      </div>
    </header>

    <main class="max-w-[1200px] mx-auto px-4">
      
<article>

  <h1>DS 1</h1>
  <div>
    

    
  </div>

  

  <div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
</svg>
<div class="pl-8  mb-2 mr-8">
<p><strong>Sujet</strong></p>
</div><div class="pl-8 mr-8">
<p><a href="ds1_2023_2024.pdf" class="fichier">Étude de l'élément majoritaire</a></p>
<p>Durée du contrôle : 3h.</p>
</div>
</div>
<h2>Barème</h2>
<blockquote>
<p>TBD</p>
</blockquote>
<h2>Corrigé</h2>
<h3>Remarques générales</h3>
<p>Beaucoup de personnes perdent bêtement des points sur les quesions de cours. Il y avant plus de 6 points à prendre uniquement sur elles ! Il faut que vous connaissiez :</p>
<ul>
<li>la définition de la complexité d'un problème</li>
<li>comment on calcule un minorant pour le problème de la recherche (c'est le même argument qui est repris partout)</li>
<li>la complexité du problème du tri et savoir expliquer pourquoi (avec le minorant et un majorant du cours)</li>
<li>connaître le principe algorithmique de diviser. Vous êtes plus de la moitié à avoir oublié qu'après la division il faut recombiner et surotut que c'est cette étape qui est crutiale pour avoir une complexité faible, pas la division.</li>
<li>connaître le master theorem et son application pour le problème du tri fusion</li>
</ul>
<p>Parfois, vos arguments deviennent un peu vaseux quand ce n'est pas clair. La plupart du temps en algoirthmie, il suffit de peu de mots bien choisi pour expliciter ce qu'on fait. Si vous avez besoin de plusieurs paragraphes c'est que soit ce n'est pas clair, soit c'est faux.</p>
<p>Lorsque l'on vous demande de voir ce que fait un algorithme sur des exemples, faites le ! Beaucoup décrivent ce qu'ils pensent que leur algorithme fait et pas ce qu'il fait réllement... Il faut prendre ces questions comme une oportunité de vérifier que ce que vous avez fait est juste.</p>
<h3>Exercice 1 : encadrement du problême</h3>
<h4>1.1</h4>
<blockquote>
<p>Combien d'éléments majoritaires peut avoir un tableau ? Prouvez-le rigoureusement</p>
</blockquote>
<p>Il ne peut y avoir qu'un seul élément majoritaire car il contient strictement plus de la moitié des éléments. S'il y en avait 2 avec respectivement $n_1$ et $n_2$ éléments on aurait $n = n_1 + n_2 \geq (E(n / 2) + 1) + (E(n / 2) + 1) \geq n + 1$ ce qui est impossible ($E()$ désignant la partie entière).</p>
<h4>1.2.1</h4>
<blockquote>
<p>Montrez que quelle que soit la taille $n &gt; 2$ du tableau et quel que soit $0 \leq i &lt; n$, il existe un tableau $T$ d'élément majoritaire $e$ tel que $T[i] \neq e$.</p>
</blockquote>
<p>Pour tout $n &gt; 2$ on a $\frac{n}{2} + 1 &lt; n$, on peut donc créer un tableau de taille $n$ ayant un deux valeurs distinctes une pour tous les $T[j]$ avec $j\neq i$ (qui sera donc l'élément majoritaire) et l'autre pour $T[i]$.</p>
<h4>1.2.2</h4>
<blockquote>
<p>Montrez que quelle que soit la taille $n \geq 1$ du tableau et quel que soit $0 \leq i &lt; n$, il existe un tableau $T$ d'élément majoritaire $e$ tel que $T[i] = e$.</p>
</blockquote>
<p>Le tableau avec une unique valeur répond trivialement à la question.</p>
<h4>1.2.3</h4>
<blockquote>
<p>Montrez que quels que soient $n&gt;2$ et $0 \leq i &lt; n$, il existe toujours deux tableaux d'entiers $T$ et $T'$ de taille $n$ tels que :</p>
<ul>
<li>$T[j] = T'[j]$ pour tout $j \neq i$,</li>
<li>$T$ admet un élément majoritaire,</li>
<li>$T'$ n'admet pas d'élément majoritaire.</li>
</ul>
</blockquote>
<p>La question 1.2.1 nous montre que l'on peut créer un tableau possédant un élément majoritaire et tel que $T[i]$ ne soit pas cet élément. On peut de plus s'arranger pour que cet élément majoritaire soit exactement présent la partie entière de $\frac{n}{2}$ plus 1 fois (on remplace si nécessaire les éléments surnuméraires par $T[i]$).</p>
<p>Le tableau $T'$ tel que :</p>
<ul>
<li>$T[j] = T'[j]$ pour tout $j \neq i$</li>
<li>$T'[i]$ vaut l'élément majoritaire de $T$</li>
</ul>
<p>Répond à la question.</p>
<h4>1.2.4</h4>
<blockquote>
<p>Déduisez-en que la complexité du problème de l'élément majoritaire est en $\Omega(n)$, avec $n$ la taille du tableau (il n'existe pas d'algorithme permettant de résoudre le problème de l'élément majoritaire en strictement moins de $n$ opérations pour tout $n &gt; N_0$).</p>
</blockquote>
<p>On procède comme dans le cours pour démontrer <a href="/cours_informatique/cours/algorithmie/complexit%C3%A9-probl%C3%A8me/#complexit%C3%A9-recherche">la complexité du problème de la recherche</a>.</p>
<p>On suppose qu'il existe un algorithme prenant strictement moins que $n$ opérations pour trouver l'élément majoritaire de tout tableau de taille $n &gt; N_0$. Prenons un tableau $T$ comme dans la question précédente. On a alors deux cas :</p>
<ul>
<li>soit l'algorithme a parcouru toutes les cases de $T$ possédant l'élément majoritaire et il a eu besoin d'au moins $\frac{n}{2} + 1 = \Omega(n)$ opérations,</li>
<li>soit il n'a pas parcouru toutes les cases de $T$ possédant l'élément majoritaire, disons $T[i]$, et on crée le tableau $T'$ identique à $T$ sauf pour la case d'indice $i$ : $T'$ ne possède pas d'élément majoritaire mais l'algorithme va donner la même réponse que pour $T$. Contradiction.</li>
</ul>
<h4>1.3.1</h4>
<blockquote>
<p>Donnez le pseudo-code et la preuve d'une fonction <code class="language-">compte</code> de complexité $\mathcal{O}(n)$ telle que <code class="language-">compte(T, x)</code> est le nombre d'occurrences de $x$ dans $T$ (si $x\notin T$, <code class="language-">compte(T, x)</code> vaut 0).</p>
</blockquote>
<pre class="language-python " style="counter-reset: linenumber 0"><code class="language-python">
<span class="token keyword">def</span> <span class="token function">compte</span><span class="token punctuation">(</span>T<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">:</span>

    nombre <span class="token operator">=</span> <span class="token number">0</span>
    <span class="token keyword">for</span> element <span class="token keyword">in</span> T<span class="token punctuation">:</span>
        <span class="token keyword">if</span> element <span class="token operator">==</span> x<span class="token punctuation">:</span>
            nombre <span class="token operator">+=</span> <span class="token number">1</span>
    <span class="token keyword">return</span> nombre
</code></pre>
<p>La complexité de la fonction est en $\mathcal{O}(n)$ où $n$ est la taille de $T$ puisque :</p>
<ul>
<li>toutes les lignes sont de complexité $\mathcal{O}(1)$</li>
<li>la boucle <code class="language-">for</code> est exécutée la taille de $T$ fois, c'est à dire $\mathcal{O}(n)$ fois.</li>
</ul>
<p>L'invariant de boucle que l'on va utiliser pour prouver l'algorithme <code class="language-">compte</code> est : au bout de la $i$ ème itération, <code class="language-">nombre</code> vaut le nombres de fois où <code class="language-">x</code> est présent dans les $i$ premières cases de $T$.</p>
<ol>
<li>l'invariant est clairement vérifié à la fin de la première itération</li>
<li>si l'invariant est vérifié à la fin de la $i$ ème itération, , comme la $i+1$ itération vérifie si <code class="language-">x == T[i]</code> et ajoute 1 à <code class="language-">nombre</code> si c'est le cas, l'invariant est toujours vérifié à la fin de la $i + 1$ ème itération.</li>
<li>l'invariant est vrai en sortie de boucle, c'est à dire après avoir parcouru tous les éléments de $T$ : <code class="language-">nombre</code> vaut bien le nombre de fois où <code class="language-">x</code> est présent dans $T$.</li>
</ol>
<h4>1.3.2</h4>
<blockquote>
<p>Utilisez la question précédente pour créer algorithme en $\mathcal{O}(n^2)$ qui prend un tableau d'entiers en paramètre et rend un élément majoritaire de ce tableau s'il existe, ou <code>None</code> sinon.</p>
</blockquote>
<pre class="language-python line-numbers" style="counter-reset: linenumber 0"><code class="language-python">
<span class="token keyword">def</span> élément_majoritaire<span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">for</span> x <span class="token keyword">in</span> T<span class="token punctuation">:</span>
        <span class="token keyword">if</span> compte<span class="token punctuation">(</span>T<span class="token punctuation">,</span> x<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token builtin">len</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> x
    <span class="token keyword">return</span> <span class="token boolean">None</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>Le test de la ligne 4 est en $\mathcal{O}(n)$ où $n$ est la taille de $T$ puisqu'il faut exécuter <code class="language-">compte</code>. Toutes les autres lignes sont de complexité $\mathcal{O}(1)$ et comme la boucle <code class="language-">for</code> est exécutée la taille de $T$ fois, on exécute <code class="language-">compte</code> $n$ fois ce qui porte la complexité de l'algorithme à $\mathcal{O}(n^2)$.</p>
<p>L'invariant de boucle que l'on va utiliser pour prouver l'algorithme <code class="language-">élément_majoritaire</code> est : au bout de la $i$ ème itération,aucun des $i$ premières cases de $T$ n'est un élément majoritaire.</p>
<ol>
<li>l'invariant est clairement vérifié à la fin de la première itération</li>
<li>si l'invariant est vérifié à la fin de la $i$ ème itération, comme la $i+1$ itération vérifie si <code class="language-">T[i]</code> est un élément majoritaire, l'invariant est toujours vérifié à la fin de la $i + 1$ ème itération.</li>
<li>l'invariant est vrai en sortie de boucle, c'est à dire après avoir parcouru tous les éléments de $T$ : si on arrive en ligne 6, c'est que $T$ n'a pas d'élément majoritaire. Si l'on s'arrête à la fin de la $i$ ème itération c'est que <code class="language-">T[i-1]</code> est l'élément majoritaire de $T$.</li>
</ol>
<h4>1.3.3</h4>
<blockquote>
<p>Explicitez en quelques phrases le fonctionnement de l'algorithme de la question précédente si, en entrée, on lui donne les deux exemples du début de l'énoncé.</p>
</blockquote>
<p>En utilisant le premier tableau, la fonction va parcourir tous les éléments de $T$ et pour chacun effectuer la fonction <code class="language-">compte</code> sans trouver d'élément présent 5 fois ou plus.</p>
<p>En utilisant le premier tableau, la fonction sortir au bout de la première itération puisque 2 est l'élément majoritaire de $T$.</p>
<h4>1.3.4</h4>
<blockquote>
<p>En déduire que la complexité du problème de l'élément majoritaire est en $\mathcal{O}(n^2)$</p>
</blockquote>
<p>L'algorithme de la question 1.3.2 résoud le problème de la recherche d'un élément majoritaire, sa complexité est donc un majorant de la complexité du problème.</p>
<h3>Exercice 2 : Tris</h3>
<h4>2.1.1</h4>
<blockquote>
<p>Donnez le nom d'un algorithme de tri ayant une complexité de $\mathcal{O}(n\ln(n))$ avec $n$ la taille du tableau à trier. Vous expliciterez son fonctionnement en quelques phrases.</p>
</blockquote>
<p>L'algorithme vu en cours qui a cette complexité est <a href="/cours_informatique/cours/algorithmie/probl%C3%A8me-tris/algorithme-fusion" class="interne">le tri fusion</a> il utilise le principe algorithmique <em>diviser pour régner</em>. L'idée est de composer une liste triée à partir de deux listes elles même triées. L'algorithme est le suivant :</p>
<ol>
<li>on scinde la liste en 2 parties égale que l'on trie en utilisant la récursion</li>
<li>on crée une liste triée à partir des deux sous-listes triées (ceci peut se faire en $\mathcal{O}(n)$ opérations)</li>
<li>on rend la liste finale triée</li>
</ol>
<p>La complexité nous est donnée par le master théorème.</p>
<h4>2.1.2</h4>
<blockquote>
<p>Justifiez en quelques phrases que le problème du tri est en $\Omega(n\ln(n))$.</p>
</blockquote>
<p>Il faut pouvoir distinguer parmi tous les ordres possibles et il y en a $n!$. Il faut donc au moins $\Omega(\ln(n!))$ tests pour disinguer tous les cas. On conclut en remarquant que $\Omega(\ln(n!)) = \Omega(n\ln(n))$.</p>
<h4>2.1.3</h4>
<blockquote>
<p>Déduisez-en que le problème du tri est en $\Theta(n\ln(n))$.</p>
</blockquote>
<ol>
<li>On a un algorithme en $\mathcal{O}(n\ln(n))$ pour résoudre le problème</li>
<li>On sait qu'il faut au moins $\Omega(n\ln(n))$ opérations</li>
</ol>
<p>Les deux conditions ci-dessus montrent, par définiton, que le problème du tri est en $\Theta(n\ln(n))$.</p>
<h4>2.2.1</h4>
<blockquote>
<p>Si $T$ est trié, démontrez l'existence d'un indice $i$ (que vous expliciterez) tel que, si $T$ admet un élément majoritaire $x$, alors $x=T[i]$.</p>
</blockquote>
<p>Si le tableau <code class="language-">T</code> est trié et qu'il contient un élément majoritaire, alors c'est l'élément à la position <code class="language-">len(T) // 2</code> (<code class="language-">//</code> est la division entière). Supposons en effet que <code class="language-">T[len(T) // 2]</code> ne soit pas un élément majoritaire de <code class="language-">T</code>. Comme les éléments de <code class="language-">T</code> strictement plus grand (<em>resp.</em> strictement plus petit) que <code class="language-">T</code> sont tous d'indices strictement plus grand (<em>resp.</em> strictement plus petit) que <code class="language-">len(T) // 2</code> il y en a au plus <code class="language-">len(T) // 2</code> : ils ne peuvent pas être majoritaire. Ainsi si <code class="language-">T[len(T) // 2]</code> n'est pas un élément majoritaire de <code class="language-">T</code>, le tableau ne possède pas d'éléments majoritaire.</p>
<h4>2.2.2</h4>
<blockquote>
<p>Déduisez-en un algorithme itératif, dont vous donnerez le pseudo-code et la preuve, plus efficace que celui de l'exercice 1.3.2 pour résoudre le problème de l'élément majoritaire.</p>
</blockquote>
<pre class="language-python " style="counter-reset: linenumber 0"><code class="language-python">
<span class="token keyword">def</span> <span class="token function">element_majoritaire</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">:</span>
    T<span class="token punctuation">.</span>sort<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> compte<span class="token punctuation">(</span>T<span class="token punctuation">[</span><span class="token builtin">len</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span> <span class="token operator">//</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> T<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token builtin">len</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> T<span class="token punctuation">[</span><span class="token builtin">len</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span> <span class="token operator">//</span> <span class="token number">2</span><span class="token punctuation">]</span>
    <span class="token keyword">return</span> <span class="token boolean">None</span>
</code></pre>
<p>L'algorithme commence par trier le tableau et compte le nombre d'occurence de l'élément au milieu. Ci cette occurence est majoritaire, on a trouvé notre  élément majoritaire et si elle ne l'est pas, la question 2.2.1 montre que le tableau ne peut avoir d'élément majoritaire,</p>
<p>Sa complexité est ramené à la complexité du tri plus une fois la complexité de <code class="language-">compte</code> : la complexité est donc en $\mathcal{O}(len(T) \ln(len(T)))$.</p>
<h4>2.2.3</h4>
<blockquote>
<p>Explicitez en quelques phrases le fonctionnement de l'algorithme de la question précédente si, en entrée, on lui donne les deux exemples du début de l'énoncé.</p>
</blockquote>
<ul>
<li>En utilisant le premier tableau, son tri va donner le tableau <code class="language-">T = [2, 4, 4, 4, 4, 4, 5, 5, 5]</code> et son milieu <code class="language-">T[4]</code> vaut 4 qui est majoritaire.</li>
<li>En utilisant le second tableau, son tri va donner le tableau <code class="language-">T = [2, 2, 2, 2, 2, 2, 3, 3, 3, 3,  4, 6]</code> et son milieu <code class="language-">T[6]</code> vaut 3 n'est pas majoritaire : le tableau n'a pas d'élément majoritaire.</li>
</ul>
<h3>Exercice 3 : Diviser pour régner</h3>
<h4>3.1</h4>
<blockquote>
<p>Expliciter le principe algorithmique de <em>diviser pour régner</em></p>
</blockquote>
<p>Le principe algorithmique <em>diviser pour régner</em> est décrit dans le cours <a href="/cours_informatique/cours/algorithmie/probl%C3%A8me-tris/algorithme-fusion/#diviser-pour-r%C3%A9gner" class="interne">ici</a> :</p>
<p>Un algorithme de la forme <strong><em>diviser pour régner</em></strong> fonctionne en deux parties :</p>
<ol>
<li><strong>résoudre</strong> $k$ sous-problèmes du problème initial</li>
<li><strong>combiner</strong> les $k$ solutions des sous-problèmes en une solution du problème initial</li>
</ol>
<h4>3.2.1</h4>
<blockquote>
<p>Montrez que si $T$ admet un élément majoritaire $x$, alors $x$ est un élément majoritaire de $T_1$ ou $T_2$.</p>
</blockquote>
<p>On suppose que $T$ de taille $n$ contient un élément majoritaire $x$. Si $x$ n'est pas majoritaire dans $T_1$, c'est qu'il est présent $\frac{n}{4}$ fois ou moins dans $T_1$. On le retrouve donc au moins $\frac{n}{4}+1$ fois dans $T_2$ : c'est un élément majoritaire de $T_2$.</p>
<h4>3.2.2</h4>
<blockquote>
<p>Donnez un algorithme qui détermine, quand $x$ est un élément majoritaire de $T_1$, si $x$ est un élément majoritaire de $T$.</p>
</blockquote>
<p>Il suffit de regarder si <code class="language-">compte(x, T) &gt; len(T) // 2</code> avec <code class="language-">x</code> l'élément majoritaire de $T_1$ ou $T_2$ s'il est différent de <code class="language-">None</code>. Ce qui peut se traduire en pyhton en :</p>
<pre class="language-python " style="counter-reset: linenumber 0"><code class="language-python">
x <span class="token operator">=</span> element_majoritaire<span class="token punctuation">(</span>T1<span class="token punctuation">)</span>
<span class="token keyword">if</span> x <span class="token operator">!=</span> <span class="token boolean">None</span> <span class="token keyword">and</span> <span class="token punctuation">(</span>compte<span class="token punctuation">(</span>x<span class="token punctuation">,</span> T<span class="token punctuation">)</span> <span class="token operator">></span> n <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">return</span> x

x <span class="token operator">=</span> element_majoritaire<span class="token punctuation">(</span>T2<span class="token punctuation">)</span>
<span class="token keyword">if</span> x <span class="token operator">!=</span> <span class="token boolean">None</span> <span class="token keyword">and</span> <span class="token punctuation">(</span>compte<span class="token punctuation">(</span>x<span class="token punctuation">,</span> T<span class="token punctuation">)</span> <span class="token operator">></span> n <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">return</span> x
</code></pre>
<h4>3.2.3</h4>
<blockquote>
<p>Déduisez-en un algorithme récursif, plus efficace que celui de l'exercice 1.3.2, pour résoudre le problème.</p>
</blockquote>
<pre class="language-python " style="counter-reset: linenumber 0"><code class="language-python">
<span class="token keyword">def</span> <span class="token function">element_majoritaire</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">:</span>
    n <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span>
    <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> T<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
    x <span class="token operator">=</span> element_majoritaire<span class="token punctuation">(</span>T<span class="token punctuation">[</span><span class="token punctuation">:</span>n<span class="token operator">//</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> x <span class="token operator">!=</span> <span class="token boolean">None</span> <span class="token keyword">and</span> compte<span class="token punctuation">(</span>x<span class="token punctuation">,</span> T<span class="token punctuation">)</span> <span class="token operator">></span> n <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> x

    x <span class="token operator">=</span> element_majoritaire<span class="token punctuation">(</span>T<span class="token punctuation">[</span>n<span class="token operator">//</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> x <span class="token operator">!=</span> <span class="token boolean">None</span> <span class="token keyword">and</span> compte<span class="token punctuation">(</span>x<span class="token punctuation">,</span> T<span class="token punctuation">)</span> <span class="token operator">></span> n <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> x

    <span class="token keyword">return</span> <span class="token boolean">None</span>
</code></pre>
<p>La condition d'arrêt est pour des tailles de tableaux égales à $1 = 2^0$. Pour laquelle on trouve bien l'élément majoritaire.</p>
<p>On suppose alors par récurrence que l'algoerithme fonctionne pour $n = 2^i$ et on vérifie qu'il continue de fnctionner pour $n'=2^{i+1}$. Ceci est évidant car on applique directement la condition de 3.2.2</p>
<p>La complexité $C(n)$ de l'algoirthme est régit par l'équation de récurrence : $C(n) = 2 \cdot C(n/2) + \mathcal{O}(n)$ puisque la complexité de <code class="language-">compte</code> est linéaire. Cette équation est la méme que pour le tri fusion, ce qui donne une complexité de $C(n) = \mathcal{O}(n\log(n))$.</p>
<h4>3.3.1</h4>
<blockquote>
<p>Reprenez cet exercice sans supposer que $n$ est une puissance de 2. Que faut-il changer pour que l'algorithme continue de fonctionner ?</p>
</blockquote>
<p>La taille de $T_1$ peut maintenant être différente de la taille de $T_2$. Cette différence ne peut cependant pas être plus importante que 1 et cela ne change rien pour leurs éléments majoritaires. Il ne faut donc rien changer, l'algorithme continue de fonctionner.</p>
<h4>3.3.2</h4>
<blockquote>
<p>Explicitez en quelques phrases le fonctionnement de l'algorithme de la question précédente si, en entrée, on lui donne les deux exemples du début de l'énoncé.</p>
</blockquote>
<p>Pour le premier exemple, le tableau <code class="language-">[2, 4, 5, 4, 5, 4, 5, 4, 4]</code> va être découpé en <code class="language-">[2, 4, 5, 4]</code> et en <code class="language-">[5, 4, 5, 4, 4]</code>. Le second tableau à un élément majoriaire, 4, qui est aussi un élément majoritaire du tableau initial.</p>
<p>Pour le second exemple, le tableau <code class="language-">[2, 2, 3, 6, 4, 3, 2, 2, 3, 3, 2, 2]</code> va être découpé en <code class="language-">[2, 2, 3, 6, 4, 3]</code> et en <code class="language-">[2, 2, 3, 3, 2, 2]</code>.</p>
<h3>Exercice 4 : Piles</h3>
<h4>4.1</h4>
<blockquote>
<p>Coder avec des listes de python la structure de pile. Vous coderez les fonctions :</p>
<ul>
<li><code class="language-">crée_pile_vide() -&gt; list</code></li>
<li><code class="language-">empile(x: int or None, pile: list)</code></li>
<li><code class="language-">dépile(pile:list) -&gt; int or None</code></li>
</ul>
</blockquote>
<p>On utilise des liste en python pour simuler des piles, avec les méthodes <code class="language-">append</code> et <code class="language-">pop</code>.</p>
<pre class="language-python " style="counter-reset: linenumber 0"><code class="language-python"><span class="token keyword">def</span> crée_pile_vide<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>


<span class="token keyword">def</span> <span class="token function">empile</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> pile<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> x <span class="token operator">!=</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
        pile<span class="token punctuation">.</span>append<span class="token punctuation">(</span>x<span class="token punctuation">)</span>

<span class="token keyword">def</span> dépile<span class="token punctuation">(</span>pile<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>pile<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">:</span>
        x <span class="token operator">=</span> pile<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> x
    <span class="token keyword">else</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token boolean">None</span>

</code></pre>
<h4>4.2.1</h4>
<blockquote>
<p>La valeur de $y$ à la ligne 6 est-elle une valeur de $P_1$ ? Et si oui, laquelle ?</p>
</blockquote>
<p>Si $y$ est <code class="language-">None</code> c'est que la pile $P_1$ est vide et sinon $y$ vut le dernier élément empilé.</p>
<h4>4.2.2</h4>
<blockquote>
<p>Montrez qu'à chaque itération de la boucle for, $x$ est empilé soit dans $P_1$, soit dans $P_2$.</p>
</blockquote>
<p>Il y a cinq cas possibles, mutuellement exclusifs :</p>
<ul>
<li>soit $y$ est <code class="language-">None</code> : $x$ est empilé dans $P_1$</li>
<li>soit $y \neq x$ : $x$ est empilé dans $P_1$</li>
<li>soit $y = x$ et la pile $P_2$ est vide : $x$ est empilé dans $P_2$</li>
<li>soit $y = x$, la pile $P_2$ est non vide et on la dépile en $z$ et $z = x$ : $z$puis $x$ sont empilés dans $P_2$</li>
<li>soit $y = x$, la pile $P_2$ est non vide et on la dépile en $z$ et $z \neq x$ : $z$ puis $x$ sont empilés dans $P_1$</li>
</ul>
<h4>4.2.3</h4>
<blockquote>
<p>Donnez le contenu des deux piles $P_1$ et $P_2$ {\bf à la fin de l'algorithme} si, en entrée, on lui donne les deux exemples du début de l'énoncé.</p>
</blockquote>
<ul>
<li>Pour $T = [2, 4, 5, 4, 5, 4, 5, 4, 4]$ on obtient :
<ul>
<li>$P_1 = [2, 4, 5, 4, 5, 4, 5, 4]$</li>
<li>$P_2=[4]$</li>
</ul>
</li>
<li>Pour $T = [2,2,3,6,4,3,2,2,3,3,2,2]$ on obtient :
<ul>
<li>$P_1 = [2, 3, 6, 4, 3, 2, 3, 2, 3, 2]$</li>
<li>$P_2 = [2, 2]$</li>
</ul>
</li>
</ul>
<h4>4.2.4</h4>
<blockquote>
<p>Quelle est la complexité de l'algorithme ?<br>
Puisqu'empiler et dépiler sont en $\mathcal{O}(1)$ opération, la complexité totale de l'algorithme est en $\mathcal{O}(len(T))$ opérations.</p>
</blockquote>
<h4>4.2.5</h4>
<blockquote>
<p>Montrez que tous les éléments de la pile $P_2$ sont identiques à la fin de l'algorithme.</p>
</blockquote>
<p>On empile dans $P_2$ que si la pile était vide (le cas <code>z == None</code>) ou si le dernier élément de la pile est égal au nouvel élément (<code>z == x</code>). Tous les éléments de $P_2$ sont identiques.</p>
<h4>4.2.6</h4>
<blockquote>
<p>Montrez qu'à la fin de l'algorithme, deux éléments consécutifs de la pile $P_1$ sont toujours différents.</p>
</blockquote>
<p>On empile dans $P_1$ soit :</p>
<ul>
<li>dans le premier <code class="language-">if</code>. dans ce cas là, soit la pile était vide soit le dernier élément de la pile ($y$) est différent de $x$</li>
<li>dans le second <code class="language-">else</code>. Dans ce cas là le denier élément de la pile ($y$) est différent de $x$ car on est dans le premier else et $z$ est différent de $x$ puisqu'on est dans le second else. On a donc $y \neq x \neq z$ et la proprété est vérifiée.</li>
</ul>
<h4>4.2.7</h4>
<blockquote>
<p>Déduisez-en qu'un élément majoritaire, s'il en existe, ne peut être que le dernier élément stocké dans $P_2$ ou le dernier élément stocké dans $P_1$.</p>
</blockquote>
<p>Ala fin de l'algorithme, les éléments de $T$ sont répartis dans deux listes. La première, $P_1$, est alternée et la seconde, $P_2$, est composées d'éléments identiques.</p>
<p>Soit alors $x$ dans $P_1$ mais qui n'est pas dans $P_2$. Il ne peut apparaitre qu'au pire <code>len(P1) // 2 + 1</code> fois dans $P_1$. On a alors plusieurs cas :</p>
<ul>
<li>$P_2$ n'est pas vide (et ne contient pas $x$). De là, $x$ est présent dans $T$ au mieux <code>len(T) // 2</code>. Ce ne peut être un élément majoritaire.</li>
<li>$P_2$ est vide. Pour que $x$ soit un élément majoritaire de $T$ il faut qu'il apparaisse <code>len(P1) // 2 + 1</code> dans $P_1$, donc que ce soit le dernier élément ajouté de $P_1$.</li>
</ul>
<p>On en conclut que si $T$ possède un élément majoritaire, c'est :</p>
<ul>
<li>soit l'élément de $P_2$ si $P_2$ est non vide,</li>
<li>soit le dernier élément de $P_1$ si $P_2$ est vide.</li>
</ul>
<h4>4.3.1</h4>
<blockquote>
<p>Déduisez de la partie précédente un algorithme linéaire en la taille du tableau en entrée pour résoudre le problème de l'élément majoritaire.</p>
</blockquote>
<pre class="language-text " style="counter-reset: linenumber 0"><code class="language-text">Entrées : Un tableau d'entiers T
Programme :
    Soient P1 et P2 les piles issuent de Majorité(T)
    x = dépile(P2)
    Si x == None:
        x = dépile(P1)
    
    si x == None ou si compte(T, x) <= len(T) // 2:
        return None
    return x

</code></pre>
<p>L'algorithme est exacte puisque'il implémente directement la question 4.2.7. Sa complexité est celle de l'exécution de l'algorithme <code class="language-">Majorité</code> plus celle de <code class="language-">compte</code> plus des instruction en $\mathcal{O}(1)$ : sa complexité totale est en $\mathcal{O}(n)$ où $n$ est la taille de $T$.</p>
<h4>4.3.2</h4>
<blockquote>
<p>Quelle est la complexité du problème de l'élément majoritaire ?</p>
</blockquote>
<p>L'algorithme de la question 4.3.1 résoud le problème de l'élément majoriaire en $\mathcal{O}(n)$ opérations et la quesion 1.2.4 a montré qu'il était en $\Omega(n)$, on en déduit donc que la complexité du problème est de $\Theta(n)$.</p>


</article>
    </main>

    <footer class="min-h-[50px] border-t-2 border-gray-200 mt-4">
      <div class="max-w-[1200px] mx-auto px-4 relative">
        <div class="min-h-[50px] flex justify-center items-center">
          <p>
            Cours d'informatique à l'école centrale Marseille
          </p>
        </div>
        <div class="min-h-[50px] flex justify-center items-center absolute right-0 top-0">
          <button onclick="goTop()" id="myBtn" title="Go to top">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
              <path stroke-linecap="round" stroke-linejoin="round" d="M15 11.25l-3-3m0 0l-3 3m3-3v7.5M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
            </svg>
          </button>

          <button onclick="goBottom()" id="myBtn" title="Go to top">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
              <path stroke-linecap="round" stroke-linejoin="round" d="M9 12.75l3 3m0 0l3-3m-3 3v-7.5M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
            </svg>
          </button>
        </div>

      </div>
    </footer>

    <script>
      MathJax
        .startup
        .document
        .getMathItemsWithin(document.body);
    </script>

  </body>
</html>