<!DOCTYPE html>
<html lang="fr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>Confidentialité</title>

    

    <link href="https://prismjs.catppuccin.com/latte.css" rel="stylesheet">

    <link href="/cours_informatique/assets/node_modules/prismjs/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet">
    <script src="/cours_informatique/assets/node_modules/prismjs/plugins/line-numbers/prism-line-numbers.min.js"></script>
    
    <link href="/cours_informatique/assets/stylesheets/main.css" rel="stylesheet">

  </head>
  <body>
    <script>
      window.MathJax = {
        tex: {
          inlineMath: [
            [
              '$', '$'
            ],
            [
              '\\(', '\\)'
            ]
          ]
        },
        svg: {
          fontCache: 'global'
        }
      };

      function goTop() {
        window.scrollTo({top: 0});
      }
      function goBottom() {
        window.scrollTo({top: document.body.scrollHeight});
      }
    </script>
    <script type="text/javascript" id="MathJax-script" src="/cours_informatique/assets/node_modules/mathjax/es5/tex-svg-full.js"></script>

    <header class="border-b-2 border-gray-200 mb-4">
      <div class="max-w-[1200px] mx-auto px-4 relative">
        <div class="min-h-[50px] flex justify-between items-center">
          <a class="mx-2" href="/cours_informatique/">Home</a>
        </div>

        <div class="min-h-[50px] flex justify-center items-center absolute right-0 top-0">
          <a class="mx-2" href="/cours_informatique/about">About</a>
          <button onclick="goTop()" id="myBtn" title="Go to top">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
              <path stroke-linecap="round" stroke-linejoin="round" d="M15 11.25l-3-3m0 0l-3 3m3-3v7.5M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
            </svg>
          </button>

          <button onclick="goBottom()" id="myBtn" title="Go to top">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
              <path stroke-linecap="round" stroke-linejoin="round" d="M9 12.75l3 3m0 0l3-3m-3 3v-7.5M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
            </svg>
          </button>
        </div>

      </div>
    </header>

    <main class="max-w-[1200px] mx-auto px-4">
      
<article>

  <h1>Confidentialité</h1>
  <div>
    

    
  </div>

  

    
<div class="quote relative  py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-purple-500 bg-purple-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-purple-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M5 19a2 2 0 01-2-2V7a2 2 0 012-2h4l2 2h4a2 2 0 012 2v1M5 19h14a2 2 0 002-2v-5a2 2 0 00-2-2H9a2 2 0 00-2 2v5a2 2 0 01-2 2z"></path>
</svg>
<div class="pl-8 mr-8">

<a class="interne" href="/cours_informatique/cours/">Cours</a><span class="px-1">/</span><a class="interne" href="/cours_informatique/cours/sécurité/">Sécurité</a><span class="px-1">/</span><a class="interne" href="/cours_informatique/cours/sécurité/cryptographie/">Cryptographie</a><span class="px-1">/</span><a class="interne" href="/cours_informatique/cours/sécurité/cryptographie/confidentialité/">Confidentialité</a>

</div></div>



    
  

  <p>Le processus d'envoi d'un message confidentiel entre Alice et Bob décrit précédemment doit être ajusté pour être réaliste :</p>
<pre><code>    Alice    |  Eve   |     Bob
-------------|--------|--------------
    m, k     |        |      k
E(k, m) = c -|-- c ---|----&gt; c
             |        | D(k, c) = m
             |        |
espace privé | public |    privé
</code></pre>
<p>On va petit à petit modifier ce schéma pour le rendre utilisable en pratique. Commençons tout d'abord par fixer le code utilisé. On utilise le chiffre de Vernam car il possède deux avantages imbattables :</p>
<ul>
<li>il est à confidentialité parfaite</li>
<li>il est de complexité linéaire et très facile à implémenter</li>
</ul>
<p>On obtient alors le schéma suivant :</p>
<pre><code>    Alice    |  Eve   |     Bob
-------------|--------|--------------
    m, k     |        |      k
  k ⊕ m = c -|-- c ---|----&gt; c
             |        |  k ⊕ c = m
             |        |
espace privé | public |    privé
</code></pre>
<p>Pour que le chiffre de Vernam fonctionne, il faut que la clé soit générée de façon uniforme. Attelons-nous à ça.</p>
<h2>Génération de clés uniformes</h2>
<p>La clé générée doit être uniforme pour qu'un attaquant potentiel ne puisse pas avoir le moindre indice sur celle-ci. Ceci est impossible à faire avec un algorithme qui est par définition déterministe. On utilise ainsi des systèmes physiques (souvent couplés à des algorithmes et intégré directement sur le processeur) appelé <em><strong>TRNG</strong></em> pour <em>True Random Number Generator</em> pour cela.</p>
<p>Nous ne rentrerons pas en détail ici sur les moyens de générer de tels nombres, le lecteur intéressé pourra visiter le lien suivant :</p>
<div class="quote relative  py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-cyan-500 bg-cyan-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-cyan-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z"></path>
</svg>
<div class="pl-8 mr-8">
<p>Pour en savoir plus :</p>
<p><a href="/cours_informatique/cours/misc/al%C3%A9atoire/nombres-al%C3%A9atoires" class="interne"><em>True Random Number Generator</em></a></p>
</div></div>

<p>Ce qu'il faut en retenir pour nous c'est que :</p>
<div class="quote relative py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-red-500 bg-red-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-red-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"></path>
</svg>
<div class="pl-8 mb-2 mr-8">
<p><strong>À retenir</strong></p>
</div><div class="pl-8 mr-8">
<p>Générer des nombre vraiment aléatoire avec un ordinateur est possible en utilisant des systèmes physiques embarqués. C'est cependant un processus compliqué et coûteux en temps.</p>
</div></div>

<h2>Partager la clé</h2>
<p>Il est cependant irréaliste qu'Alice et Bob aient connaissance de la clé avant de se transmettre un message, sinon aucune communication sécurisée ne serait possible entre 2 ordinateurs. Il faut utiliser un moyen pour qu'Alice et/ou Bob puissent générer une clé puis se la transmettre de façon sécurisée.</p>
<p>Ceci est possible en utilisant des problèmes dont que l'on ne sait pas algorithmiquement résoudre efficacement :</p>
<div class="quote relative py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-fuchsia-500 bg-fuchsia-100">
  <svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-fuchsia-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
    <path stroke-linecap="round" stroke-linejoin="round" d="M5.25 5.653c0-.856.917-1.398 1.667-.986l11.54 6.348a1.125 1.125 0 010 1.971l-11.54 6.347a1.125 1.125 0 01-1.667-.985V5.653z"></path>
  </svg>
<div class="pl-8 mr-8">
<p><a href="partager-secret" class="interne">Partager un secret</a></p>
</div></div>

<p>Le schéma de transmission confidentiel devient alors :</p>
<pre><code>    Alice    |         |     Bob
    privé    | public  |    privé
-------------|---------|--------------
     m       |         |
             |         |
     a ---v  |         |  v--- b           # générés par un TRNG
     k &lt;--===|= A = B =|===--&gt; k           # protocole de partage de clé sécurisé
             |         |
  k ⊕ m = c -|--- c ---|----&gt; c
             |         |  k ⊕ c = m
             |         |
</code></pre>
<h2>Notion de sécurité</h2>
<p>La sécurisation du protocole de transmission de la clé par le protocole de Diffie-Hellmann dépend de la complexité du meilleur algorithme (connu) permettant de résoudre le problème du logarithme discret. Elle dépend du ratio entre le temps nécessaire pour le décrypter et la durée de vie du message.</p>
<p>Formalisons ce concept avec la notion de fonctions à sens unique.</p>
<h3>Fonctions à sens unique</h3>
<div class="quote relative py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-emerald-500 bg-emerald-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-emerald-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
  <path stroke-linecap="round" stroke-linejoin="round" d="M13.19 8.688a4.5 4.5 0 011.242 7.244l-4.5 4.5a4.5 4.5 0 01-6.364-6.364l1.757-1.757m13.35-.622l1.757-1.757a4.5 4.5 0 00-6.364-6.364l-4.5 4.5a4.5 4.5 0 001.242 7.244"></path>
</svg>
<div class="pl-8 mr-8">
<p><a href="https://en.wikipedia.org/wiki/One-way_function">One way function</a></p>
</div></div>

<p>En gros, une fonction $f$ est à sens unique s'il est :</p>
<ul>
<li>facile de calculer $f(x) = y$ avec un algorithme efficace</li>
<li>impossible de trouver $x$ sachant $f(y)$ avec un algorithme efficace</li>
</ul>
<p>Ce qui donne la définition suivante :</p>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
</svg>
<div class="pl-8 mb-2 mr-8">
<p><strong>Définition</strong></p>
</div><div class="pl-8 mr-8">
<p>Une fonction $f: \{0, 1\}^t \rightarrow \{0, 1\}^t$ dont il existe un algorithme efficace pour la calculer est <strong><em>à sens unique</em></strong> si pour tout algorithme efficace $A$, la probabilité suivante est négligeable :</p>
<div>
$$
\Pr_{x \xleftarrow{U} \{0, 1\}^t}[f(F(f(x))) = f(x)]
$$
</div>
</div></div>

<p>En utilisant les définitions de efficace et négligeable suivantes :</p>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
</svg>
<div class="pl-8 mb-2 mr-8">
<p><strong>Définition</strong></p>
</div><div class="pl-8 mr-8">
<ul>
<li>une fonction $f(n)$ est <strong><em>efficace</em></strong> si $f(n) = \mathcal{O}(n^d)$ pour <strong>un</strong> entier $d$.</li>
<li>une fonction $f(n)$ est <strong><em>négligeable</em></strong> si $f(n) = \mathcal{O}(1/n^d)$ pour <strong>tout</strong> entier $d$.</li>
</ul>
</div></div>

<div class="quote relative  py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-cyan-500 bg-cyan-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-cyan-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z"></path>
</svg>
<div class="pl-8 mr-8">
<p>On peut de façon équivalente dire que $f(n)$ est négligeable si $f(n)n^d$ tend vers 0 en plus l'infini pour tout $d$.</p>
</div></div>

<p>L'intérêt de cette formalisation est que négligeabilité se compose tout comme l'efficacité (somme et produit de polynôme restent des polynômes) :</p>
<ul>
<li>$p(n) + p(n)$ reste efficace si $p(n)$ et $p(n)$ le sont</li>
<li>$p(n) \cdot p(n)$ reste efficace si $p(n)$ et $p(n)$ le sont</li>
<li>$\epsilon(n) + \epsilon(n)'$ reste négligeable si $\epsilon(n)$ et $\epsilon(n)'$ le sont</li>
<li>$\epsilon(n) \cdot \epsilon(n)'$ reste négligeable si $\epsilon(n)$ et $\epsilon(n)'$ le sont</li>
<li>$p(n) \cdot \epsilon(n)$ reste négligeable si $\epsilon(n)$ l'est et $p(n)$ est efficace</li>
</ul>
<div class="quote relative py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-red-500 bg-red-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-red-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"></path>
</svg>
<div class="pl-8 mb-2 mr-8">
<p><strong>À retenir</strong></p>
</div><div class="pl-8 mr-8">
<p>On supposera toujours pour la suite que :</p>
<ul>
<li>les adversaires n'ont à leurs dispositions que des algorithmes <strong><em>efficaces</em></strong>, c'est à dire polynomiaux</li>
<li>qu'on ne veut consentir qu'une possibilité de réussite <strong><em>négligeable</em></strong></li>
</ul>
</div></div>

<p>On voit bien l'intérêt pour le chiffrement de ce type de fonction : on cache dans le résultat d'une fonction ce que l'on veut transmettre. C'est ce qu'on a fait avec le logarithme discret dans le protocole de Diffie-Hellman et que l'on fera avec le problème d la factorisation lorsque l'on étudiera le problème de l'authentification.</p>
<p>Ces deux problèmes sont (très fortement) soupçonnées de faire partie de ce type de fonctions. Seulement soupçonné car on a la proposition suivante :</p>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
</svg>
<div class="pl-8 mb-2 mr-8">
<p><strong>Proposition</strong></p>
</div><div class="pl-8 mr-8">
<p>S'il existe des fonctions à sens unique, alors $P \neq NP$</p>
</div></div>

<div class="relative drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-indigo-500 bg-indigo-100">
<details class="group" open="">
<summary class="list-none py-0.5">
<svg class="group-open:hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M9 5l7 7-7 7"></path>
</svg>
<svg class="group-open:block hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7"></path>
</svg>
<div class="pl-8 font-bold inline-block">
<p>preuve</p>
</div>
<svg class="group-open:hidden inline-block pl-3 w-10 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M5 12h.01M12 12h.01M19 12h.01M6 12a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0z"></path>
</svg>
</summary>
<div class="mx-8 pb-2">
<p>Dérive directement de ce que l'<a href="/cours_informatique/cours/algorithmie/probl%C3%A8me-SAT/#algorithme-SAT" class="interne">on a vu avec le problème SAT</a> : il est équivalent pour SAT de trouver une entrée si on a la solution que de trouver la solution si on a une entrée. On a donc l'implication suivante : Si $P = NP$ alors il ne peut exister de fonction à sens unique.</p>
</div>
</details>     
</div>
<p>Notez que :</p>
<ul>
<li>la réciproque n'est pas démontrée</li>
<li>il y a très peu de chance qu'on arrive à en exhiber une fonction à sens unique</li>
</ul>
<p>Tout algorithme de chiffrement est ainsi basé sur des suppositions. Pour éviter de tout construire sur du sable, on cherche à avoir au moins des preuves de constructions pour qu'il suffise de changer un algorithme si devient clair que le problème associé n'est pas à sens unique plutôt que de changer toute la méthode. C'est le but de la section suivante.</p>
<h3>Sémantiquement sécurisé</h3>
<!-- TBD

Ici faire directement le découpage avec des permutations. Ne plus parler des G(k). On utilise directement chacha20 avec les justifications de constructions

 -->
<p>Si les meilleurs algorithmes de résolution sont connus (ce qui n'est jamais vraiment assuré) on peut déterminer une taille de clé qui garantissent un temps de décryptage trop important. Formalisons cette notion :</p>
<div class="quote relative py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-fuchsia-500 bg-fuchsia-100">
  <svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-fuchsia-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
    <path stroke-linecap="round" stroke-linejoin="round" d="M5.25 5.653c0-.856.917-1.398 1.667-.986l11.54 6.348a1.125 1.125 0 010 1.971l-11.54 6.347a1.125 1.125 0 01-1.667-.985V5.653z"></path>
  </svg>
<div class="pl-8 mr-8">
<p><a href="d%C3%A9finition-s%C3%A9curit%C3%A9" class="interne">Sémantiquement sécurisée</a></p>
</div></div>

<h2>Transmission</h2>
<p>La méthode de chiffrement utilisant le code de Verna n'est pas directement utilisable en pratique car, la clé de chiffrement ne devant pas être répétée pour garantir l'inviolabilité du chiffrement, il faudrait utiliser le protocole de Diffie-Hellman pour générer des clés différentes pour chaque partie du message à chiffrer ce qui est trop coûteux en temps et empêcherait.</p>
<p>On utilise donc un générateur de nombre pseudo-aléatoire cryptographique (<em>Cryptographic Pseudo-Random Number Generator</em>) pour générer assez de bit à partir de la clé pour chiffrer le message entier :</p>
<pre><code>    Alice    |         |     Bob
    privé    | public  |    privé
-------------|---------|--------------
     m       |         |
             |         |
     a ---v  |         |  v--- b           # générés par un TRNG
     k &lt;--===|= A = B =|===--&gt; k           # protocole de partage de clé sécurisé
             |         |
  G(k) = K   |         |  G(k) = K         # générés par un CPRNG
             |         |
  K ⊕ m = c -|--- c ---|----&gt; c
             |         |  K ⊕ c = m
</code></pre>
<div class="quote relative py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-fuchsia-500 bg-fuchsia-100">
  <svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-fuchsia-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
    <path stroke-linecap="round" stroke-linejoin="round" d="M5.25 5.653c0-.856.917-1.398 1.667-.986l11.54 6.348a1.125 1.125 0 010 1.971l-11.54 6.347a1.125 1.125 0 01-1.667-.985V5.653z"></path>
  </svg>
<div class="pl-8 mr-8">
<p><a href="nombres-pseudo-al%C3%A9atoires-cryptographiques" class="interne">Nombres pseudo aléatoires cryptographiques</a></p>
</div></div>

<p>Avoir un CPRNG suffit pour garantir un chiffrement de Vernam sémantiquement sécurisé :</p>
<p><span id="chiffre-CPRNG"></span></p>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
</svg>
<div class="pl-8 mb-2 mr-8">
<p><strong>Proposition</strong></p>
</div><div class="pl-8 mr-8">
<p>Si $G: \{0, 1\}^s \rightarrow \{0, 1\}^n$, avec $s &lt;&lt;n$ est un  CPRNG, alors :</p>
<ul>
<li>$E(k, m) = G(k) \oplus m$</li>
<li>$D(k, m) = E(k, m)$</li>
</ul>
<p>est une méthode de chiffrement sécurisée.</p>
</div></div>

<div class="relative drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-indigo-500 bg-indigo-100">
<details class="group" open="">
<summary class="list-none py-0.5">
<svg class="group-open:hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M9 5l7 7-7 7"></path>
</svg>
<svg class="group-open:block hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7"></path>
</svg>
<div class="pl-8 font-bold inline-block">
<p>preuve</p>
</div>
<svg class="group-open:hidden inline-block pl-3 w-10 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M5 12h.01M12 12h.01M19 12h.01M6 12a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0z"></path>
</svg>
</summary>
<div class="mx-8 pb-2">
<p>Soit $A$ un algorithme efficace d'aun adversaire du jeu de la reconnaissance avec deux mots $m_0$ et $m_1$. Son avantage vaut :</p>
<div>
$$
\begin{array}{lcl}
\epsilon(A) &=& \vert \Pr_{k\xleftarrow{U}\{0, 1\}^s}[A(G(k)\oplus m_1) = 1] - \Pr_{k\xleftarrow{U}\{0, 1\}^s}[A(G(k)\oplus m_2) = 1] \vert\\
&=& \Pr_{k\xleftarrow{U}\{0, 1\}^s}[A(G(k)\oplus m_1) = 1] - \Pr_{u\xleftarrow{U}\{0, 1\}^t}[A(u\oplus m_1) = 1]-\\
&& (\Pr_{k\xleftarrow{U}\{0, 1\}^s}[A(G(k)\oplus m_2) = 1] -\Pr_{u\xleftarrow{U}\{0, 1\}^t}[A(u\oplus m_1) = 1]) \vert\\
\end{array}
$$
</div>
<p>Comme $u\xleftarrow{U}\{0, 1\}^t\oplus m_1$ est une variable uniforme (<a href="../chiffre-vernam/#uniforme" class="interne">on l'a démontré</a>) on a $u\xleftarrow{U}\{0, 1\}^t\oplus m_1 = u\xleftarrow{U}\{0, 1\}^t\oplus m_2 = u\xleftarrow{U}\{0, 1\}^t$ et donc :</p>
<div>
$$
\begin{array}{lcl}
\epsilon(A) &=& \vert \Pr_{k\xleftarrow{U}\{0, 1\}^s}[A(G(k)\oplus m_1) = 1] - \Pr_{u\xleftarrow{U}\{0, 1\}^t}[A(u\oplus m_1) = 1] -\\
&& (\Pr_{k\xleftarrow{U}\{0, 1\}^s}[A(G(k)\oplus m_2) = 1] -\Pr_{u\xleftarrow{U}\{0, 1\}^t}[A(u\oplus m_2) = 1]) \vert\\
&=& \vert \Pr_{k\xleftarrow{U}\{0, 1\}^s}[A(G(k)\oplus m_1) = 1] - \Pr_{u\xleftarrow{U}\{0, 1\}^t}[A(u\oplus m_1) = 1] \vert +\\
&& \vert \Pr_{k\xleftarrow{U}\{0, 1\}^s}[A(G(k)\oplus m_2) = 1] -\Pr_{u\xleftarrow{U}\{0, 1\}^t}[A(u\oplus m_2) = 1] \vert
\end{array}
$$
</div>
<p>On peut supposer sans perte de généralité que :</p>
<div>
$$
\begin{array}{lcl}
\epsilon(A) &\leq&2\cdot\vert \Pr_{k\xleftarrow{U}\{0, 1\}^s}[A(G(k)\oplus m_1) = 1] - \Pr_{u\xleftarrow{U}\{0, 1\}^t}[A(u\oplus m_1) = 1] \vert
\end{array}
$$
</div>
<p>L'algorithme $A'$ tel que $A'(x) = A(x \oplus m_1)$ est un algorithme qui reconnaît $G$. Comme $G$ est un CPRNG, son avantage $\epsilon(A')$ ne peut être que négligeable et comme :</p>
<div>
$$
\begin{array}{lcl}
\epsilon(A') &=& \vert \Pr_{k\xleftarrow{U}\{0, 1\}^s}[A(G(k)\oplus m_1) = 1] - \Pr_{u\xleftarrow{U}\{0, 1\}^t}[A(u\oplus m_1) = 1] \vert
\end{array}
$$
</div>
<p>On en déduit que $\epsilon(A)$ est aussi négligeable ce qui conclut la preuve.</p>
</div>
</details>     
</div>
<h2>Message de taille variable</h2>
<p>Les générateurs de nombres pseudo-aléatoires ne permettent pas de générer des mots de tailles arbitraires. Certains peuvent être très grand (comme les lsfr ou le Blum-blum-shub) d'autres de tailles fixes et petites (chacha20 ne peut produire que des mots de longueur 512b).</p>
<p>Le schéma de transmission se complexifie encore en ajoutant une boucle de chiffrement :</p>
<pre><code>    Alice     |         |     Bob
    privé     | public  |    privé
--------------|---------|--------------
     m        |         |
              |         |
     a ---v   |         |  v--- b           # générés par un TRNG
     k &lt;--====|= A = B =|===--&gt; k           # protocole de partage de clé sécurisé
              |         |
----&gt;         |         |
|             |         |
|  G(ki) = K  |         |  G(ki) = K         # générés par un CPRNG
|             |         |
| K ⊕ mi = c -|--- c ---|----&gt; c
|             |         |  K ⊕ c = mi
|             |         |  m = mi || m
----          |         |    
</code></pre>
<p>Notez qu'il ne faut pas répéter la clé !</p>
<div class="quote relative py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-orange-500 bg-orange-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-orange-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M8.228 9c.549-1.165 2.03-2 3.772-2 2.21 0 4 1.343 4 3 0 1.4-1.278 2.575-3.006 2.907-.542.104-.994.54-.994 1.093m0 3h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
<div class="pl-8 mr-8">
<p>Montrez que si l'on encode plusieurs parties de message avec la même clé, le chiffre n'est pas sémantiquement sécurisé.</p>
</div></div>

<div class="relative drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-indigo-500 bg-indigo-100">
<details class="group">
<summary class="list-none py-0.5">
<svg class="group-open:hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M9 5l7 7-7 7"></path>
</svg>
<svg class="group-open:block hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7"></path>
</svg>
<div class="pl-8 font-bold inline-block">
<p>corrigé</p>
</div>
<svg class="group-open:hidden inline-block pl-3 w-10 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M5 12h.01M12 12h.01M19 12h.01M6 12a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0z"></path>
</svg>
</summary>
<div class="mx-8 pb-2">
<p>Si l'on utilise deux fois la même clé, si deux portions de messages sont identiques alors ils auront le même chiffre. On peut alors utiliser les messages :</p>
<ul>
<li>$m_1 = b_1b_2$</li>
<li>$m_2 = b_1b_1$</li>
</ul>
<p>On reconnaîtra $m_1$ de m_2$ avec un avantage de 1.</p>
</div>
</details>     
</div>
<!-- 

> TBD refaire l'image p12 <https://crypto.stanford.edu/~dabo/courses/cs255_winter19/lectures/PRP-PRF.pdf>

 -->
<div class="quote relative py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-red-500 bg-red-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-red-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"></path>
</svg>
<div class="pl-8 mr-8">
<p>Ce mode de chiffrement existe (ECB) est n'est <a href="https://fr.eitca.org/cybersecurity/eitc-is-ccf-classical-cryptography-fundamentals/applications-of-block-ciphers/modes-of-operation-for-block-ciphers/examination-review-modes-of-operation-for-block-ciphers/how-does-the-electronic-codebook-ecb-mode-of-operation-work-and-what-are-its-primary-security-drawbacks/">jamais recommandé</a></p>
</div></div>

<p>Voyons  comment tout ceci peut se faire de façon sécurisée :</p>
<p>Concaténer des blocs de messages chiffrés. On découpe le message à chiffrer $m$ en blocs $m_i$ de taille $t$ fixe que l'on traite séparément.</p>
<p>Plutôt que d'utiliser un générateur on utilise une <a href="../nombres-pseudo-al%C3%A9atoires-cryptographiques/#PRF" class="interne">fonction pseudo-aléatoire sécurisée</a> (ou une <a href="../nombres-pseudo-al%C3%A9atoires-cryptographiques/#PRP" class="interne">permutation</a>) dont on a vu que l'utilisation était identique à un générateur mais permettait d'avoir un paramètre de plus, le vecteur d'initialisation.</p>
<p>On va utiliser le schéma suivant pour désigner une PRF (<em>resp.</em> une PRP) $F(k, \text{iv})$ :</p>
<pre><code>       iv   
        |   
      --|-- 
 k---|&gt; F  |
      ----- 
        |
     F(k,iv)   
</code></pre>
<p>On a alors le schéma de chiffrement suivant, qui modifie le vecteur d'initialisation en incrémentant un compteur :</p>
<pre><code>    iv || 01     iv || 02         iv || i          iv || l
        |            |                |                |
      --|--        --|--            --|--            --|-- 
 k---|&gt;    |   k--|&gt;    |  ...  k--|&gt;    |  ...  k--|&gt;    |
      --v--        --v--            --v--            --v-- 
        |            |                 |               |
 m1---&gt; ⊕     m2---&gt; ⊕          mi---&gt; ⊕        ml---&gt; ⊕ 
        |            |                 |               |
        v            v                 v               v
       c1           c2                ci              cl
</code></pre>
<p>Ce schéma est bien sécurisé si $F$ l'est et que la place prise par le compteur n'est pas trop grande :</p>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
</svg>
<div class="pl-8 mb-2 mr-8">
<p><strong>proposition</strong></p>
</div><div class="pl-8 mr-8">
<p>$F: \{0, 1\}^s \times \{0, 1\}^t \rightarrow \{0, 1\}^t$ est une fonction pseudo-aléatoire sécurisée et $m$ un message de taille $l\cdot t$ alors :</p>
<div>
$$
E(k, m) = (F(k, \text{iv} \;\|\; 1) \;\|\;  \dots \;\|\;  F(k, \text{iv} \;\|\; l)) \oplus m
$$
</div>
<p>Est un chiffre sécurisé.</p>
</div></div>

<div class="quote relative  py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-cyan-500 bg-cyan-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-cyan-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z"></path>
</svg>
<div class="pl-8 mr-8">
<p>L'opérateur $\;\|\;$ est la concaténation.</p>
</div></div>

<div class="relative drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-indigo-500 bg-indigo-100">
<details class="group" open="">
<summary class="list-none py-0.5">
<svg class="group-open:hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M9 5l7 7-7 7"></path>
</svg>
<svg class="group-open:block hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7"></path>
</svg>
<div class="pl-8 font-bold inline-block">
<p>preuve</p>
</div>
<svg class="group-open:hidden inline-block pl-3 w-10 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M5 12h.01M12 12h.01M19 12h.01M6 12a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0z"></path>
</svg>
</summary>
<div class="mx-8 pb-2">
<p>Comme $F$ est une PRF, $F(k, \text{iv} \;\|\; i)$ est indiscernable de la variable aléatoire uniforme pour tout $\text{iv} \;\|\; i$. On peut ensuite utiliser le même schéma de preuve que <a href="nombres-pseudo-al%C3%A9atoires-cryptographiques/#chiffre-CPRNG-incr%C3%A9mental" class="interne">la preuve de l'incrémentalité d'un CPRNG</a> et permet de montrer que $(F(k, \text{iv} ;|; 1) ;|;  \dots ;|;  F(k, \text{iv} ;|; l))$ est indiscernable de la variable aléatoire uniforme (ici $m$ est au pire égale à la taille $t$ du message qui reste polynomial par rapport au paramètre de sécurité).</p>
</div>
</details>     
</div>
<p>Cette construction permet également de chiffrer <strong>et</strong> déchiffrer rapidement le message en parallèle. Il suffit de connaître la clé $k$ et la position du bloc à chiffrer/déchiffrer.</p>
<pre><code>    Alice     |         |     Bob
    privé     | public  |    privé
--------------|---------|--------------
     m        |         |
              |         |
     a ---v   |         |  v--- b           # générés par un TRNG
     k &lt;--====|= A = B =|===--&gt; k           # protocole de partage de clé sécurisé
              |         |
--i--&gt;        |         |
|             |         |
| F(k,        |         | F(k,              # PRF
|   iv || i)  |         |   iv || i)
|   = K       |         |   = K             
|             |         |
| K ⊕ mi = c -|--- c ---|----&gt; c
|             |         |  K ⊕ c = mi
|             |         |  m = mi || m
----          |         |    
</code></pre>
<h2>Nonce</h2>
<p>Le vecteur d'initialisation est souvent utilisé comme <a href="https://en.wikipedia.org/wiki/Cryptographic_nonce">NONCE</a>, qui comme son nom l'indique est utilisé une unique fois.</p>
<p>De nombreux protocoles cryptographiques l'utilise pour distinguer des encodages au sein de l'envoi d'un message pour éviter les <a href="https://fr.wikipedia.org/wiki/Attaque_par_rejeu">attaque par rejeu</a>. Le Nonce peut en effet être envoyé en clair, du moment que la clé est secrète.</p>
<pre><code>    Alice     |         |     Bob
    privé     | public  |    privé
--------------|---------|--------------
     m        |         |
              |         |
     a ---v   |         |  v--- b           # générés par un TRNG
     k &lt;--====|= A = B =|===--&gt; k           # protocole de partage de clé sécurisé
              |         |
    N --------|---------|----&gt; N            # Nonce    
              |         |                 
--i--&gt;        |         |
|             |         |
| F(k,        |         | F(k,              # PRF
|   N || i)   |         |   N || i)
|   = K       |         |   = K             
|             |         |
| K ⊕ mi = c -|--- c ---|----&gt; c
|             |         |  K ⊕ c = mi
|             |         |  m = mi || m
----          |         |    
</code></pre>
<h2>Schéma final de la transmission</h2>
<p>En utilisant le chirrfre de Vernam, la transmission sécurisée ressemble finalement à ceci :</p>
<pre><code>    Alice     |         |     Bob
    privé     | public  |    privé
--------------|---------|--------------
     m        |         |
              |         |
     a ---v   |         |  v--- b           # générés par un TRNG
     k &lt;--====|= A = B =|===--&gt; k           # protocole de partage de clé sécurisé
              |         |
    N --------|---------|----&gt; N            # Nonce    
              |         |                 
--i--&gt;        |         |
|             |         |
| F(k,        |         | F(k,              # PRF
|   N || i)   |         |   N || i)
|   = K       |         |   = K             
|             |         |
| K ⊕ mi = c -|--- c ---|----&gt; c
|             |         |  K ⊕ c = mi
|             |         |  m = mi || m
----          |         |    
</code></pre>
<p>On appelle ce type de transmission <a href="https://fr.wikipedia.org/wiki/Chiffrement_de_flux">chiffrement de flux</a>, qui est la norme actuellement. Il permet :</p>
<ul>
<li>des clés de petites tailles par rapport au message à faire passer</li>
<li>des algorithmes de complexité linéaires pour chiffrer et déchiffrer les messages.</li>
</ul>
<p>On considère actuellement que si le <a href="https://en.wikipedia.org/wiki/Key_size#Brute-force_attack">nombre de clés est supérieur à $2^{128}$</a>, l'approche brute-force n'est pas profitable car il faudrait un temps de déchiffrage supérieure à la durée de vie du message. Si l'on utilise des connaissances supplémentaires, il est possible de faire baisser ce nombre drastiquement.</p>
<div class="quote relative py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-emerald-500 bg-emerald-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-emerald-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
  <path stroke-linecap="round" stroke-linejoin="round" d="M13.19 8.688a4.5 4.5 0 011.242 7.244l-4.5 4.5a4.5 4.5 0 01-6.364-6.364l1.757-1.757m13.35-.622l1.757-1.757a4.5 4.5 0 00-6.364-6.364l-4.5 4.5a4.5 4.5 0 001.242 7.244"></path>
</svg>
<div class="pl-8 mr-8">
<p><a href="https://www.ssi.gouv.fr/administration/guide/mecanismes-cryptographiques/">recommendations ANSSI taille de clés</a></p>
</div></div>



</article>
    </main>

    <footer class="min-h-[50px] border-t-2 border-gray-200 mt-4">
      <div class="max-w-[1200px] mx-auto px-4 relative">
        <div class="min-h-[50px] flex justify-center items-center">
          <p>
            Cours d'informatique de François Brucker
          </p>
        </div>
        <div class="min-h-[50px] flex justify-center items-center absolute right-0 top-0">
          <button onclick="goTop()" id="myBtn" title="Go to top">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
              <path stroke-linecap="round" stroke-linejoin="round" d="M15 11.25l-3-3m0 0l-3 3m3-3v7.5M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
            </svg>
          </button>

          <button onclick="goBottom()" id="myBtn" title="Go to top">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
              <path stroke-linecap="round" stroke-linejoin="round" d="M9 12.75l3 3m0 0l3-3m-3 3v-7.5M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
            </svg>
          </button>
        </div>

      </div>
    </footer>

    <script>
      MathJax
        .startup
        .document
        .getMathItemsWithin(document.body);
    </script>

  </body>
</html>