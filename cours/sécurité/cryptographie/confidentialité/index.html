<!DOCTYPE html>
<html lang="fr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>Confidentialité</title>

    

    <link href="https://prismjs.catppuccin.com/latte.css" rel="stylesheet">

    <link href="/cours_informatique/assets/node_modules/prismjs/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet">
    <script src="/cours_informatique/assets/node_modules/prismjs/plugins/line-numbers/prism-line-numbers.min.js"></script>
    
    <link href="/cours_informatique/assets/stylesheets/main.css" rel="stylesheet">

  </head>
  <body>
    <script>
      window.MathJax = {
        tex: {
          inlineMath: [
            [
              '$', '$'
            ],
            [
              '\\(', '\\)'
            ]
          ]
        },
        svg: {
          fontCache: 'global'
        }
      };

      function goTop() {
        window.scrollTo({top: 0});
      }
      function goBottom() {
        window.scrollTo({top: document.body.scrollHeight});
      }
    </script>
    <script type="text/javascript" id="MathJax-script" src="/cours_informatique/assets/node_modules/mathjax/es5/tex-svg-full.js"></script>

    <header class="border-b-2 border-gray-200 mb-4">
      <div class="max-w-[1200px] mx-auto px-4 relative">
        <div class="min-h-[50px] flex justify-between items-center">
          <a class="mx-2" href="/cours_informatique/">Home</a>
        </div>

        <div class="min-h-[50px] flex justify-center items-center absolute right-0 top-0">
          <a class="mx-2" href="/cours_informatique/about">About</a>
          <button onclick="goTop()" id="myBtn" title="Go to top">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
              <path stroke-linecap="round" stroke-linejoin="round" d="M15 11.25l-3-3m0 0l-3 3m3-3v7.5M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
            </svg>
          </button>

          <button onclick="goBottom()" id="myBtn" title="Go to top">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
              <path stroke-linecap="round" stroke-linejoin="round" d="M9 12.75l3 3m0 0l3-3m-3 3v-7.5M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
            </svg>
          </button>
        </div>

      </div>
    </header>

    <main class="max-w-[1200px] mx-auto px-4">
      
<article>

  <h1>Confidentialité</h1>
  <div>
    

    
  </div>

  

    
<div class="quote relative  py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-purple-500 bg-purple-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-purple-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M5 19a2 2 0 01-2-2V7a2 2 0 012-2h4l2 2h4a2 2 0 012 2v1M5 19h14a2 2 0 002-2v-5a2 2 0 00-2-2H9a2 2 0 00-2 2v5a2 2 0 01-2 2z"></path>
</svg>
<div class="pl-8 mr-8">

<a class="interne" href="/cours_informatique/cours/">Cours</a><span class="px-1">/</span><a class="interne" href="/cours_informatique/cours/sécurité/">Sécurité</a><span class="px-1">/</span><a class="interne" href="/cours_informatique/cours/sécurité/cryptographie/">Cryptographie</a><span class="px-1">/</span><a class="interne" href="/cours_informatique/cours/sécurité/cryptographie/confidentialité/">Confidentialité</a>

</div></div>



    
  

  <div class="quote relative py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-emerald-500 bg-emerald-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-emerald-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
  <path stroke-linecap="round" stroke-linejoin="round" d="M13.19 8.688a4.5 4.5 0 011.242 7.244l-4.5 4.5a4.5 4.5 0 01-6.364-6.364l1.757-1.757m13.35-.622l1.757-1.757a4.5 4.5 0 00-6.364-6.364l-4.5 4.5a4.5 4.5 0 001.242 7.244"></path>
</svg>
<div class="pl-8 mb-2 mr-8">
<p><strong>Bibliographie</strong></p>
</div><div class="pl-8 mr-8">
<ul>
<li>&quot;random number generators : principles and practices de David Johnston&quot;</li>
<li>&quot;Introduction to modern cryptography de Jonathan Katk et Yehuda Lindell&quot;</li>
</ul>
</div></div>

<p>Le processus d'envoi d'un message confidentiel entre Alice et Bob décrit précédemment doit être ajusté pour être réaliste :</p>
<pre><code>    Alice    |  Eve   |     Bob
-------------|--------|--------------
    m, k     |        |      k
E(k, m) = c -|-- c ---|----&gt; c
             |        | D(k, c) = m
             |        |
espace privé | public |    privé
</code></pre>
<p>On va petit à petit modifier ce schéma pour le rendre utilisable en pratique. Commençons tout d'abord par fixer le code utilisé. On utilise le chiffre de Vernam car il possède deux avantages imbattables :</p>
<ul>
<li>il est à confidentialité parfaite</li>
<li>il est de complexité linéaire et très facile à implémenter</li>
</ul>
<p>On obtient alors le schéma suivant :</p>
<pre><code>    Alice    |  Eve   |     Bob
-------------|--------|--------------
    m, k     |        |      k
  k ⊕ m = c -|-- c ---|----&gt; c
             |        |  k ⊕ c = m
             |        |
espace privé | public |    privé
</code></pre>
<p>Pour que le chiffre de Vernam fonctionne, il faut que la clé soit générée de façon uniforme. Attelons-nous à ça.</p>
<h2>Génération de clés uniformes</h2>
<p>La clé générée doit être uniforme pour qu'un attaquant potentiel ne puisse pas avoir le moindre indice sur celle-ci. Ceci est impossible à faire avec un algorithme qui est par définition déterministe. On utilise ainsi des systèmes physiques (souvent couplés à des algorithmes et intégré directement sur le processeur) appelé <em><strong>TRNG</strong></em> pour <em>True Random Number Generator</em> pour cela.</p>
<p>Nous ne rentrerons pas en détail ici sur les moyens de générer de tels nombres, le lecteur intéressé pourra visiter le lien suivant :</p>
<div class="quote relative  py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-cyan-500 bg-cyan-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-cyan-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z"></path>
</svg>
<div class="pl-8 mr-8">
<p>Pour en savoir plus :</p>
<p><a href="/cours_informatique/cours/misc/al%C3%A9atoire/nombres-al%C3%A9atoires" class="interne"><em>True Random Number Generator</em></a></p>
</div></div>

<p>Ce qu'il faut en retenir pour nous c'est que :</p>
<div class="quote relative py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-red-500 bg-red-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-red-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"></path>
</svg>
<div class="pl-8 mb-2 mr-8">
<p><strong>À retenir</strong></p>
</div><div class="pl-8 mr-8">
<p>Générer des nombre vraiment aléatoire avec un ordinateur est possible en utilisant des systèmes physiques embarqués. C'est cependant un processus compliqué et coûteux en temps.</p>
</div></div>

<h2>Partager la clé</h2>
<p>Il est cependant irréaliste qu'Alice et Bob aient connaissance de la clé avant de se transmettre un message, sinon aucune communication sécurisée ne serait possible entre 2 ordinateurs. Il faut utiliser un moyen pour qu'Alice et/ou Bob puissent générer une clé puis se la transmettre de façon sécurisée.</p>
<p>Ceci est possible en utilisant des problèmes dont que l'on ne sait pas algorithmiquement résoudre efficacement :</p>
<div class="quote relative py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-fuchsia-500 bg-fuchsia-100">
  <svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-fuchsia-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
    <path stroke-linecap="round" stroke-linejoin="round" d="M5.25 5.653c0-.856.917-1.398 1.667-.986l11.54 6.348a1.125 1.125 0 010 1.971l-11.54 6.347a1.125 1.125 0 01-1.667-.985V5.653z"></path>
  </svg>
<div class="pl-8 mr-8">
<p><a href="partager-secret" class="interne">Partager de secret</a></p>
</div></div>

<p>Le schéma de transmission confidentiel devient alors :</p>
<pre><code>    Alice    |         |     Bob
    privé    | public  |    privé
-------------|---------|--------------
     m       |         |
             |         |
     a ---v  |         |  v--- b           # générés par un TRNG
     k &lt;--===|= A = B =|===--&gt; k           # protocole de partage de clé sécurisé
             |         |
  k ⊕ m = c -|--- c ---|----&gt; c
             |         |  k ⊕ c = m
             |         |
</code></pre>
<h2>Notion de sécurité</h2>
<p>La sécurisation du protocole de transmission de la clé par le protocole de Diffie-Hellmann dépend de la complexité du meilleur algorithme (connu) permettant de résoudre le problème du logarithme discret. Elle dépend du ratio entre le temps nécessaire pour le décrypter et la durée de vie du message.</p>
<p>Si les meilleurs algorithmes de résolution sont connus (ce qui n'est jamais vraiment assuré) on peut déterminer une taille de clé qui garantissent un temps de décryptage trop important. Formalisons cette notion :</p>
<div class="quote relative py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-fuchsia-500 bg-fuchsia-100">
  <svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-fuchsia-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
    <path stroke-linecap="round" stroke-linejoin="round" d="M5.25 5.653c0-.856.917-1.398 1.667-.986l11.54 6.348a1.125 1.125 0 010 1.971l-11.54 6.347a1.125 1.125 0 01-1.667-.985V5.653z"></path>
  </svg>
<div class="pl-8 mr-8">
<p><a href="d%C3%A9finition-s%C3%A9curit%C3%A9" class="interne">Sémantiquement sécurisée</a></p>
</div></div>

<h2>Transmission</h2>
<p>La méthode de chiffrement utilisant le code de Verna n'est pas directement utilisable en pratique car, la clé de chiffrement ne devant pas être répétée pour garantir l'inviolabilité du chiffrement, il faudrait utiliser le protocole de Diffie-Hellman pour générer des clés différentes pour chaque partie du message à chiffrer ce qui est trop coûteux en temps et empêcherait.</p>
<p>On utilise donc un générateur de nombre pseudo-aléatoire cryptographique (<em>Cryptographic Pseudo-Random Number Generator</em>) pour générer assez de bit à partir de la clé pour chiffrer le message entier :</p>
<pre><code>    Alice    |         |     Bob
    privé    | public  |    privé
-------------|---------|--------------
     m       |         |
             |         |
     a ---v  |         |  v--- b           # générés par un TRNG
     k &lt;--===|= A = B =|===--&gt; k           # protocole de partage de clé sécurisé
             |         |
  G(k) = K   |         |  G(k) = K         # générés par un CPRNG
             |         |
  K ⊕ m = c -|--- c ---|----&gt; c
             |         |  K ⊕ c = m
</code></pre>
<div class="quote relative py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-fuchsia-500 bg-fuchsia-100">
  <svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-fuchsia-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
    <path stroke-linecap="round" stroke-linejoin="round" d="M5.25 5.653c0-.856.917-1.398 1.667-.986l11.54 6.348a1.125 1.125 0 010 1.971l-11.54 6.347a1.125 1.125 0 01-1.667-.985V5.653z"></path>
  </svg>
<div class="pl-8 mr-8">
<p><a href="nombres-pseudo-al%C3%A9atoires-cryptographiques" class="interne">Nombres pseudo aléatoires cryptographiques</a></p>
</div></div>

<blockquote>
<p>TBD CPRNG -&gt; permutation
TBD historiquement AES mais maintenant chacha20 (de Bertstein, celui des courbes elliptiques)</p>
</blockquote>
<h2>Schéma final de la transmission</h2>
<p>Pour qu'une méthode de chiffrement puisse être utilisé en pratique, il faut pouvoir avoir deux choses :</p>
<ul>
<li>des clés de petites tailles par rapport au message à faire passer</li>
<li>des algorithmes de complexité linéaires pour chiffrer et déchiffrer les messages.</li>
</ul>
<p>Même si on s'autorise théoriquement des algorithmes polynomiaux, en pratique, efficaces veut plutôt dire linéaire car il faut que ces algorithmes puissent chiffrer de très nombreuses données en peu de temps. Efficace prend donc deux significations différentes, selon que l'on cherche à prouver théoriquement des résultats où que l'on veuille en pratique chiffrer des données. L'un ne va cependant pas sans l'autre.</p>
<p>Ces deux contraintes vont forcément nous faire passer des informations à l'adversaire. Selon le type d'information que l'on ne veut pas divulguer on va utiliser une méthode plutôt qu'une autre.</p>
<blockquote>
<p>rappel définition securisé, avantage, etc.</p>
</blockquote>
<ol>
<li>Alice et/ou Bob doivent créer un nombre aléatoire de façon uniforme servant de clé.</li>
<li>Alice et Bob doivent s'échanger une clé de taille petite par rapport à la taille du message à échanger mais choisie uniformément parmi toutes les clé possibles</li>
<li>cette clé doit permettre de générer une clé plus grosse de taille égale au message à échanger (on verra pourquoi)</li>
<li>on chiffre le message avec le code de Vernam que l'on peut ensuite transmettre</li>
</ol>
<pre><code>    Alice    |        |     Bob
    privé    | public |    privé
-------------|--------|--------------
      m      |        |     
      k &lt;----|--------|----&gt; k
  G(k) = K   |        |  G(k) = K    
E(K, m) = c -|-- c ---|----&gt; c
             |        | D(K, c) = m
             |        |
</code></pre>
<p>Pour que tout fonctionne sans accros il faut que chaque étape soit &quot;<em>sécurisée</em>&quot; (on définira précisément ce terme plus tard) en particulier :</p>
<ol>
<li>il faut créer une clé uniforme.</li>
<li>il faut pouvoir se partager un secret via un canal public</li>
<li>il faut que l'algorithme de génération de clé plus grosse soit connu de tous <strong>mais</strong> que ce soit impossible de connaître la séquence finale si on a pas la clé de départ</li>
<li>il faut que $c$ soit uniforme pour ne pas</li>
</ol>
<pre><code>           k                   k
           |                   |
           v                   v
        -------             -------
       |       |           |       |
 m --&gt; |   E   | --&gt; c --&gt; |   D   | --&gt; m
       |       |           |       |
        -------             -------
</code></pre>
<p>Deux types d'attaques :</p>
<ul>
<li>brute-force : énumération des clés</li>
<li>connaissances supplémentaires :
<ul>
<li><em>a priori</em> sur $m$ si l'attaque est chiffre seul</li>
<li>acquises si on peut avoir ou produire des couples (message, chiffre)</li>
</ul>
</li>
</ul>
<p>On considère actuellement que si le <a href="https://en.wikipedia.org/wiki/Key_size#Brute-force_attack">nombre de clés est supérieur à $2^{128}$</a>, l'approche brute-force n'est pas profitable car il faudrait un temps de déchiffrage supérieure à la durée de vie du message. Si l'on utilise des connaissances supplémentaires, il est possible de faire baisser ce nombre drastiquement.</p>
<div class="quote relative py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-emerald-500 bg-emerald-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-emerald-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
  <path stroke-linecap="round" stroke-linejoin="round" d="M13.19 8.688a4.5 4.5 0 011.242 7.244l-4.5 4.5a4.5 4.5 0 01-6.364-6.364l1.757-1.757m13.35-.622l1.757-1.757a4.5 4.5 0 00-6.364-6.364l-4.5 4.5a4.5 4.5 0 001.242 7.244"></path>
</svg>
<div class="pl-8 mr-8">
<p><a href="https://www.ssi.gouv.fr/administration/guide/mecanismes-cryptographiques/">recommendations ANSSI taille de clés</a></p>
</div></div>

<h2>Génération de nombres pseudo-aléatoires</h2>
<div class="quote relative py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-emerald-500 bg-emerald-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-emerald-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
  <path stroke-linecap="round" stroke-linejoin="round" d="M13.19 8.688a4.5 4.5 0 011.242 7.244l-4.5 4.5a4.5 4.5 0 01-6.364-6.364l1.757-1.757m13.35-.622l1.757-1.757a4.5 4.5 0 00-6.364-6.364l-4.5 4.5a4.5 4.5 0 001.242 7.244"></path>
</svg>
<div class="pl-8 mr-8">
<p><a href="https://en.wikipedia.org/wiki/Random_number_generation">https://en.wikipedia.org/wiki/Random_number_generation</a></p>
</div></div>

<p>Clé initiale doit être uniforme. Puis on étend à la taille du message à chiffrer. En partant d'une clé aléatoire sur $k$ bits un algorithme $G()$ permettant de produire $k &lt;&lt;t$ bits que l'on cherche à être le plus aléatoire possible :</p>
<pre><code>  ---------
  | k bit |
  ---------
  :        \
  :         \
  :          \
  :           \
  --------------
  |G(k) à t bits|
  --------------
</code></pre>
<p>Comme $G$ est un algorithme il est <strong>déterministe</strong> mais si la suite $G(k)$ possède des propriétés statistiques relevant de l'aléatoire, on dira que $G$ est un générateur de nombre pseudo-aléatoire.</p>
<p>Ca existe :</p>
<ul>
<li><a href="https://docs.python.org/fr/3.14/library/random.html">les nombres pseudo-aléatoire de python</a>. Fonctionnent avec une seed.</li>
<li>le modulo $x_{n+1} = a \cdot x_n + b \pmod p$ avec $p$ un nombre premier.</li>
</ul>
<p>Ou encore les décimales de pi à partir de la $k$ème
voir des méthodes plus sophistiquée comme <a href="Rapport_de_Stage_Laura_Michelutti.pdf">les lsfr</a>.</p>
<p>Mais attention doit être &quot;sécurisé&quot; ! On ne doit pas pouvoir prédire la suite à partir d'un échantillon. Ceci peut se faire si un attaquant peut envoyer des messages à chiffrer :</p>
<pre><code>  kkkkkkk
+ 0000000
----------
  kkkkkkk
</code></pre>
<p>On retrouve Xn puis si modulo je connais la suite.</p>
<p>Ces générateur (python, ou encore le modulo avec un entier premier) sont parfait pour prédire le monde physique, les sorties sont bien uniformes et indétectables de l'aléatoire, mais pour les applications crypto on veut en plus non-prédictible.</p>
<p>Du coup $\pi$ marche pas non plus trop (<a href="https://mathoverflow.net/questions/26942/is-pi-a-good-random-number-generator">https://mathoverflow.net/questions/26942/is-pi-a-good-random-number-generator</a> et <a href="https://www2.lbl.gov/Science-Articles/Archive/pi-random.html">https://www2.lbl.gov/Science-Articles/Archive/pi-random.html</a>).</p>
<p>Et les lsfr il faut travailler.</p>
<div class="quote relative py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-emerald-500 bg-emerald-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-emerald-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
  <path stroke-linecap="round" stroke-linejoin="round" d="M13.19 8.688a4.5 4.5 0 011.242 7.244l-4.5 4.5a4.5 4.5 0 01-6.364-6.364l1.757-1.757m13.35-.622l1.757-1.757a4.5 4.5 0 00-6.364-6.364l-4.5 4.5a4.5 4.5 0 001.242 7.244"></path>
</svg>
<div class="pl-8 mr-8">
<p><a href="https://fr.eitca.org/cybersecurity/eitc-is-ccf-classical-cryptography-fundamentals/stream-ciphers/stream-ciphers-random-numbers-and-the-one-time-pad/examination-review-stream-ciphers-random-numbers-and-the-one-time-pad/what-are-the-key-differences-between-true-random-number-generators-trngs-pseudorandom-number-generators-prngs-and-cryptographically-secure-pseudorandom-number-generators-csprngs/">Différences entre les différents générateur pseudo-aléatoires</a></p>
</div></div>

<!-- > TBD TP
>
> - lsfr avec python etc.
> - les décimales de pi :
>   - <https://www.youtube.com/watch?v=FDXf1XxCXAk>
>   - sont aléatoires si tu ne sais pas que c'est elles.
>   - prendre les bits de la représentation binaire des décimales de pi et leur faire passer des tests d'aléatoire. -->
<h3>Nombres pseudo-aléatoires cryptographique</h3>
<p>On a utilisé plusieurs fois le terme &quot;sécurisé&quot; avec des notions différentes :</p>
<ul>
<li>la sécurité du partage de la clé était basé sur la <strong>difficulté algorithmique</strong> du logarithme discret.</li>
<li>générateur de nombre pseudo-aléatoire est sécurisé s'il est <strong>non prédictible</strong></li>
</ul>
<p>Essayons de formaliser tout ça en une seule définition qui va permettre de créer des système de chiffrement que l'on pourra démontrer sécurisé (au oins en théorie).</p>
<div class="quote relative py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-fuchsia-500 bg-fuchsia-100">
  <svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-fuchsia-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
    <path stroke-linecap="round" stroke-linejoin="round" d="M5.25 5.653c0-.856.917-1.398 1.667-.986l11.54 6.348a1.125 1.125 0 010 1.971l-11.54 6.347a1.125 1.125 0 01-1.667-.985V5.653z"></path>
  </svg>
<div class="pl-8 mr-8">
<p><a href="d%C3%A9finitions" class="interne">Définitions de la confidentialité</a></p>
</div></div>

<p>Le message ne doit pouvoir être lu que par son destinataire. Comment partager la clé en secret ?</p>
<h2>Chiffrer un message</h2>
<p>Les algorithmes de chiffrement classiques ne permettent pas de chiffrer des message de taille quelconque. Ils sont conçus pour chiffrer des blocs de taille fixes.</p>
<h3>Chiffrer un message de taille fixe</h3>
<div class="quote relative py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-fuchsia-500 bg-fuchsia-100">
  <svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-fuchsia-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
    <path stroke-linecap="round" stroke-linejoin="round" d="M5.25 5.653c0-.856.917-1.398 1.667-.986l11.54 6.348a1.125 1.125 0 010 1.971l-11.54 6.347a1.125 1.125 0 01-1.667-.985V5.653z"></path>
  </svg>
<div class="pl-8 mr-8">
<p><a href="chiffrer-un-bloc" class="interne">Chiffrer un bloc</a></p>
</div></div>

<h3>Chiffrer un message de taille quelconque</h3>
<p>Il existe historiquement deux types de codes même si les différences commencent à s'estomper entres eux :</p>
<ul>
<li>les codes en flux qui vont se comporter comme le code de Vernam</li>
<li>les code en bloc qui vont découper le message en blocs et chiffrer chacun d'entre eux avec un permutation.</li>
</ul>
<div class="quote relative py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-fuchsia-500 bg-fuchsia-100">
  <svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-fuchsia-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
    <path stroke-linecap="round" stroke-linejoin="round" d="M5.25 5.653c0-.856.917-1.398 1.667-.986l11.54 6.348a1.125 1.125 0 010 1.971l-11.54 6.347a1.125 1.125 0 01-1.667-.985V5.653z"></path>
  </svg>
<div class="pl-8 mr-8">
<p><a href="sch%C3%A9ma-g%C3%A9n%C3%A9ral" class="interne">Schéma général</a></p>
</div></div>

<blockquote>
<p><a href="https://www.youtube.com/watch?v=G2TYtN2qJls&amp;list=PLbdXd8eufjyWStIhgGkstZi-cvHhUPatc">https://www.youtube.com/watch?v=G2TYtN2qJls&amp;list=PLbdXd8eufjyWStIhgGkstZi-cvHhUPatc</a></p>
</blockquote>
<h3>Attention aux implémentations</h3>
<p>Les <a href="partager-secret/#side-channel-attack" class="interne">side channel attacks</a> permettent, on l'a vue, de tirer parie de l'implémentation de l'algorithme pour obtenir un avantage npn négligeable. Pour qu'aucune information ne transparaisse, il faut que l'algorithme :</p>
<ol>
<li>fasse tout le temps la même chose</li>
<li>consomme la même énergie</li>
<li>...</li>
</ol>
<p>Bref, n'implémentez pas vous même les algorithmes, prenez des implémentations éprouvées.</p>
<div class="quote relative py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-emerald-500 bg-emerald-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-emerald-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
  <path stroke-linecap="round" stroke-linejoin="round" d="M13.19 8.688a4.5 4.5 0 011.242 7.244l-4.5 4.5a4.5 4.5 0 01-6.364-6.364l1.757-1.757m13.35-.622l1.757-1.757a4.5 4.5 0 00-6.364-6.364l-4.5 4.5a4.5 4.5 0 001.242 7.244"></path>
</svg>
<div class="pl-8 mr-8">
<ul>
<li><a href="https://www.youtube.com/watch?v=GPwNFrpd1KU">channel attack exemples</a></li>
<li><a href="https://www.ssi.gouv.fr/agence/publication/combined-fault-and-side-channel-attack-on-protected-implementations-of-aes/">Attaques sur Machines embarquées</a></li>
</ul>
</div></div>

<h2>Générer des clés</h2>
<h3>Générateur de nombre aléatoire cryptographique</h3>
<blockquote>
<p>TBD LSFR</p>
</blockquote>
<div class="quote relative py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-emerald-500 bg-emerald-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-emerald-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
  <path stroke-linecap="round" stroke-linejoin="round" d="M13.19 8.688a4.5 4.5 0 011.242 7.244l-4.5 4.5a4.5 4.5 0 01-6.364-6.364l1.757-1.757m13.35-.622l1.757-1.757a4.5 4.5 0 00-6.364-6.364l-4.5 4.5a4.5 4.5 0 001.242 7.244"></path>
</svg>
<div class="pl-8 mr-8">
<p>Rapport de stage sur les codes LSFR : <a href="Rapport_de_Stage_Laura_Michelutti.pdf">projet codes LSFR</a></p>
</div></div>

<h3>Trouver la clé</h3>
<p>Il faut utiliser des générateur avec entropie. Il n'est pas utile de retrouver le nombre ensuite.</p>
<blockquote>
<p>TBD <code class="fichier">/dev/random</code> ou <code class="fichier">/dev/urandom</code>
TBD : faire grossir partie <a href="al%C3%A9atoire" class="interne">aléatoire</a></p>
</blockquote>
<h3>Key derivation function</h3>
<div class="quote relative py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-emerald-500 bg-emerald-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-emerald-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
  <path stroke-linecap="round" stroke-linejoin="round" d="M13.19 8.688a4.5 4.5 0 011.242 7.244l-4.5 4.5a4.5 4.5 0 01-6.364-6.364l1.757-1.757m13.35-.622l1.757-1.757a4.5 4.5 0 00-6.364-6.364l-4.5 4.5a4.5 4.5 0 001.242 7.244"></path>
</svg>
<div class="pl-8 mr-8">
<p><a href="https://en.wikipedia.org/wiki/Key_derivation_function">Key derivation function</a></p>
</div></div>

<p>Les protocole vont avoir besoin de tout un tas de clés différentes. Une pour chaque message à transmettre et pour chaque messages. La façon la plus simple, si on a un PRF sous la main est de :</p>
<ul>
<li>posséder une clé primaire appelée $SK$ (<em>source key</em>)</li>
<li>une constante $CTX$, application dépendante pour éviter que plusieurs applications différentes utilisant la même clé primaires de se trouvent avec les mêmes clés</li>
</ul>
<p>Puis il suffit d'étier le process à chaque fois que l'in veut une clé avec : $F(\text{SK}, \text{CTX} || i)$, où $i$ est un compteur.</p>


</article>
    </main>

    <footer class="min-h-[50px] border-t-2 border-gray-200 mt-4">
      <div class="max-w-[1200px] mx-auto px-4 relative">
        <div class="min-h-[50px] flex justify-center items-center">
          <p>
            Cours d'informatique de François Brucker
          </p>
        </div>
        <div class="min-h-[50px] flex justify-center items-center absolute right-0 top-0">
          <button onclick="goTop()" id="myBtn" title="Go to top">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
              <path stroke-linecap="round" stroke-linejoin="round" d="M15 11.25l-3-3m0 0l-3 3m3-3v7.5M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
            </svg>
          </button>

          <button onclick="goBottom()" id="myBtn" title="Go to top">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
              <path stroke-linecap="round" stroke-linejoin="round" d="M9 12.75l3 3m0 0l3-3m-3 3v-7.5M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
            </svg>
          </button>
        </div>

      </div>
    </footer>

    <script>
      MathJax
        .startup
        .document
        .getMathItemsWithin(document.body);
    </script>

  </body>
</html>