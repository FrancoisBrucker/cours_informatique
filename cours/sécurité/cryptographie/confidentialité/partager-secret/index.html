<!DOCTYPE html>
<html lang="fr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>Partage de secret</title>

    

    <link href="https://prismjs.catppuccin.com/latte.css" rel="stylesheet">

    <link href="/cours_informatique/assets/node_modules/prismjs/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet">
    <script src="/cours_informatique/assets/node_modules/prismjs/plugins/line-numbers/prism-line-numbers.min.js"></script>
    
    <link href="/cours_informatique/assets/stylesheets/main.css" rel="stylesheet">

  </head>
  <body>
    <script>
      window.MathJax = {
        tex: {
          inlineMath: [
            [
              '$', '$'
            ],
            [
              '\\(', '\\)'
            ]
          ]
        },
        svg: {
          fontCache: 'global'
        }
      };

      function goTop() {
        window.scrollTo({top: 0});
      }
      function goBottom() {
        window.scrollTo({top: document.body.scrollHeight});
      }
    </script>
    <script type="text/javascript" id="MathJax-script" src="/cours_informatique/assets/node_modules/mathjax/es5/tex-svg-full.js"></script>

    <header class="border-b-2 border-gray-200 mb-4">
      <div class="max-w-[1200px] mx-auto px-4 relative">
        <div class="min-h-[50px] flex justify-between items-center">
          <a class="mx-2" href="/cours_informatique/">Home</a>
        </div>

        <div class="min-h-[50px] flex justify-center items-center absolute right-0 top-0">
          <a class="mx-2" href="/cours_informatique/about">About</a>
          <button onclick="goTop()" id="myBtn" title="Go to top">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
              <path stroke-linecap="round" stroke-linejoin="round" d="M15 11.25l-3-3m0 0l-3 3m3-3v7.5M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
            </svg>
          </button>

          <button onclick="goBottom()" id="myBtn" title="Go to top">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
              <path stroke-linecap="round" stroke-linejoin="round" d="M9 12.75l3 3m0 0l3-3m-3 3v-7.5M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
            </svg>
          </button>
        </div>

      </div>
    </header>

    <main class="max-w-[1200px] mx-auto px-4">
      
<article>

  <h1>Partage de secret</h1>
  <div>
    

    
  </div>

  

    
<div class="quote relative  py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-purple-500 bg-purple-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-purple-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M5 19a2 2 0 01-2-2V7a2 2 0 012-2h4l2 2h4a2 2 0 012 2v1M5 19h14a2 2 0 002-2v-5a2 2 0 00-2-2H9a2 2 0 00-2 2v5a2 2 0 01-2 2z"></path>
</svg>
<div class="pl-8 mr-8">

<a class="interne" href="/cours_informatique/cours/">Cours</a><span class="px-1">/</span><a class="interne" href="/cours_informatique/cours/sécurité/">Sécurité</a><span class="px-1">/</span><a class="interne" href="/cours_informatique/cours/sécurité/cryptographie/">Cryptographie</a><span class="px-1">/</span><a class="interne" href="/cours_informatique/cours/sécurité/cryptographie/confidentialité/">Confidentialité</a><span class="px-1">/</span><a class="interne" href="/cours_informatique/cours/sécurité/cryptographie/confidentialité/partager-secret/">Partage de secret</a>

</div></div>



    
  

  <p>Comment se partager un secret alors que tout le monde nous espionne ? Le protocole <a href="https://fr.wikipedia.org/wiki/%C3%89change_de_cl%C3%A9s_Diffie-Hellman">Diffie-Hellman</a> est une solution à ce problème, aidé par le fait que l'on ne sait pas tout faire en algorithmie.</p>
<div class="quote relative py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-emerald-500 bg-emerald-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-emerald-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
  <path stroke-linecap="round" stroke-linejoin="round" d="M13.19 8.688a4.5 4.5 0 011.242 7.244l-4.5 4.5a4.5 4.5 0 01-6.364-6.364l1.757-1.757m13.35-.622l1.757-1.757a4.5 4.5 0 00-6.364-6.364l-4.5 4.5a4.5 4.5 0 001.242 7.244"></path>
</svg>
<div class="pl-8 mr-8">
<p><a href="https://www.youtube.com/watch?v=NmM9HA2MQGI&amp;list=RDCMUC9-y-6csu5WGm29I7JiwpnA">le problème en quelques vidéos</a></p>
</div></div>

<h2>Protocole Diffie-Hellman</h2>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
</svg>
<div class="pl-8 mb-2 mr-8">
<p><strong>Protocole Diffie-Hellman</strong></p>
</div><div class="pl-8 mr-8">
<p>Dans le domaine public :</p>
<ul>
<li>$p$ premier</li>
<li>$g &lt; p$ un générateur du groupe cyclique $(\mathbb{Z}/p\mathbb{Z}^{\star}, \cdot)$</li>
</ul>
<ol>
<li>Échange de la première partie des clés
<ul>
<li>Alice choisit un nombre $a$ et envoie à Bob $A = g^a \bmod p$</li>
<li>Bob choisit un nombre $b$ et envoie à Bob $B = g^b \bmod p$</li>
</ul>
</li>
<li>Constitution des clés :
<ul>
<li>Alice construit le secret $K = B^a \bmod p = g^{ab} \bmod p$</li>
<li>Bob construit le secret $K = A^b \bmod p = g^{ab} \bmod p$</li>
</ul>
</li>
</ol>
<p>Au final, Alice et Bob partagent un nombre $K$ compris entre $0$ et $p-1$.</p>
</div></div>

<h2>Pourquoi ça marche</h2>
<ol>
<li>si $n$ est premier, <a href="/cours_informatique/cours/misc/corps-ZpZ/#groupe-cyclique" class="interne">$(\mathbb{Z}/p\mathbb{Z}^{\star}, \cdot)$ est un groupe cyclique</a></li>
<li>il est très facile de faire <a href="/cours_informatique/cours/misc/corps-ZpZ/#exponentiation-modulaire" class="interne">l'exponentiation modulaire</a> dans le cas général et encore plus rapide en notation binaire</li>
<li><a href="/cours_informatique/cours/misc/corps-ZpZ/#logarithme-discret" class="interne">le logarithme discret</a> est une opération coûteuse</li>
</ol>
<h3>Existence</h3>
<p>Comme $g$ est un générateur d'un groupe cyclique, on peut donc avoir tout le monde en temps que $g^a$</p>
<p>$ab$ permet bien d'obtenir tout nombre $q$ entre $0$ et $p-1$ car :</p>
<ul>
<li>soit $q$ n'est pas premier et $q=ab$ avec $a$ et $b$ plus petit que $p$</li>
<li>soit $q$ est premier et $p+q$ est pair, donc composé, et il existe $a$ et $b$ plus petit que $p$ tel que $ab = p + q$.</li>
</ul>
<h3>Algorithme de transmission</h3>
<p>L'exponentiation modulaire peut s'écrire comme <a href="/cours_informatique/cours/algorithmie/projet-exponentiation/%C3%A9tude-algorithmique/" class="interne">l'exponentiation indienne</a> en utilisant le principe dit de &quot;<em>square and multiply</em>&quot; :</p>
<pre class="language-pseudocode" tabindex="0" data-language="pseudocode"><code class="language-pseudocode"><span class="token builtin">algorithme</span> <span class="token function">expo</span><span class="token punctuation">(</span>x<span class="token punctuation">:</span> <span class="token builtin">entier</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token builtin">entier</span><span class="token punctuation">)</span> <span class="token operator">→</span> <span class="token builtin">entier</span><span class="token punctuation">:</span>
    r <span class="token operator">:=</span> <span class="token number">1</span>
    <span class="token keyword">tant que</span> y <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">:</span>
        <span class="token keyword">si</span> y est impair<span class="token punctuation">:</span>
            r <span class="token operator">←</span> r <span class="token operator">*</span> x mod p     <span class="token comment"># MULTIPLY</span>
            y <span class="token operator">←</span> y <span class="token operator">-</span> <span class="token number">1</span>
        x <span class="token operator">←</span> x <span class="token operator">*</span> x mod p         <span class="token comment"># SQUARE</span>
        y <span class="token operator">←</span> y <span class="token operator">/</span> <span class="token number">2</span>
    <span class="token keyword">rendre</span> r</code></pre>
<p>En supposant que la complexité de l'addition, la multiplication et le modulo soient de complexité $\mathcal{O}(1)$, la complexité de l'algorithme est en $\mathcal{O}(\log_2(y))$ qui correspond au nombre maximum d'itérations dans la boucle.</p>
<div class="quote relative  py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-cyan-500 bg-cyan-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-cyan-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z"></path>
</svg>
<div class="pl-8 mr-8">
<p>En réalité les complexité des opérations arithmétiques ne sont pas en $\mathcal{O}(1)$, mais cela ne change pas le résultat. Pour plus d'info, n'hésitez pas à consulter <a href="/cours_informatique/cours/algorithmie/fonctions-bool%C3%A9ennes/" class="interne">cette partie du cours</a></p>
</div></div>

<p>Si $x$, $y$ et $p$ sont stockés sur $n$ bits, la complexité est polynomiale puisque $\log_2(y) \leq n$.</p>
<h3>Problème du logarithme discret</h3>
<div class="quote relative py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-emerald-500 bg-emerald-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-emerald-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
  <path stroke-linecap="round" stroke-linejoin="round" d="M13.19 8.688a4.5 4.5 0 011.242 7.244l-4.5 4.5a4.5 4.5 0 01-6.364-6.364l1.757-1.757m13.35-.622l1.757-1.757a4.5 4.5 0 00-6.364-6.364l-4.5 4.5a4.5 4.5 0 001.242 7.244"></path>
</svg>
<div class="pl-8 mr-8">
<p><a href="https://fr.wikipedia.org/wiki/Logarithme_discret">https://fr.wikipedia.org/wiki/Logarithme_discret</a></p>
</div></div>

<p>Trouver $x$ à partir de $y=g^x \bmod p$ n'est pas évident. En effet l'algorithme naif suivant :</p>
<pre class="language-pseudocode" tabindex="0" data-language="pseudocode"><code class="language-pseudocode"><span class="token builtin">algorithme</span> <span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">:</span> <span class="token builtin">entier</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token builtin">entier</span><span class="token punctuation">,</span> g<span class="token punctuation">:</span> <span class="token builtin">entier</span><span class="token punctuation">)</span> <span class="token operator">→</span> <span class="token builtin">entier</span><span class="token punctuation">:</span>
    r <span class="token operator">:=</span> <span class="token number">1</span>
    <span class="token keyword">pour chaque</span><span class="token number"> i </span>de <span class="token number">0</span> à p<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span>
        <span class="token keyword">si</span> r <span class="token operator">==</span> y<span class="token punctuation">:</span>
            <span class="token keyword">rendre</span><span class="token number"> i
</span>        r <span class="token operator">←</span> r <span class="token operator">*</span> g mod p</code></pre>
<p>est de complexité $\mathcal{O}(p)$ (le nombre maximum d'itérations dans la boucle) en supposant que la complexité de l'addition, la multiplication et le modulo soient de complexité $\mathcal{O}(1)$.</p>
<p>Comme précédemment, si les entiers sont stockés sur $n=\log_2(p)$ bits, la complexité de l'algorithme est maintenant exponentielle par rapport à la taille $n$ de l'entrée : $\mathcal{O}( \cdot 2^{log_2(p)}) = \mathcal{O}( \cdot 2^{n})$. Le nombre de possibilité à essayer va être rédhibitoire, même pour un algorithme très rapide. Par exemple, l'exécution d'un algorithme faisant 1 opération en $10^{-6}$ secondes pour calculer le logarithme discret d'une clé à $64$ bits : il va y avoir de l'ordre de $2^{64}$ opérations. Comme $10^6 \simeq 2^{20}$ il faudra environ $2^{44}$ secondes soit plus de 6 mois.</p>
<p>Attention cependant, le meilleur algorithme n'est souvent pas le naif ! Regardons pas exemple cet algorithme, appelé <a href="https://fr.wikipedia.org/wiki/Baby-step_giant-step">Baby step giant step</a> qui échange du temps contre de la mémoire.</p>
<p>Son principe est simple.</p>
<ol>
<li>
<p>Si $0 &lt; m &lt; p$, alors la division euclidienne de $x$ par $m$ donne : $x = i \cdot m + j$ avec :</p>
<ul>
<li>$0 \leq i \leq p/m$</li>
<li>$0 \leq j &lt; m$</li>
</ul>
</li>
<li>
<p>On a $y=g^x \mod p$ si et seulement si : $g^i = y \cdot ((g^{-1})^m)^j$</p>
</li>
</ol>
<p>Ce qui donne :</p>
<pre class="language-pseudocode" tabindex="0" data-language="pseudocode"><code class="language-pseudocode"><span class="token builtin">algorithme</span> <span class="token function">steps</span><span class="token punctuation">(</span>y<span class="token punctuation">:</span> <span class="token builtin">entier</span><span class="token punctuation">,</span> g<span class="token punctuation">:</span> <span class="token builtin">entier</span><span class="token punctuation">)</span> <span class="token operator">→</span> <span class="token builtin">entier</span><span class="token punctuation">:</span>
    d <span class="token operator">:=</span> Dict<span class="token operator">&lt;</span><span class="token builtin">entier</span><span class="token punctuation">,</span> <span class="token builtin">entier</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    c <span class="token operator">:=</span> <span class="token number">1</span>
    
    <span class="token keyword">pour chaque</span><span class="token number"> i </span>de <span class="token number">0</span> à p<span class="token operator">/</span>m<span class="token punctuation">:</span>       <span class="token comment"># baby step</span>
        d<span class="token punctuation">[</span>c<span class="token punctuation">]</span> <span class="token operator">=</span><span class="token number"> i
</span>        c <span class="token operator">←</span> g <span class="token operator">*</span> c 

    <span class="token keyword">si</span> y est une clé de d<span class="token punctuation">:</span>          <span class="token comment"># g^i = y  => x = i * m + 0</span>
        <span class="token keyword">rendre</span> d<span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">*</span> m

    c <span class="token operator">←</span> expo<span class="token punctuation">(</span>expo<span class="token punctuation">(</span>g<span class="token punctuation">,</span> n<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> m<span class="token punctuation">)</span>       <span class="token comment"># 1/g = g^(n-2) puisque g^(n-1) = 1 (petit thm Fermat)</span>

    <span class="token keyword">pour chaque</span><span class="token number"> j </span>de <span class="token number">1</span> à m<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span>       <span class="token comment"># giant step</span>
        y <span class="token operator">←</span> y <span class="token operator">*</span> c
        <span class="token keyword">si</span> c est une clé de d<span class="token punctuation">:</span>  <span class="token comment"># g^i = y  => x = i * m + j</span>
            <span class="token keyword">rendre</span> d<span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">*</span> m <span class="token operator">+</span><span class="token number"> j
</span></code></pre>
<p>La complexité de l'algorithme est alors clairement de :</p>
<ul>
<li>$\mathcal{O}(m)$ en mémoire pour stocker toutes les valeurs dans le dictionnaire</li>
<li>$\mathcal{O}(m + p/m)$ en moyenne pour la complexité pour parcourir les 2 boucles et les test (en moyenne du dictionnaire)</li>
</ul>
<p>Pour ne pas favoriser une boucle plutôt qu'un autre on prend $m$ tel que $p/m = m$, c'est à dire $m = \sqrt{p}$.</p>
<p>On obtient alors une complexité en moyenne et en mémoire de $\mathcal{O}(\sqrt{p})$</p>
<div class="quote relative py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-red-500 bg-red-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-red-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"></path>
</svg>
<div class="pl-8 mb-2 mr-8">
<p><strong>À retenir</strong></p>
</div><div class="pl-8 mr-8">
<p>La technique qui consiste à stocker des valeurs intermédiaires pour accélérer le calcul est appelé <a href="https://fr.wikipedia.org/wiki/Compromis_temps-m%C3%A9moire">compromis temps/mémoire</a> est une technique importante à connaître.</p>
<p>Elle ne fera cependant pas de miracle puisqu'elle est bornée par la taille la mémoire disponible.</p>
</div></div>

<p>Et tout d'un coup avec notre clé de 64b, notre algorithme n'aura plus besoin que de $2^{32}$ opérations. À raison d'une opération par microseconde, il ne faudra plus que 5 millisecondes pour résoudre le problème !</p>
<div class="quote relative py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-red-500 bg-red-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-red-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"></path>
</svg>
<div class="pl-8 mb-2 mr-8">
<p><strong>À retenir</strong></p>
</div><div class="pl-8 mr-8">
<p>On considère actuellement que si le <a href="https://en.wikipedia.org/wiki/Key_size#Brute-force_attack">nombre de possibilité à tester est supérieur à $2^{128}$</a>, l'approche brute-force n'est pas profitable car il faudrait un temps de déchiffrage supérieure à la durée de vie du message.</p>
</div></div>

<div class="quote relative  py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-cyan-500 bg-cyan-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-cyan-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z"></path>
</svg>
<div class="pl-8 mr-8">
<p><a href="https://www.ssi.gouv.fr/administration/guide/mecanismes-cryptographiques/">recommendations ANSSI taille de clés</a></p>
</div></div>

<p>Pour une clé de 128bit et 1 opération par microsecondes :</p>
<ul>
<li>l'algorithme naïf prend de l'ordre de $10^{25}$ ans</li>
<li>l'algorithme baby-step giant step prend de l'ordre de $584942$ ans (ce qui est encore beaucoup mais on change tout de même d'ordre de grandeur).</li>
</ul>
<p>Les exemples précédents supposent un ordinateur avec un processeur unique et deux algorithmes non optimisés. Pour des algorithmes parallèles et optimisés on peut peut faire bien mieux.</p>
<p>Lorsque la puissance de calcul augmente, il suffit d'augmenter linéairement la taille de la clé puisque cela augmente exponentiellement le nombre de possibilités (doubler la vitesse d'un algorithme permet de traiter dans le même temps de clés à un bit de plus).</p>
<div class="quote relative py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-emerald-500 bg-emerald-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-emerald-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
  <path stroke-linecap="round" stroke-linejoin="round" d="M13.19 8.688a4.5 4.5 0 011.242 7.244l-4.5 4.5a4.5 4.5 0 01-6.364-6.364l1.757-1.757m13.35-.622l1.757-1.757a4.5 4.5 0 00-6.364-6.364l-4.5 4.5a4.5 4.5 0 001.242 7.244"></path>
</svg>
<div class="pl-8 mr-8">
<p>Voir <a href="https://math.mit.edu/classes/18.783/2022/LectureNotes9.pdf">https://math.mit.edu/classes/18.783/2022/LectureNotes9.pdf</a> ou encore <a href="https://www.lix.polytechnique.fr/~morain/MPRI/2013/lecture1.pdf">https://www.lix.polytechnique.fr/~morain/MPRI/2013/lecture1.pdf</a> pour d'autres algorithmes de résolution.</p>
</div></div>

<h2>Attaque</h2>
<p>Il existe beaucoup de types d'attaques possibles. Explicitons-en quelques unes.</p>
<h3>Brute force</h3>
<p>La meilleure attaque connue est l'attaque brute force en utilisant <a href="https://fr.wikipedia.org/wiki/Logarithme_discret#Algorithmes">l'algorithme du crible général</a> qui est une méthode de factorisation.</p>
<div class="quote relative py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-emerald-500 bg-emerald-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-emerald-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
  <path stroke-linecap="round" stroke-linejoin="round" d="M13.19 8.688a4.5 4.5 0 011.242 7.244l-4.5 4.5a4.5 4.5 0 01-6.364-6.364l1.757-1.757m13.35-.622l1.757-1.757a4.5 4.5 0 00-6.364-6.364l-4.5 4.5a4.5 4.5 0 001.242 7.244"></path>
</svg>
<div class="pl-8 mr-8">
<p><a href="https://github.com/vbsinha/Diffie-Hellman-Attacks?tab=readme-ov-file">https://github.com/vbsinha/Diffie-Hellman-Attacks?tab=readme-ov-file</a></p>
</div></div>

<p>Pour un nombre premier de 2058bit, l'attaque brute force en utilisant le crible général prend de l'ordre de $2^{90}$ opérations.</p>
<p>On préconise donc une taille de clé de 4096b actuellement. Voir <a href="https://www.bsi.bund.de/SharedDocs/Downloads/EN/BSI/Publications/TechGuidelines/TG02102/BSI-TR-02102-1.pdf?__blob=publicationFile">ce doc p35</a>.</p>
<h3>Man in the middle</h3>
<p>On ne cherche pas à décrypter le code, on se place en intermédiaire de la conversation :</p>
<pre><code>    Alice    |     Mallory       |     Bob
    privé    |      public       |    privé
-------------|-------------------|--------------
     M       |                   |
             |                   |
     a ---.  |b' ---.     .--- a'|  .--- b           
          v  |      v     v      |  v
     K &lt;--===|= A ===     === B =|===--&gt; K'           # 2 partages de clé sécurisé
             |                   |
  K ⊕ M = C -|--- C              |
             |     K ⊕ C = M     |  
             |      K' ⊕ M = C' -|----&gt; C'
             |                   |      K' ⊕ C' = M
</code></pre>
<p>Tout se passe comme si Alice parlait à Bob mais ils parlent tous les deux à Mallory qui fait l'intermédiaire : il se fait passer pour Bob auprès d'Alice et d'Alice auprès de Bob.</p>
<p>Il n'y a a priori aucun moyen de se prémunir de ce genre d'attaque si on ne possède pas un mécanisme d'authentification.</p>
<h3><span id="side-channel-attack"></span>Side channel attack</h3>
<p>L'exponentiation indienne peut s'écrire de façon binaire en utilisant le principe <a href="/cours_informatique/cours/misc/nombres/#exponentiation">MULTIPLY and SQUARE</a>.</p>
<pre><code>algorithme expo(x: [entier], y: [entier]) → [entier]:
  r := [entier]
  r ← [1, 0 .. 0]         # 64b par défaut 
  pour chaque i de 0 à n-1:
    si y[i] == 1:
      r ← mult(r, x)      # MULTIPLY
    x ← mult(x, x)        # SQUARE
  rendre r
</code></pre>
<p>On remarque qu'il y a deux fois plus de travail lorsque $y[i]$ vaut 1 que lorsqu'il vaut 0. Il est donc possible de connaître la clé :</p>
<ul>
<li>soit en analysant en temps réel le fonctionnement de l'algorithme</li>
<li>soit en mesurant le temps mis pour réaliser l'algorithme et comparer au mis par le même algorithme avec que des 0 ou des 1 comme clé.</li>
</ul>
<p>ça a l'air de la science fiction mais c'est tout à fait possible, ne serait-ce qu'en mesurant le courant pris par le processeur !</p>
<div class="quote relative py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-emerald-500 bg-emerald-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-emerald-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
  <path stroke-linecap="round" stroke-linejoin="round" d="M13.19 8.688a4.5 4.5 0 011.242 7.244l-4.5 4.5a4.5 4.5 0 01-6.364-6.364l1.757-1.757m13.35-.622l1.757-1.757a4.5 4.5 0 00-6.364-6.364l-4.5 4.5a4.5 4.5 0 001.242 7.244"></path>
</svg>
<div class="pl-8 mr-8">
<p><a href="https://perso.telecom-paristech.fr/pacalet/HWSec/lectures/side_channels/l-nb.pdf">Algorithmes et simple power analysis</a></p>
</div></div>

<div class="quote relative py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-emerald-500 bg-emerald-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-emerald-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
  <path stroke-linecap="round" stroke-linejoin="round" d="M13.19 8.688a4.5 4.5 0 011.242 7.244l-4.5 4.5a4.5 4.5 0 01-6.364-6.364l1.757-1.757m13.35-.622l1.757-1.757a4.5 4.5 0 00-6.364-6.364l-4.5 4.5a4.5 4.5 0 001.242 7.244"></path>
</svg>
<div class="pl-8 mr-8">
<ul>
<li><a href="https://fr.wikipedia.org/wiki/Attaque_par_canal_auxiliaire">side channel attack</a></li>
<li><a href="https://www.youtube.com/watch?v=3v5Von-oNUg">cours du MIT</a></li>
<li><a href="https://www.youtube.com/watch?v=2-zQp26nbY8">exemples de side channel attack</a></li>
<li><a href="https://www.youtube.com/watch?v=GPwNFrpd1KU">channel attack autres exemples</a></li>
<li><a href="https://www.ssi.gouv.fr/agence/publication/combined-fault-and-side-channel-attack-on-protected-implementations-of-aes/">Attaques sur Machines embarquées</a></li>
</ul>
</div></div>

<h2>Utilisation de courbes elliptiques</h2>
<p>Un des intérêt du protocole de Diffie-Hellmann est qu'il peut s'écrire sous la forme de courbes elliptiques, ce qui permet de réduire la taille de la clé tout en évitant l'attaque brute force.</p>
<blockquote>
<p>TBD à étoffer !</p>
</blockquote>
<blockquote>
<p>TBD <a href="https://andrea.corbellini.name/2015/05/17/elliptic-curve-cryptography-a-gentle-introduction/">https://andrea.corbellini.name/2015/05/17/elliptic-curve-cryptography-a-gentle-introduction/</a>
TBD On a besoin que de l'exposant. Cela peut donc se faire dans tout groupe pas obligé d'être dans Z/pZ.
TDB exemple avec courbe elliptique.
<a href="https://fr.wikipedia.org/wiki/%C3%89change_de_cl%C3%A9s_Diffie-Hellman_bas%C3%A9_sur_les_courbes_elliptiques">https://fr.wikipedia.org/wiki/Échange_de_clés_Diffie-Hellman_basé_sur_les_courbes_elliptiques</a>
TBD taille clé 256b actuellement (<a href="https://fr.wikipedia.org/wiki/Curve25519">courbe de Bernstein</a>)
Renvoyer à <a href="/cours_informatique/cours/misc/courbes-elliptiques" class="interne">Courbes elliptiques</a>
pour la def et les propriétés basiques d'une courbe elliptique.</p>
</blockquote>


</article>
    </main>

    <footer class="min-h-[50px] border-t-2 border-gray-200 mt-4">
      <div class="max-w-[1200px] mx-auto px-4 relative">
        <div class="min-h-[50px] flex justify-center items-center">
          <p>
            Cours d'informatique de François Brucker
          </p>
        </div>
        <div class="min-h-[50px] flex justify-center items-center absolute right-0 top-0">
          <button onclick="goTop()" id="myBtn" title="Go to top">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
              <path stroke-linecap="round" stroke-linejoin="round" d="M15 11.25l-3-3m0 0l-3 3m3-3v7.5M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
            </svg>
          </button>

          <button onclick="goBottom()" id="myBtn" title="Go to top">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
              <path stroke-linecap="round" stroke-linejoin="round" d="M9 12.75l3 3m0 0l3-3m-3 3v-7.5M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
            </svg>
          </button>
        </div>

      </div>
    </footer>

    <script>
      MathJax
        .startup
        .document
        .getMathItemsWithin(document.body);
    </script>

  </body>
</html>