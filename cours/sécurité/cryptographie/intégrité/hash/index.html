<!DOCTYPE html>
<html lang="fr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>Hash cryptographiques</title>

    

    <link href="https://prismjs.catppuccin.com/latte.css" rel="stylesheet">

    <link href="/cours_informatique/assets/node_modules/prismjs/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet">
    <script src="/cours_informatique/assets/node_modules/prismjs/plugins/line-numbers/prism-line-numbers.min.js"></script>
    
    <link href="/cours_informatique/assets/stylesheets/main.css" rel="stylesheet">

  </head>
  <body>
    <script>
      window.MathJax = {
        tex: {
          inlineMath: [
            [
              '$', '$'
            ],
            [
              '\\(', '\\)'
            ]
          ]
        },
        svg: {
          fontCache: 'global'
        }
      };

      function goTop() {
        window.scrollTo({top: 0});
      }
      function goBottom() {
        window.scrollTo({top: document.body.scrollHeight});
      }
    </script>
    <script type="text/javascript" id="MathJax-script" src="/cours_informatique/assets/node_modules/mathjax/es5/tex-svg-full.js"></script>

    <header class="border-b-2 border-gray-200 mb-4">
      <div class="max-w-[1200px] mx-auto px-4 relative">
        <div class="min-h-[50px] flex justify-between items-center">
          <a class="mx-2" href="/cours_informatique/">Home</a>
        </div>

        <div class="min-h-[50px] flex justify-center items-center absolute right-0 top-0">
          <a class="mx-2" href="/cours_informatique/about">About</a>
          <button onclick="goTop()" id="myBtn" title="Go to top">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
              <path stroke-linecap="round" stroke-linejoin="round" d="M15 11.25l-3-3m0 0l-3 3m3-3v7.5M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
            </svg>
          </button>

          <button onclick="goBottom()" id="myBtn" title="Go to top">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
              <path stroke-linecap="round" stroke-linejoin="round" d="M9 12.75l3 3m0 0l3-3m-3 3v-7.5M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
            </svg>
          </button>
        </div>

      </div>
    </header>

    <main class="max-w-[1200px] mx-auto px-4">
      
<article>

  <h1>Hash cryptographiques</h1>
  <div>
    

    
  </div>

  

    
<div class="quote relative  py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-purple-500 bg-purple-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-purple-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M5 19a2 2 0 01-2-2V7a2 2 0 012-2h4l2 2h4a2 2 0 012 2v1M5 19h14a2 2 0 002-2v-5a2 2 0 00-2-2H9a2 2 0 00-2 2v5a2 2 0 01-2 2z"></path>
</svg>
<div class="pl-8 mr-8">

<a class="interne" href="/cours_informatique/cours/">Cours</a><span class="px-1">/</span><a class="interne" href="/cours_informatique/cours/sécurité/">Sécurité</a><span class="px-1">/</span><a class="interne" href="/cours_informatique/cours/sécurité/cryptographie/">Cryptographie</a><span class="px-1">/</span><a class="interne" href="/cours_informatique/cours/sécurité/cryptographie/intégrité/">Intégrité</a><span class="px-1">/</span><a class="interne" href="/cours_informatique/cours/sécurité/cryptographie/intégrité/hash/">Hash cryptographiques</a>

</div></div>



    
      
<div class="quote relative  py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-pink-500 bg-pink-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-pink-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 6.253v13m0-13C10.832 5.477 9.246 5 7.5 5S4.168 5.477 3 6.253v13C4.168 18.477 5.754 18 7.5 18s3.332.477 4.5 1.253m0-13C13.168 5.477 14.754 5 16.5 5c1.747 0 3.332.477 4.5 1.253v13C19.832 18.477 18.247 18 16.5 18c-1.746 0-3.332.477-4.5 1.253"></path>
</svg>
<div class="pl-8 mb-2 mr-8">

<b>Prérequis :</b>

</div><div class="pl-8 mr-8">


      <ul>
              
              <li>
                <a class="interne" href="/cours_informatique/cours/algorithmie/structure-dictionnaire/fonctions-hash/">Fonctions de hachage</a>
              </li></ul>
      

</div></div>


    
  

  <div class="quote relative py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-emerald-500 bg-emerald-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-emerald-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
  <path stroke-linecap="round" stroke-linejoin="round" d="M13.19 8.688a4.5 4.5 0 011.242 7.244l-4.5 4.5a4.5 4.5 0 01-6.364-6.364l1.757-1.757m13.35-.622l1.757-1.757a4.5 4.5 0 00-6.364-6.364l-4.5 4.5a4.5 4.5 0 001.242 7.244"></path>
</svg>
<div class="pl-8 mr-8">
<ul>
<li><a href="https://fr.wikipedia.org/wiki/Fonction_de_hachage_cryptographique">Hash cryptographique</a></li>
<li><a href="https://membres-ljk.imag.fr/Bruno.Grenet/IntroCrypto/4.HashFunctions.pdf">Hash propriétés et autres</a></li>
</ul>
</div></div>

<p>Une fonction de hash cryptographique doit être conçue pour éviter les collisions, c'est à dire qu'en connaissant $a$ il est très difficile de trouver $b \neq a$ tel que $f(b) = f(a)$</p>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
</svg>
<div class="pl-8 mb-2 mr-8">
<p><strong>Définition</strong></p>
</div><div class="pl-8 mr-8">
<p>Une fonction $H: \{0, 1\}^\star \rightarrow \{0, 1\}^n$ est une fonction de <strong><em>hash cryptographique</em></strong> si elle est résistante aux collisions.</p>
<p>Tout algorithme efficace ne peut rendre un couple $(x, x')$ tel que $H(x) = H(x')$ qu'avec un avantage négligeable.</p>
</div></div>

<p>On peut relâcher la condition de résistance à la collision en :</p>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
</svg>
<div class="pl-8 mb-2 mr-8">
<p><strong>Définition</strong></p>
</div><div class="pl-8 mr-8">
<p>Une fonction $H: \{0, 1\}^\star \rightarrow \{0, 1\}^n$ est <strong><em>résistant à la pré-image</em></strong> si étant donné $y$, tout algorithme efficace ne peut trouver $x$ tel que $H(x) = y$ qu'avec un avantage négligeable.</p>
</div></div>

<p>Ou encore :</p>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
</svg>
<div class="pl-8 mb-2 mr-8">
<p><strong>Définition</strong></p>
</div><div class="pl-8 mr-8">
<p>Une fonction $H: \{0, 1\}^\star \rightarrow \{0, 1\}^n$ est <strong><em>résistant à la seconde pré-image</em></strong> si étant donné $x$, tout algorithme efficace ne peut trouver $x'$ tel que $H(x) = H(x')$ qu'avec un avantage négligeable.</p>
</div></div>

<p>La résistance à la seconde pré-image condition étant plus restrictive que la résistance à la pré-image.</p>
<h2>Usage</h2>
<h3>Intégrité non sécurisée</h3>
<p>On accole le hash au message envoyé : $m || H(m)$</p>
<p>Le message est bien transmis si le hash du message arrivé correspond au hash concaténé. On peut alors associer un couple $(S, V)$ <strong><em>signe et vérifie</em></strong> :</p>
<ul>
<li>$S(m) = H(m)$</li>
<li>$V(m, h) = (H(m) == h)$</li>
</ul>
<div class="quote relative py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-red-500 bg-red-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-red-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"></path>
</svg>
<div class="pl-8 mr-8">
<p>Rien n'empêche un attaquant de modifier et $m$ et son hash. Cette technique est uniquement preuve de transmission correct d'un message dans un canal pouvant être bruité, mais pas susceptible d'être attaqué.</p>
</div></div>

<h3>Stockage sécurisé</h3>
<div class="quote relative py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-emerald-500 bg-emerald-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-emerald-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
  <path stroke-linecap="round" stroke-linejoin="round" d="M13.19 8.688a4.5 4.5 0 011.242 7.244l-4.5 4.5a4.5 4.5 0 01-6.364-6.364l1.757-1.757m13.35-.622l1.757-1.757a4.5 4.5 0 00-6.364-6.364l-4.5 4.5a4.5 4.5 0 001.242 7.244"></path>
</svg>
<div class="pl-8 mr-8">
<p><a href="https://patouche.github.io/2015/03/21/stocker-des-mots-de-passe/">stocker ses mots de passes</a></p>
</div></div>

<p>Les mots de passe d'un système son normalement stockés sous la forme d'un hash, auquel on ajoute un <em>sel</em> aléatoire. Voyons pourquoi.</p>
<h4>Ne pas faire</h4>
<ol>
<li>Stockage en clair dans un fichier : pas sécurisé du tout</li>
<li>Stockage en clair dans un fichier accessible par un seul utilisateur : si vol de l'ordinateur pas sécurisé</li>
<li>Mot de passe chiffré : le mot de passe est potentiellement connu de plusieurs autres personnes, dont l'administrateur.</li>
</ol>
<h4>Utilisation d'un hash</h4>
<p>A priori <strong>personne</strong> à part l'utilisateur n'à à connaître son mot de passe. On peut arriver à ceci en utilisant une fonction de hash :</p>
<ol>
<li>on stocke dans la base le hash d'un mot de passe</li>
<li>si le hash du mot de passe tapé correspond au hash de la base, c'est bon</li>
</ol>
<p>Si le hash est cryptographique la probabilité de collision est négligeable : il est statistiquement impossible de tomber par hasard sur un mot ayant le même hash.</p>
<div class="quote relative py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-red-500 bg-red-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-red-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"></path>
</svg>
<div class="pl-8 mr-8">
<p>Si le mot de passe est simple la probabilité de tomber sur vote mot de passe sera plus grande que la probabilité de collision. Utiliser une table de hachage ne dispense pas d'avoir un mot de passe <em>sécurisé</em>.</p>
</div></div>

<p>Deux types d'attaques génériques fonctionne bien pour des mot de passes non sécurisés (<em>ie.</em> pas assez long ou sur par assez de caractères différents). L'attaque <a href="https://fr.wikipedia.org/wiki/Attaque_par_force_brute#Complexit%C3%A9_th%C3%A9orique_de_l'attaque">Brute force si faible nombre de possibilités</a> fonctionne assez bien car :</p>
<ul>
<li>si uniquement des caractères minuscules $2^{128} = 26^x$ donne $x = 28$ ce qui est trop long</li>
<li>si uniquement des caractères minuscules et majuscule $2^{128} = 26^x$ donne $x = 23$ ce qui est trop long aussi, mais ok pour des <a href="https://fr.wikipedia.org/wiki/Phrase_secr%C3%A8te">passphrase</a>.</li>
<li>si tout le clvier, l'ordre de 100 possibilité ce qui fait pour un mot de passe de 8 caractères $2^{54}$. D'où la nécessité de limiter le nombre d'essais.</li>
<li>si base 64, il faut $128/7 \simeq 18$ pour obtenir pour obtenir jun mot de passe sécurisé brute force.</li>
</ul>
<p>On peut accélérer le processus en utilisant un dictionnaire des mots de passes les plus utilisés (des mots ou des combinaisons de mots français) et en les choisissant en priorité. Et on les choisis par ordre aléatoires.</p>
<h4>Salage du hash</h4>
<p>Enfin, stocker les et pas les mots de passes en clair hash n'aide pas vraiment :</p>
<ul>
<li>on peut utiliser des tables de hash déjà faites</li>
<li>si la base de mots de passes est grande on va retrouver plusieurs fois le même hash.</li>
</ul>
<p>Pour ne garder aucune trace statistique dans le fichier stocké <a href="https://fr.wikipedia.org/wiki/Salage_(cryptographie)">on utilise un sel</a>. On obtient le couple signature, vérification :</p>
<ul>
<li>$S(m) = SALT || H(SALT || m)$</li>
<li>$V(m, t) = H(t[:p] || m) = t[p:]$ où $p$ est la longueur du sel</li>
</ul>
<div class="quote relative py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-emerald-500 bg-emerald-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-emerald-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
  <path stroke-linecap="round" stroke-linejoin="round" d="M13.19 8.688a4.5 4.5 0 011.242 7.244l-4.5 4.5a4.5 4.5 0 01-6.364-6.364l1.757-1.757m13.35-.622l1.757-1.757a4.5 4.5 0 00-6.364-6.364l-4.5 4.5a4.5 4.5 0 001.242 7.244"></path>
</svg>
<div class="pl-8 mr-8">
<p><a href="https://www.youtube.com/watch?v=Sc3aHMCc4h0">argon2</a></p>
</div></div>

<h3>Clés</h3>
<p>La non collision permet de rechercher les hash plutôt que les valeurs exactes dans une liste stockant toutes les données. C'est la technique utilisée par Git pour gérer les ajouts, suppressions et modifications de code dans un projet.</p>
<div class="quote relative  py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-cyan-500 bg-cyan-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-cyan-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z"></path>
</svg>
<div class="pl-8 mr-8">
<p>Git utilise par défaut la fonction de hash <a href="https://fr.wikipedia.org/wiki/SHA-1">SHA-1</a>.</p>
</div></div>

<h2>Construction</h2>
<p>Il existe de nombreux hash. Testez les différences pour voir :</p>
<div class="quote relative py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-emerald-500 bg-emerald-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-emerald-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
  <path stroke-linecap="round" stroke-linejoin="round" d="M13.19 8.688a4.5 4.5 0 011.242 7.244l-4.5 4.5a4.5 4.5 0 01-6.364-6.364l1.757-1.757m13.35-.622l1.757-1.757a4.5 4.5 0 00-6.364-6.364l-4.5 4.5a4.5 4.5 0 001.242 7.244"></path>
</svg>
<div class="pl-8 mr-8">
<p><a href="https://emn178.github.io/online-tools/sha1.html">exemples de hash</a></p>
</div></div>

<p>Nous allons voir deux constructions. La première utilisée actuellement, la seconde qui vient.</p>
<h3>Construction courante</h3>
<blockquote>
<p>TBD comme pour le chiffrement. Un bloc
puis on lie de façon sécurisée.</p>
</blockquote>
<h4>construction par Davies–Meyer</h4>
<div class="quote relative py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-emerald-500 bg-emerald-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-emerald-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
  <path stroke-linecap="round" stroke-linejoin="round" d="M13.19 8.688a4.5 4.5 0 011.242 7.244l-4.5 4.5a4.5 4.5 0 01-6.364-6.364l1.757-1.757m13.35-.622l1.757-1.757a4.5 4.5 0 00-6.364-6.364l-4.5 4.5a4.5 4.5 0 001.242 7.244"></path>
</svg>
<div class="pl-8 mr-8">
<p><a href="https://fr.wikipedia.org/wiki/Construction_de_Davies-Meyer">Construction Davies–Meyer</a></p>
</div></div>

<p>On utilise la construction Davies–Meyer qui permet de transformer <a href="../../confidentialit%C3%A9/nombres-pseudo-al%C3%A9atoires-cryptographiques/#PRP" class="interne">une permutation pseudo-aléatoire sécurisée</a> $P : \{0, 1\}^s \times \{0, 1\}^t \rightarrow \{0, 1\}^t$ ($P(k, x)$ est une permutation aléatoire de $x$) en hash à taille fixe.</p>
<pre><code>       iv   
        |   
      --|-- 
 k---|&gt; P  |
      ----- 
        |
     P(k,iv)   
</code></pre>
<p>On fait rentrer le message là où normalement arrive la clé. Et un utilisant une constante $\text{IV}$ (initial value) à la place de la où habituellement se place un message.</p>
<div>
$$
H(m) = P(m, \text{IV}) \oplus \text{IV}
$$
</div>
<p>Ce qui donne schéma :</p>
<pre><code>       iv 
        |  
        |------⊕------ H(m)  
     ---|--    |
m---|&gt;  P  |   |
     ------    |
        |      |
        --------
</code></pre>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
</svg>
<div class="pl-8 mb-2 mr-8">
<p><strong>Théorème</strong></p>
</div><div class="pl-8 mr-8">
<p>Si le bloc est une PRP, alors la résistance à la collision est maximale.</p>
</div></div>

<div class="relative drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-indigo-500 bg-indigo-100">
<details class="group" open="">
<summary class="list-none py-0.5">
<svg class="group-open:hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M9 5l7 7-7 7"></path>
</svg>
<svg class="group-open:block hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7"></path>
</svg>
<div class="pl-8 font-bold inline-block">
<p>preuve</p>
</div>
<svg class="group-open:hidden inline-block pl-3 w-10 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M5 12h.01M12 12h.01M19 12h.01M6 12a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0z"></path>
</svg>
</summary>
<div class="mx-8 pb-2">
<p>Comme la permutation de $P(k, \cdot)$ est répartie uniformément selon $k$, la probabilité que deux messages différents aient le même hash $P(m, \text{iv}) \oplus \text{iv} = P(m', \text{iv}) \oplus \text{iv}$ est la même qu'avoir deux fonctions différentes $f$ et $f'$ de $\mathcal{F}(\{0, 1\}^t, \{0, 1\}^t)$ telle que $f(\text{iv}) = f'(\text{iv})$. Cela revient à la probabilité de choisir deux fois le même élément de $\{0, 1\}^t$, c'est à dire $1/2^t$.</p>
<p>Réciproquement, si l'on connaît $P(m, \text{iv}) \oplus \text{iv}$, trouver $m' \neq m$ tel que $P(m, \text{iv}) \oplus \text{iv} = P(m', \text{iv}) \oplus \text{iv}$ revient à trouver au hasard une fonction $f$ de $\mathcal{F}(\{0, 1\}^t, \{0, 1\}^t)$ telle que $f(\text{iv}) = P(m, \text{iv})$ cette probabilité est aussi de $1/2^t$.</p>
</div>
</details>     
</div>
<p>La preuve nécessite un PRP, mais comme on est pas sur que cela existe, les algorithmes mettant en oeuvre ce principe doivent être conçus pour très bien mélanger les bits tout en étant non prédictif (il faut le faire de façon &quot;<em>compliquée</em>&quot;).</p>
<p>Les algorithmes SHA-1 et SHA-2 sont basés sur ce principes. Les permutation sécurisées utilisées sont appelées <a href="https://fr.wikipedia.org/wiki/Shacal">shacal-1 et shacal-2</a>. Mais on pourrait tout aussi bien utiliser chacha20 pour cela ! Ou son grand frère salsa20 originellement construit pour ça.</p>
<h4>Extension par Merkel Damgard</h4>
<div class="quote relative py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-emerald-500 bg-emerald-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-emerald-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
  <path stroke-linecap="round" stroke-linejoin="round" d="M13.19 8.688a4.5 4.5 0 011.242 7.244l-4.5 4.5a4.5 4.5 0 01-6.364-6.364l1.757-1.757m13.35-.622l1.757-1.757a4.5 4.5 0 00-6.364-6.364l-4.5 4.5a4.5 4.5 0 001.242 7.244"></path>
</svg>
<div class="pl-8 mr-8">
<p><a href="https://www.youtube.com/watch?v=s7arHByjSOw">Merkel Damgard preuve</a></p>
</div></div>

<p>On utilise la construction de <a href="https://fr.wikipedia.org/wiki/Construction_de_Merkle-Damg%C3%A5rd">Construction de Merkel Damgard</a> pour étendre la portée du hash à taille fixe à des messages dont la taille est un multiple de $t$. POur cela, on commence par ajouter <a href="https://fr.wikipedia.org/wiki/Remplissage_(cryptographie)">un padding</a> à la fin qui consiste en :</p>
<div>
$$
m \;\|\; 1 \;\|\; 0\dots 0 \;\|\; \text{taille du message}
$$
</div>
<p>Ensuite, on itère la construction précédente :</p>
<pre><code>       iv        H(m1)                   H(m2)                   H(mi)                  H(m)  
        |------⊕----------------|------⊕------- ... ----|------⊕------- .... ---|------⊕--------
        |      |                |      |                |      |                |      |        
     ---|--    |             ---|--    |             ---|--    |             ---|--    |        
m1--|&gt;  P  |   |        m2--|&gt;  P  |   |        mi--|&gt;  P  |   |        ml--|&gt;  P  |   |        
     ------    |             ------    |             ------    |             ------    |        
        |      |                |      |                |      |                |      |        
        --------                --------                --------                --------        
</code></pre>
<p>Le message final doit bien faire une taille multiple de la taille du hash à taille fixe. Si le message est déjà de la bonne taille on ajoute tout de même un bloc ne contenant que le padding et la taille.</p>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
</svg>
<div class="pl-8 mb-2 mr-8">
<p><strong>Théorème</strong></p>
</div><div class="pl-8 mr-8">
<p>Si un bloc est résistant à la collision, la construction entière l'est.</p>
</div></div>

<div class="relative drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-indigo-500 bg-indigo-100">
<details class="group" open="">
<summary class="list-none py-0.5">
<svg class="group-open:hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M9 5l7 7-7 7"></path>
</svg>
<svg class="group-open:block hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7"></path>
</svg>
<div class="pl-8 font-bold inline-block">
<p>preuve</p>
</div>
<svg class="group-open:hidden inline-block pl-3 w-10 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M5 12h.01M12 12h.01M19 12h.01M6 12a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0z"></path>
</svg>
</summary>
<div class="mx-8 pb-2">
<p>Supposons qu'il y ait une collision :</p>
<p>On a alors $H_n = H'_{n'}$ ce qui implique :</p>
<div>
$$
P(H_{m-1}, m_n \ ||\  \text{pad}) = P(H'_{m'-1}, m'_{n'} \ ||\  \text{pad}')
$$
</div>
<p>De là si :</p>
<div>
$$
m_n \ ||\  \text{pad} \neq m'_{n'} \ ||\  \text{pad}
$$
</div>
<p>On a découvert une collision interne ce qui est improbable. Donc :</p>
<div>
$$
m_n \ ||\  \text{pad} = m'_{n'} \ ||\  \text{pad}'
$$
</div>
<p>Alors :</p>
<ol>
<li>$\text{pad} = \text{pad}'$ ce qui implique que les deux messages ont la même taille</li>
<li>$m_n = m'_n$ : les messages ont la même fin</li>
</ol>
<p>On conclut la preuve en remarquant que si $H_{m-1}$ est différent de ${H'}_{m-1}$ on a une collision ce qui est improbable. Les deux sont alors égaux et poursuit par récurrence.</p>
</div>
</details>     
</div>
<p>Les fonctions de hash très utilisés que sont les SHA-1 et SHA-2 sont basées sur ce principe. En revanche, SHA-3, le petit nouveau, est basé sur un autre principe que nous allons rapidement aborder maintenant.</p>
<div class="quote relative py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-emerald-500 bg-emerald-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-emerald-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
  <path stroke-linecap="round" stroke-linejoin="round" d="M13.19 8.688a4.5 4.5 0 011.242 7.244l-4.5 4.5a4.5 4.5 0 01-6.364-6.364l1.757-1.757m13.35-.622l1.757-1.757a4.5 4.5 0 00-6.364-6.364l-4.5 4.5a4.5 4.5 0 001.242 7.244"></path>
</svg>
<div class="pl-8 mr-8">
<p><a href="https://www.youtube.com/watch?v=orIgy2MjqrA">L'algorithme sha2</a></p>
</div></div>

<h3>Construction en éponge</h3>
<div class="quote relative  py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-cyan-500 bg-cyan-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-cyan-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z"></path>
</svg>
<div class="pl-8 mr-8">
<p>Les <a href="https://en.wikipedia.org/wiki/Sponge_function">sponge function</a></p>
</div></div>

<blockquote>
<p>TBD :</p>
<ul>
<li><a href="https://www.youtube.com/watch?v=fzlflyw7X2I">fonctionnement de SHA-3</a></li>
<li><a href="https://www.youtube.com/watch?v=bTOJ9An9wpE">sha 3 sponge function</a></li>
<li><a href="https://keccak.team/files/SpongeFunctions.pdf">sponge function thm</a></li>
<li><a href="https://summerschool-croatia.cs.ru.nl/2017/slides/introduction%20to%20permutation-based%20cryptography.pdf">https://summerschool-croatia.cs.ru.nl/2017/slides/introduction to permutation-based cryptography.pdf</a></li>
</ul>
</blockquote>
<h2>Attaque</h2>
<div class="quote relative py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-emerald-500 bg-emerald-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-emerald-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
  <path stroke-linecap="round" stroke-linejoin="round" d="M13.19 8.688a4.5 4.5 0 011.242 7.244l-4.5 4.5a4.5 4.5 0 01-6.364-6.364l1.757-1.757m13.35-.622l1.757-1.757a4.5 4.5 0 00-6.364-6.364l-4.5 4.5a4.5 4.5 0 001.242 7.244"></path>
</svg>
<div class="pl-8 mr-8">
<ul>
<li><a href="https://people.cs.uchicago.edu/~davidcash/284-autumn-21/12-hash.pdf">Attaque des fonctions de hash</a></li>
<li><a href="https://www.youtube.com/watch?v=Zl1TZJGfvPo">sha 1 collision</a></li>
</ul>
</div></div>

<h3>Attaque des anniversaires</h3>
<p>L'attaque générique des anniversaires est l'attaque brute force associée aux fonctions de hash cryptographique.</p>
<p>Grace au <a href="/cours_informatique/cours/algorithmie/structure-dictionnaire/fonctions-hash/#paradoxe-anniversaires" class="interne">paradoxe des anniversaires</a>, on sait qu'il suffit de $2^{n/2}$ mots de $\{0, 1\}^n$ pour avoir une probabilité supérieure à 1/2 d'avoir deux éléments $x$ et $x'$ tels que $H(x) = H(x')$.</p>
<p>Il n'est pas nécessaire de stocker tous les mots en mémoire, on peut montrer qu'il suffit de :</p>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
</svg>
<div class="pl-8 mb-2 mr-8">
<p><strong>Algorithme attaque par point fixe</strong></p>
</div><div class="pl-8 mr-8">
<ol>
<li>prendre $x_1 = y_1$ un mot aléatoire de $\{0, 1\}^n$</li>
<li>créer itérativement $x_i = H(x_{i−1})$ et $y_i = H(H(y_{i−1}))$ jusqu'à ce que $x_m = y_m$</li>
<li>on a alors $H(x_{m−1}) = H(H(y_{m−1}))$ si $x_{m-1} \neq H(y_{m−1})$ (ce qui est très probable)</li>
</ol>
<p>Il faut, comme l'attaque brute force du dictionnaire de l'ordre de $\mathcal{O}(2^{n/2})$ opération avant de trouver une collision</p>
</div></div>

<div class="relative drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-indigo-500 bg-indigo-100">
<details class="group" open="">
<summary class="list-none py-0.5">
<svg class="group-open:hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M9 5l7 7-7 7"></path>
</svg>
<svg class="group-open:block hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7"></path>
</svg>
<div class="pl-8 font-bold inline-block">
<p>preuve</p>
</div>
<svg class="group-open:hidden inline-block pl-3 w-10 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M5 12h.01M12 12h.01M19 12h.01M6 12a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0z"></path>
</svg>
</summary>
<div class="mx-8 pb-2">
<p>C'est l'<a href="https://fr.wikipedia.org/wiki/Algorithme_du_li%C3%A8vre_et_de_la_tortue">algorithme du lièvre et de la tortue</a>.</p>
<p>L'ensemble d'arrivée de $H$ étant fini, il va exister, pour tout $x$, un entier $p$ tels que $H^p(x) = H^q(x)$ avec $q &gt; p$.</p>
<p>On pose :</p>
<ul>
<li>$\lambda = p$</li>
<li>$\mu = q-p$</li>
</ul>
<p>Soit $x$ le plus petit entier tel que $\lambda +x$ soit un multiple de $\mu$. On a $0 \leq x \leq \mu$ puisque la division euclidienne de $\lambda$ par $\mu$ donne $\lambda = q\cdot \mu +r$ et donc $x=\mu-r$</p>
<p>On a alors : $2(\lambda +x) = \lambda +x + k\cdot \mu$ et donc $H^{2(\lambda +x)}(x) = H^{\lambda +x}(x)$.</p>
<blockquote>
<p>TBD aussi en analysant si lapin en arrière de k de la tortue sur le cycle : à l'étape d'après k-1 en arrière.</p>
</blockquote>
</div>
</details>     
</div>
<p>Notez que si l'attaque des anniversaires ne donne pas de garanties sur les deux mots que l'on trouve, il est très facile de modifier 2 documents différents de façon aléatoire un très grand nombre de fois, ce qui va garantir de tomber sur une collision tout en ayant deux texte se ressemblant.</p>
<div class="quote relative  py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-cyan-500 bg-cyan-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-cyan-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z"></path>
</svg>
<div class="pl-8 mr-8">
<p>La technique précédente permet de présenter deux textes différents de même hash en :</p>
<ol>
<li>écrivant deux textes différents</li>
<li>modifier aléatoirement les deux textes en ajoutant des espaces, des retours chariots ou backspace. Bref plein de choses qui ne se voient pas une fois.</li>
<li>au bout de $2^{n/2}$ modifications, on a deux deux texte de même hash où le contenu <em>visible</em> est celui des deux textes initiaux.</li>
</ol>
<p>Il suffit ensuite de faire signer la version $A$ du texte puis de présenter la version $B$, prétendument signée.</p>
<p>Il faut toujours modifier un peu un document que l'on signe, histoire que l'attaquant doive tout refaire.</p>
</div></div>

<h3>Brute force par Rainbow tables</h3>
<p>On peut même préparer un dictionnaire de ots hachés pour aller plus vite voir utiliser des <a href="https://en.wikipedia.org/wiki/Rainbow_table">https://en.wikipedia.org/wiki/Rainbow_table</a> (voir aussi <a href="https://rsheasby.medium.com/rainbow-tables-probably-arent-what-you-think-30f8a61ba6a5">https://rsheasby.medium.com/rainbow-tables-probably-arent-what-you-think-30f8a61ba6a5</a>) qui est encore une version du compromis temps/mémoire déjà vu pour le baby step/giant step.</p>
<blockquote>
<p>TBD expliquer et faire exemple Donner complexité en temps et en mémoire</p>
</blockquote>
<h3>Length extension attack</h3>
<p>Pour des construction Merkel-Damgard on peut continuer la procédure et étendre le hash. Tout se passe comme si on avait un message plus grand. Si le protocole en face n'est pas propre ce la peut mener à des catastrophes :</p>
<pre><code>
...

destinataire : François
versement : 100 euros
</code></pre>
<p>Si on ajoute la ligne :</p>
<pre><code>
....

destinataire : François
versement : 100 euros
versement : 1000000 euros
</code></pre>
<p>On peut continuer le hash sans connaître le message initial.</p>
<h3>Differential Analysis</h3>
<div class="quote relative py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-emerald-500 bg-emerald-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-emerald-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
  <path stroke-linecap="round" stroke-linejoin="round" d="M13.19 8.688a4.5 4.5 0 011.242 7.244l-4.5 4.5a4.5 4.5 0 01-6.364-6.364l1.757-1.757m13.35-.622l1.757-1.757a4.5 4.5 0 00-6.364-6.364l-4.5 4.5a4.5 4.5 0 001.242 7.244"></path>
</svg>
<div class="pl-8 mr-8">
<p><a href="https://en.wikipedia.org/wiki/Differential_cryptanalysis">differential analysis</a></p>
</div></div>

<blockquote>
<p>TBD</p>
</blockquote>
<!-- TBD

> :
> - <https://antoine.delignat-lavaud.fr/doc/slides_md5.pdf>
> <https://www.youtube.com/watch?v=GQX8W8zKf2Q>
> - <https://crypto.stackexchange.com/questions/98092/what-is-a-differential-attack-on-a-hash-function-how-would-one-attack-a-sha-alg>

-->


</article>
    </main>

    <footer class="min-h-[50px] border-t-2 border-gray-200 mt-4">
      <div class="max-w-[1200px] mx-auto px-4 relative">
        <div class="min-h-[50px] flex justify-center items-center">
          <p>
            Cours d'informatique de François Brucker
          </p>
        </div>
        <div class="min-h-[50px] flex justify-center items-center absolute right-0 top-0">
          <button onclick="goTop()" id="myBtn" title="Go to top">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
              <path stroke-linecap="round" stroke-linejoin="round" d="M15 11.25l-3-3m0 0l-3 3m3-3v7.5M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
            </svg>
          </button>

          <button onclick="goBottom()" id="myBtn" title="Go to top">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
              <path stroke-linecap="round" stroke-linejoin="round" d="M9 12.75l3 3m0 0l3-3m-3 3v-7.5M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
            </svg>
          </button>
        </div>

      </div>
    </footer>

    <script>
      MathJax
        .startup
        .document
        .getMathItemsWithin(document.body);
    </script>

  </body>
</html>