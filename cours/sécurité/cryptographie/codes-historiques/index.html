<!DOCTYPE html>
<html lang="fr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>Codes historiques</title>

    <link href="/cours_informatique/assets/node_modules/prismjs/themes/prism-solarizedlight.min.css" rel="stylesheet">
    <link href="/cours_informatique/assets/node_modules/prismjs/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet">

    <link href="/cours_informatique/assets/stylesheets/main.css" rel="stylesheet">

  </head>
  <body>
    <script>
      window.MathJax = {
        tex: {
          inlineMath: [
            [
              '$', '$'
            ],
            [
              '\\(', '\\)'
            ]
          ]
        },
        svg: {
          fontCache: 'global'
        }
      };

      function goTop() {
        window.scrollTo({top: 0});
      }
      function goBottom() {
        window.scrollTo({top: document.body.scrollHeight});
      }
    </script>
    <script type="text/javascript" id="MathJax-script" src="/cours_informatique/assets/node_modules/mathjax/es5/tex-svg-full.js"></script>

    <header class="border-b-2 border-gray-200 mb-4">
      <div class="max-w-[1200px] mx-auto px-4 relative">
        <div class="min-h-[50px] flex justify-between items-center">
          <a class="mx-2" href="/cours_informatique/">Home</a>
        </div>

        <div class="min-h-[50px] flex justify-center items-center absolute right-0 top-0">
          <a class="mx-2" href="/cours_informatique/about">About</a>
          <button onclick="goTop()" id="myBtn" title="Go to top">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
              <path stroke-linecap="round" stroke-linejoin="round" d="M15 11.25l-3-3m0 0l-3 3m3-3v7.5M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
            </svg>
          </button>

          <button onclick="goBottom()" id="myBtn" title="Go to top">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
              <path stroke-linecap="round" stroke-linejoin="round" d="M9 12.75l3 3m0 0l3-3m-3 3v-7.5M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
            </svg>
          </button>
        </div>

      </div>
    </header>

    <main class="max-w-[1200px] mx-auto px-4">
      
<article>

  <h1>Codes historiques</h1>
  <div>
    

    
  </div>

  

    
<div class="quote relative  py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-purple-500 bg-purple-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-purple-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M5 19a2 2 0 01-2-2V7a2 2 0 012-2h4l2 2h4a2 2 0 012 2v1M5 19h14a2 2 0 002-2v-5a2 2 0 00-2-2H9a2 2 0 00-2 2v5a2 2 0 01-2 2z"></path>
</svg>
<div class="pl-8 mr-8">

<a class="interne" href="/cours_informatique/cours/">Cours</a><span class="px-1">/</span><a class="interne" href="/cours_informatique/cours/sécurité/">Sécurité</a><span class="px-1">/</span><a class="interne" href="/cours_informatique/cours/sécurité/cryptographie/">Cryptographie</a><span class="px-1">/</span><a class="interne" href="/cours_informatique/cours/sécurité/cryptographie/codes-historiques/">Codes historiques</a>

</div>
</div>


    
  

  <p>En analysant 4 codes historiques, on verra quelques concepts utile pour l'analyse.</p>
<h2>Code de césar</h2>
<h3><span id="César-chiffre"></span>Chiffrement</h3>
<p>Chaque lettre est décalée dans l'alphabet :</p>
<div>
$$
\left\{
  \begin{array}{lll}
    E(k, m) &=& m + k \mod 26\\
    D(k, c) &=& c - k \mod 26\\
  \end{array}
\right.
$$
</div>
<div class="quote relative  py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-cyan-500 bg-cyan-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-cyan-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z"></path>
</svg>
<div class="pl-8 mr-8">
<p>Le <a href="https://fr.wikipedia.org/wiki/ROT13">ROT(13)</a>, César où $k=13$ (<code>A</code> est remplacé par <code>N</code>) est l'ancêtre du floutage NSFW.</p>
</div>
</div>
<p>Le code de César est un exemple de <em><strong>Codage par flux</strong></em> (<em>stream cipher</em>) : chaque lettre est chiffrée une à une avec le même algorithme (il ne change pas à chaque lettre à coder)</p>
<table>
<thead>
<tr>
<th>lettre</th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
<th>E</th>
<th>F</th>
<th>G</th>
<th>H</th>
<th>I</th>
<th>J</th>
<th>K</th>
<th>L</th>
<th>M</th>
<th>N</th>
<th>O</th>
<th>P</th>
<th>Q</th>
<th>R</th>
<th>S</th>
<th>T</th>
<th>U</th>
<th>V</th>
<th>W</th>
<th>X</th>
<th>Y</th>
<th>Z</th>
</tr>
</thead>
<tbody>
<tr>
<td>code</td>
<td>N</td>
<td>O</td>
<td>P</td>
<td>Q</td>
<td>R</td>
<td>S</td>
<td>T</td>
<td>U</td>
<td>V</td>
<td>W</td>
<td>X</td>
<td>Y</td>
<td>Z</td>
<td>A</td>
<td>B</td>
<td>C</td>
<td>D</td>
<td>E</td>
<td>F</td>
<td>G</td>
<td>H</td>
<td>I</td>
<td>J</td>
<td>K</td>
<td>L</td>
<td>M</td>
</tr>
</tbody>
</table>
<p>Faisons ça en shell, parce que pourquoi pas. Chaîne à coder :</p>
<pre><code>Longtemps je me suis couché de bonne heure.
</code></pre>
<p>On ne peut avoir que des code ASCII, don con transforme tout, pour supprimer les accents :</p>
<pre><code>❯ echo &quot;Longtemps je me suis couché de bonne heure.&quot; | recode -f utf8..flat

Longtemps je me suis couche de bonne heure.
</code></pre>
<p>On chiffre :</p>
<pre><code>❯ echo &quot;Longtemps je me suis couché de bonne heure.&quot; | recode -f utf8..flat | tr &quot;A-Za-z&quot; &quot;N-ZA-Mn-za-m&quot;

Ybatgrzcf wr zr fhvf pbhpur qr obaar urher.
</code></pre>
<p>On déchiffre. L'intérêt du ROT13 est que c'est le même algorithme pour le chiffrage et le déchiffrage :</p>
<pre><code>❯ echo &quot;Ybatgrzcf wr zr fhvf pbhpur qr obaar urher.&quot; | recode -f utf8..flat | tr &quot;A-Za-z&quot; &quot;N-ZA-Mn-za-m&quot;

Longtemps je me suis couche de bonne heure.
</code></pre>
<p>Le tout en une seule fois (avec des tee pour afficher les résultats intermédiaires) :</p>
<pre><code>❯ echo &quot;Longtemps je me suis couché de bonne heure.&quot; | recode -f utf8..flat | tee /dev/tty | tr &quot;A-Za-z&quot; &quot;N-ZA-Mn-za-m&quot; | tee /dev/tty | tr &quot;A-Za-z&quot; &quot;N-ZA-Mn-za-m&quot;

Longtemps je me suis couche de bonne heure.
Ybatgrzcf wr zr fhvf pbhpur qr obaar urher.
Longtemps je me suis couche de bonne heure.
</code></pre>
<h3><span id="César-analyse"></span>Cryptanalyse</h3>
<ol>
<li>Ne résiste pas au calcul exhaustif des clés : 26</li>
<li>Ne résiste pas à l'analyse en <a href="https://fr.wikipedia.org/wiki/Fr%C3%A9quence_d'apparition_des_lettres">fréquence de chaque lettre</a></li>
</ol>
<p>&quot;Longtemps je me suis couche de bonne heure.&quot;. les 4 premières fréquences:</p>
<ul>
<li><code>E</code> 22%85</li>
<li><code>U</code> 8%57</li>
<li><code>S</code> 8%57</li>
<li><code>O</code> 8%57</li>
</ul>
<p>Français :</p>
<table>
<tbody>
<tr>
<td>E</td>
<td>17.76</td>
<td>O</td>
<td>5.34</td>
<td>B</td>
<td>0.80</td>
</tr>
<tr>
<td>S</td>
<td>8.23</td>
<td>D</td>
<td>3.60</td>
<td>H</td>
<td>0.64</td>
</tr>
<tr>
<td>A</td>
<td>7.68</td>
<td>C</td>
<td>3.32</td>
<td>X</td>
<td>0.54</td>
</tr>
<tr>
<td>N</td>
<td>7.61</td>
<td>P</td>
<td>3.24</td>
<td>Y</td>
<td>0.21</td>
</tr>
<tr>
<td>T</td>
<td>7.30</td>
<td>M</td>
<td>2.72</td>
<td>J</td>
<td>0.19</td>
</tr>
<tr>
<td>I</td>
<td>7.23</td>
<td>Q</td>
<td>1.34</td>
<td>Z</td>
<td>0.07</td>
</tr>
<tr>
<td>R</td>
<td>6.81</td>
<td>V</td>
<td>1.27</td>
<td>K</td>
<td>0.00</td>
</tr>
<tr>
<td>U</td>
<td>6.05</td>
<td>G</td>
<td>1.10</td>
<td>W</td>
<td>0.00</td>
</tr>
<tr>
<td>L</td>
<td>5.89</td>
<td>F</td>
<td>1.06</td>
</tr>
</tbody>
</table>
<div class="quote relative py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-emerald-500 bg-emerald-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-emerald-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
  <path stroke-linecap="round" stroke-linejoin="round" d="M13.19 8.688a4.5 4.5 0 011.242 7.244l-4.5 4.5a4.5 4.5 0 01-6.364-6.364l1.757-1.757m13.35-.622l1.757-1.757a4.5 4.5 0 00-6.364-6.364l-4.5 4.5a4.5 4.5 0 001.242 7.244"></path>
</svg>
<div class="pl-8 mr-8">
<p><a href="https://fr.wikipedia.org/wiki/Fr%C3%A9quence_d%27apparition_des_lettres">https://fr.wikipedia.org/wiki/Fréquence_d'apparition_des_lettres</a></p>
</div>
</div>
<p>La lettre arrivant le plus souvent dans le message chiffré, <code>r</code> a donc toute les chances d'être <code>e</code> ce qui donne le décalage.</p>
<h2>Vigenère</h2>
<h3><span id="Vigenère-chiffre"></span>Chiffrement</h3>
<p>Remplace la clé unique par un tableau de clés $k =[k_0,\dots, k_{p-1}]$</p>
<p>Le chiffrement de $m = m_0 \dots m_L$ en $c = c_0 \dots c_L$ de fait avec l'équation :</p>
<div>
$$
\left\{
  \begin{array}{lll}
    E(k, m_i) &=& m_i + k_{(i \mod p)} \mod 26\\
    D(k, c_i) &=& c_i - k_{(i \mod p)} \mod 26\\
  \end{array}
\right.
$$
</div>
<p>Le code de Vigenère est un exemple de <em><strong>Codage par blocs</strong></em> (<em>bloc cipher</em>) : chaque bloc de $p$ lettres est codé avec le même algorithme.</p>
<p>Par exemple, si on encode notre chaîne par <code>PROUST</code>, cela revient à encoder toute les 7 lettres par un césar commençant par <code>P</code>, toutes les 8 lettres par un césar commençant par <code>R</code>, etc... Notre texte se code alors par :</p>
<pre><code>Message : Longtemps je me suis couché de bonne heure.
Clé     : PROUSTPRO US TP ROUS TPROUS TP ROUST PROUS
Chiffre : AFBALXBGG DW FT JICK VDLQBW WT SCHFX WVILW.
</code></pre>
<h3><span id="Vigenère-analyse"></span>Chiffrement</h3>
<div class="quote relative py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-emerald-500 bg-emerald-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-emerald-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
  <path stroke-linecap="round" stroke-linejoin="round" d="M13.19 8.688a4.5 4.5 0 011.242 7.244l-4.5 4.5a4.5 4.5 0 01-6.364-6.364l1.757-1.757m13.35-.622l1.757-1.757a4.5 4.5 0 00-6.364-6.364l-4.5 4.5a4.5 4.5 0 001.242 7.244"></path>
</svg>
<div class="pl-8 mr-8">
<p><a href="https://fr.wikipedia.org/wiki/Chiffre_de_Vigen%C3%A8re">Chiffre de Vigenère</a></p>
</div>
</div>
<ol>
<li>Calcul exhaustif des clés : $26^p$, si $p \geq 30$ alors environ $2^{128}$ opérations, c'est safe.</li>
<li>si la clé est choisie de façon aléatoire, par bloc cela semble sécurisé, chaque lettre peut équiprobablement être choisie. Mais :
<ol>
<li>si on a la taille on refait de l'analyse par fréquence</li>
<li><a href="https://www.bibmath.net/crypto/index.php?action=affiche&amp;quoi=poly/viganalyse">on peut trouver la taille</a></li>
</ol>
</li>
</ol>
<p>Pour retrouver la taille de la clé, on utilise <a href="https://fr.wikipedia.org/wiki/Indice_de_co%C3%AFncidence">l'indice de coïncidence mutuelle</a>, développé par Friedman dans les années 1920, qui calcule pour une langue donnée la probabilité que deux lettres choisie aléatoirement dans un texte soient égales.</p>
<p>Soit $T = c_1\dots c_n$ un texte de longueur $n&gt;&gt;1$ formé des 26 lettres de l'alphabet $\mathcal{A} = \{a_1, \dots,. a_{26}\}$. On suppose que la lettre $a_i$ apparaît $n_i$ fois dans $T$ ($\sum_i n_i = n$). On note :</p>
<div>
$$
\text{IC}(T) = \sum_{1\leq i \leq 26}\frac{n_i(n_i-1)}{n(n-1)}
$$
</div>
<p>L'indice de coïncidence de $T$. Il correspond à la probabilité de prendre deux lettres au hasard dans le texte et qu'elles soient égales. En effet, cela revient à considérer un tirage de 2 boules parmi $n$ de 26 couleurs différentes. La probabilité que les deux boules tirées soient de la couleur de $a_i$ est $C_2^{n_i}/C_2^{n} = \frac{n_i(n_i-1)}{n(n-1)}$.</p>
<p>Friedman a remarqué que ce nombre dépend de la langue choisie. En Français c'est de l'ordre 0.074.</p>
<p>Pour un codage de Vigenère, le même chiffrement est utilisé tout les $m$ caractères où $m$ est la taille de la clé, on devrait donc retrouver l'IC Français tous les 6 caractères de notre texte chiffré. En les classant par ordre croissant, de 1 à 10 on a :</p>
<ul>
<li>IC = 0.033333 décalage = 10</li>
<li>IC = 0.038095 décalage = 5</li>
<li>IC = 0.042857 décalage = 7</li>
<li>IC = 0.044118 décalage = 2</li>
<li>IC = 0.045378 décalage = 1</li>
<li>IC = 0.054167 décalage = 8</li>
<li>IC = 0.055556 décalage = 9</li>
<li>IC = 0.057576 décalage = 3</li>
<li>IC = 0.062500 décalage = 4</li>
<li>IC = 0.072222 décalage = 6</li>
</ul>
<p>C'est bien pour un décalage de 6 que l'IC est le plus proche d'un texte Français. Une fois la longueur de clé trouvée, on continue comme un César, le caractère le plus fréquent est le <code>E</code>.</p>
<p>En prenant les fréquences les plus élevées :</p>
<ul>
<li>toutes les 6 lettres à partir de la 1ere position  : <code>'T'</code> 0.33% : clé <code>P</code>. Ok !</li>
<li>toutes les 6 lettres à partir de la 2nde position  : <code>'V'</code>, <code>'S'</code>, <code>'L'</code>, <code>'J'</code> à 0.16.  Ko !</li>
<li>toutes les 6 lettres à partir de la 3eme position  : <code>'I'</code> 0.33 : clé <code>E</code>.  Ko !</li>
<li>toutes les 6 lettres à partir de la 4eme position  : <code>'L'</code>, <code>'H'</code>, <code>'D'</code> 0.16.  Ko !</li>
<li>toutes les 6 lettres à partir de la 5eme position  : <code>'W'</code> 0.5: clé <code>S</code>. Ok !</li>
<li>toutes les 6 lettres à partir de la 6eme position  : <code>'X'</code> 0.33 : clé <code>T</code>. Ok !</li>
</ul>
<p>On trouve une clé potentielle de <code>PVELST</code> :</p>
<pre><code>Message : Longtemps je me suis couché de bonne heure.
Décrypte  LKXPTEMLC SE ME OERS COQMQE DE XYWNE HAEAE
</code></pre>
<p>Il suffit ensuite d'affiner avec les mots reconnus ou de poursuivre les investigations sur les bouts de clés où les pourcentages sont trop proches. On trouve cependant la moitié des clés pour un texte devenu très petit. Plus le texte à chiffré est grand par rapport à la clé plus cette méthode devient efficace.</p>
<div class="quote relative py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-emerald-500 bg-emerald-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-emerald-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
  <path stroke-linecap="round" stroke-linejoin="round" d="M13.19 8.688a4.5 4.5 0 011.242 7.244l-4.5 4.5a4.5 4.5 0 01-6.364-6.364l1.757-1.757m13.35-.622l1.757-1.757a4.5 4.5 0 00-6.364-6.364l-4.5 4.5a4.5 4.5 0 001.242 7.244"></path>
</svg>
<div class="pl-8 mr-8">
<p><a href="https://www.youtube.com/watch?v=yHXOnCKh4iE">Décrypter Vigenère</a></p>
</div>
</div>
<h3>One time Pad (OTP)</h3>
<p>L'idée est de faire un Vigenère avec comme taille de clé le message !</p>
<p>C'est la technique du :</p>
<div class="quote relative py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-emerald-500 bg-emerald-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-emerald-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
  <path stroke-linecap="round" stroke-linejoin="round" d="M13.19 8.688a4.5 4.5 0 011.242 7.244l-4.5 4.5a4.5 4.5 0 01-6.364-6.364l1.757-1.757m13.35-.622l1.757-1.757a4.5 4.5 0 00-6.364-6.364l-4.5 4.5a4.5 4.5 0 001.242 7.244"></path>
</svg>
<div class="pl-8 mr-8">
<p><a href="https://fr.wikipedia.org/wiki/Masque_jetable">masque jetable</a>, <em>One Time Pad</em>.</p>
</div>
</div>
<p>Technique utilisée pour le téléphone rouge lors de la guerre froide.</p>
<div class="quote relative  py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-cyan-500 bg-cyan-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-cyan-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z"></path>
</svg>
<div class="pl-8 mr-8">
<p><a href="https://www.bibmath.net/crypto/index.php?action=affiche&amp;quoi=moderne/che">Chiffre du Che</a></p>
</div>
</div>
<p>Ce qui donne :</p>
<pre><code>Longtemps je me suis couche de bonne heure.
ALarecher ch ed utem psperd ud eMarc elPro
LZNXXGTTJ LL QH MNME RGJGYH XH FANEG LPJIS
</code></pre>
<p>Ce code est réputé (on va le prouver) inviolable. S'il n'est pas réutilisé.</p>
<h2>Chiffre Vernam</h2>
<p>La version informatisée du OTP est appelée <a href="https://www.cryptage.org/vernam.html">chiffre de Vernam</a>.</p>
<p>Ici les messages, les chiffres et les clés sont des mots de $\{0, 1\}^L$ et on a, avec $\oplus$ le ou exclusif binaire :</p>
<div>
$$
\left\{
  \begin{array}{lll}
    E(k, m) &=& k \oplus m\\
    D(k, c) &=& E(k, c) = k \oplus c\\
  \end{array}
\right.
$$
</div>
<p>On a bien $m = k \oplus c$ puisque $k \oplus k \oplus m = m$.</p>
<pre class="language-shell " style="counter-reset: linenumber 0"><code class="language-shell">❯ <span class="token builtin class-name">echo</span> <span class="token parameter variable">-n</span> <span class="token string">"fascina"</span> <span class="token operator">|</span> xxd <span class="token parameter variable">-ps</span>
66617363696e61
❯ <span class="token builtin class-name">echo</span> <span class="token parameter variable">-n</span> <span class="token string">"message"</span> <span class="token operator">|</span> xxd <span class="token parameter variable">-ps</span>
6d657373616765
❯ <span class="token builtin class-name">printf</span> <span class="token string">"0x%x<span class="token entity" title="\n">\n</span>"</span> <span class="token variable"><span class="token variable">$((</span><span class="token number">0xb040010080904</span> <span class="token operator">^</span> <span class="token number">0x66617363696e61</span><span class="token variable">))</span></span>
0x6d657373616765
❯ <span class="token builtin class-name">echo</span> 0x6d657373616765 <span class="token operator">|</span> xxd <span class="token parameter variable">-r</span> <span class="token punctuation">;</span> <span class="token builtin class-name">echo</span>
message
❯ 
</code></pre>
<p>Intuitivement, comme $k$ peut être ce que l'on veut, $k \oplus m$ l'est aussi. En particulier pour tous $m$ et $c$ on peut trouver $k$ tel que $c = k \oplus m$ (il suffit de prendre $k = c \oplus m$).</p>
<p>En conséquence, un attaquant devant un message crypté de peut le décrypter s'il ne connaît pas $k$ puisque $m$ pouvant être tout élément de $\{0, 1\}^L$</p>
<p>Formalisons cette intuition.</p>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
</svg>
<div class="pl-8  mb-2 mr-8">
<p><strong>Théorème</strong></p>
</div><div class="pl-8 mr-8">
<p>Si $X$ et $Y$ deux variables aléatoires indépendantes sur $M = \{0, 1\}$ et telle que $X$ soit uniforme.</p>
<p>Alors la variable aléatoire $X \oplus Y$ est uniforme sur $\{0, 1\}^L$</p>
</div>
</div>
<div class="relative drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-indigo-500 bg-indigo-100">
<details class="group" open="">
<summary class="list-none py-0.5">
<svg class="group-open:hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M9 5l7 7-7 7"></path>
</svg>
<svg class="group-open:block hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7"></path>
</svg>
<div class="pl-8 font-bold inline-block">
<p>preuve</p>
</div>
<svg class="group-open:hidden inline-block pl-3 w-10 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M5 12h.01M12 12h.01M19 12h.01M6 12a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0z"></path>
</svg>
</summary>
<div class="mx-8 pb-2">
<p>Plaçons nous à un index $i$ fixé. On a :</p>
<ul>
<li>$Pr[X_i = 0] = Pr[X_i = 1] = .5$ car la variable aléatoire $X$ est uniforme et il y a exactement la moitié de M dont le $i$ème indice vaut 0 (pour l'autre moitié cet indice vaut 1).</li>
<li>$Pr[Y_i = 0] = p_i$ et donc $Pr(Y_i = 1) = 1-p_i$</li>
</ul>
<p>Comme $(X \oplus Y)_i$ vaut 0 que si $X_i$ et $Y_i$ valent conjointement 0 ou 1, on en déduit que :</p>
<p>$$<br>
Pr[(X \oplus Y)_i = 0] = Pr[X_i = 0, Y_i = 0] + Pr[X_i = 1, Y_i = 1]<br>
$$</p>
<p>Comme $X$ et $Y$ sont indépendants, $X_i$ et $Y_i$ le sont également et on a : $Pr[X_i = a, Y_i = b] = Pr[X_i = a]\cdot Pr[Y_i = b]$. Donc :</p>
<ul>
<li>$Pr[X_i = 0, Y_i = 0] = Pr[X_i = 0]\cdot Pr[Y_i = 0] = .5\cdot p_i$</li>
<li>$Pr[X_i = 1, Y_i = 1] = Pr[X_i = 1]\cdot Pr[Y_i = 1] = .5\cdot (1-p_i)$</li>
</ul>
<p>Ce qui entraîne que $Pr[(X \oplus Y)_i = 0] = Pr[X_i = 0, Y_i = 0] + Pr[X_i = 1, Y_i = 1] = .5$, et donc que $(X \oplus Y)$ est une variable aléatoire uniforme.</p>
</div>
</details>     
</div>
<p>On déduit du résultat précédent que si la clé est une variable aléatoire uniforme indépendante du texte à chiffré, le chiffre $c$ ne donne aucune information sur $m$. Ce résultat est remarquable car il ne présuppose rien sur le message $m$ et prouve bien l'inviolabilité du code de Vernam.</p>
<p>Enfin, un chiffre $c$ peut être issu de n'importe quel message original $m$, il suffit de choisir $k = c\oplus m$.</p>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
</svg>
<div class="pl-8 mr-8">
<p>Ceci pose les bases que tout code doit avoir une clé choisie uniformément et indépendante du message.</p>
</div>
</div>
<p>Attention cependant.</p>
<h3>Ne répétez pas la clé</h3>
<p>La code de Vernam est inviolable si on ne possède aucune information supplémentaire. Si on chiffre deux messages différents avec la même clé $k \oplus m$ et $k \oplus m'$, Eve na qu'à combiner les deux messages chiffrées pour faire disparaître la clé : $k \oplus m \oplus k \oplus m' = k \oplus k \oplus m \oplus m' = m \oplus m'$. De là, si Eve sait que le message est en Français, il lui suffit de déplacer des mots sur le code pour voit apparaître d'autres mots :</p>
<pre><code>  Je suis très bien protégé
+ Il mangeait des escargots
  XXXXXXXXXXXXXXXXXXXXXXXXX
</code></pre>
<p>En faisant glisser &quot;suis&quot; par exemple, lorsqu'il arrive sur l'emplacement de la première ligne on obtient :</p>
<pre><code>     suis
  Je suis très bien protégé
+ Il mangeait des escargots 
  XXXmangXXXXXXXXXXXXXXXXXX
</code></pre>
<p>Ce qui nous donne :</p>
<ul>
<li>une position dans le premier mot</li>
<li>un début de mot dans la seconde phrase que l'on peut chercher à completer</li>
</ul>
<pre><code>     mangeait
  Je suis très bien protégé
+ Il mangeait des escargots 
  XXX        XXXXXXXXXXXXXX
     suis trè 
</code></pre>
<p>Et petit à petit on casse le chiffre....</p>
<div class="quote relative  py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-cyan-500 bg-cyan-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-cyan-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z"></path>
</svg>
<div class="pl-8 mr-8">
<p>C'est arrivé en vrai.<br>
<a href="https://fr.wikipedia.org/wiki/Projet_Venona">Projet Venona</a></p>
</div>
</div>
<h3><span id="Vernam-intégrité"></span>Intégrité</h3>
<p>Si le message est inviolable, il n'est pas infalsifiable.</p>
<pre><code>  Je donne 12 euros à François
+ XXXXXXXXXXXXXXXXXXXXXXXXXXXX
------------------------------
  YYYYYYYYYYYYYYYYYYYYYYYYYYYY
</code></pre>
<p>Certes. Mais je peux ajouter des informations si je le désire</p>
<pre><code>  Je donne 12 euros à François
+ XXXXXXXXXXXXXXXXXXXXXXXXXXXX
+ 00000000012 euros00000000000
------------------------------
  YYYYYYYYYXXXXXXXXYYYYYYYYYYY
</code></pre>
<pre><code>  Je donne 12 euros à François
+ XXXXXXXXXXXXXXXXXXXXXXXXXXXX
+ 00000000012 euros00000000000
+ 0000000009999999€00000000000
------------------------------
  YYYYYYYYYZZZZZZZZYYYYYYYYYYY
</code></pre>
<p>Ce qui est donne une fois déchiffré :</p>
<pre><code>  Je donne 12 euros à François
+ XXXXXXXXXXXXXXXXXXXXXXXXXXXX
+ 00000000012 euros00000000000
+ 0000000009999999€00000000000
+ XXXXXXXXXXXXXXXXXXXXXXXXXXXX
------------------------------
  Je donne 9999999€ à François
</code></pre>
<p>Ce qui est super Sympa de votre part !</p>
<p>Ça à l'air un peu tiré par les cheveux vu comme ça, mais si vous chiffrés des mails par exemple, ils commencent tous par un champ <code>FROM</code> et un champ <code>TO</code>, si le cryptanalyse sait ce que vous codez et que c'est issu d'un protocole, il y a de forte chances qu'il y ait des paramètres à emplacement fixe que l'on peut modifier.</p>
<h3>Authentification</h3>
<p>Rien ne garanti que c'est bien l'expéditeur voulu qui a envoyé le message :</p>
<pre><code>           cle k                   cle k'
Alice &lt;-------------&gt; Mallory &lt;--------------&gt; Bob

</code></pre>
<p>Si Mallory se fait passer d'un côté pour Bob et de l'autre côté pour Alice, aucun des deux ne peux le soupçonner.</p>


</article>
    </main>

    <footer class="min-h-[50px] border-t-2 border-gray-200 mt-4">
      <div class="max-w-[1200px] mx-auto px-4 relative">
        <div class="min-h-[50px] flex justify-center items-center">
          <p>
            Cours d'informatique à l'école centrale Marseille
          </p>
        </div>
        <div class="min-h-[50px] flex justify-center items-center absolute right-0 top-0">
          <button onclick="goTop()" id="myBtn" title="Go to top">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
              <path stroke-linecap="round" stroke-linejoin="round" d="M15 11.25l-3-3m0 0l-3 3m3-3v7.5M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
            </svg>
          </button>

          <button onclick="goBottom()" id="myBtn" title="Go to top">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
              <path stroke-linecap="round" stroke-linejoin="round" d="M9 12.75l3 3m0 0l3-3m-3 3v-7.5M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
            </svg>
          </button>
        </div>

      </div>
    </footer>

    <script>
      MathJax
        .startup
        .document
        .getMathItemsWithin(document.body);
    </script>

  </body>
</html>