<!DOCTYPE html>
<html lang="fr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>Couplages de poids maximum bi-parti</title>

    

    <link href="https://prismjs.catppuccin.com/latte.css" rel="stylesheet">

    <link href="/cours_informatique/assets/node_modules/prismjs/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet">
    <script src="/cours_informatique/assets/node_modules/prismjs/plugins/line-numbers/prism-line-numbers.min.js"></script>
    
    <link href="/cours_informatique/assets/stylesheets/main.css" rel="stylesheet">

  </head>
  <body>
    <script>
      window.MathJax = {
        tex: {
          inlineMath: [
            [
              '$', '$'
            ],
            [
              '\\(', '\\)'
            ]
          ]
        },
        svg: {
          fontCache: 'global'
        }
      };

      function goTop() {
        window.scrollTo({top: 0});
      }
      function goBottom() {
        window.scrollTo({top: document.body.scrollHeight});
      }
    </script>
    <script type="text/javascript" id="MathJax-script" src="/cours_informatique/assets/node_modules/mathjax/es5/tex-svg-full.js"></script>

    <header class="border-b-2 border-gray-200 mb-4">
      <div class="max-w-[1200px] mx-auto px-4 relative">
        <div class="min-h-[50px] flex justify-between items-center">
          <a class="mx-2" href="/cours_informatique/">Home</a>
        </div>

        <div class="min-h-[50px] flex justify-center items-center absolute right-0 top-0">
          <a class="mx-2" href="/cours_informatique/about">About</a>
          <button onclick="goTop()" id="myBtn" title="Go to top">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
              <path stroke-linecap="round" stroke-linejoin="round" d="M15 11.25l-3-3m0 0l-3 3m3-3v7.5M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
            </svg>
          </button>

          <button onclick="goBottom()" id="myBtn" title="Go to top">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
              <path stroke-linecap="round" stroke-linejoin="round" d="M9 12.75l3 3m0 0l3-3m-3 3v-7.5M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
            </svg>
          </button>
        </div>

      </div>
    </header>

    <main class="max-w-[1200px] mx-auto px-4">
      
<article>

  <h1>Couplages de poids maximum bi-parti</h1>
  <div>
    

    
  </div>

  

    
<div class="quote relative  py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-purple-500 bg-purple-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-purple-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M5 19a2 2 0 01-2-2V7a2 2 0 012-2h4l2 2h4a2 2 0 012 2v1M5 19h14a2 2 0 002-2v-5a2 2 0 00-2-2H9a2 2 0 00-2 2v5a2 2 0 01-2 2z"></path>
</svg>
<div class="pl-8 mr-8">

<a class="interne" href="/cours_informatique/cours/">Cours</a><span class="px-1">/</span><a class="interne" href="/cours_informatique/cours/graphes/">Théorie des graphes</a><span class="px-1">/</span><a class="interne" href="/cours_informatique/cours/graphes/couplages/">Couplages</a><span class="px-1">/</span><a class="interne" href="/cours_informatique/cours/graphes/couplages/couplage-max-bi-parti/">Couplages de poids maximum bi-parti</a>

</div></div>



    
  

  <p>Le problème que l'on veut maintenant résoudre est de trouver un couplage maximum de poids maximum dans les graphes bi-partis. Par exemple en reprenant l'exemple du transport amoureux, on peut quantifier l'amour entre les différents héros de roman et chercher, par tous les couplages maximaux ceux qui maximisent le contentement.</p>
<p>On peut alors, sans perte de généralité se restreindre à la recherche des couplage parfait de poids maximum de $K_{n,n}$ puisqu'il suffit de mettre des poids nuls pour chercher des couplages maximaux dans des graphes bi-partis nom complets.</p>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
</svg>
<div class="pl-8 mb-2 mr-8">
<p><strong>Problème du couplage biparti de poids maximum</strong></p>
</div><div class="pl-8 mr-8">
<p>Soit $K_{n,n}=(V, E)$ le graphe biparti complet valué par une fonction de préférence $p:E\to \mathbb{R}^+$.</p>
<p>On cherche un couplage parfait $M$ tel que <strong><em>le poids du couplage</em></strong> $p(M) = \sum_{xy\in M}p(xy)$ soit maximum.</p>
</div></div>

<p>Notez que l'on sait déjà résoudre ce problème par une modélisation part flot et en cherchant un flot max de coût maximum. Nous allons voir ici une autre méthode appelé primal/dual qui va se généraliser aux graphes quelconques.</p>
<h2>Dualité couverture/couplage</h2>
<p>On va généraliser ici <a href="../couplage-bi-parti/#K%C3%B6nig-Egerv%C3%A1ry" class="interne">le théorème de König-Egerváry</a> pour montrer que couverture de poids minimal va être égal à couplage de poids maximal. Cette dualité rappelle la dualité coupe minimale et flot maximum.</p>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
</svg>
<div class="pl-8 mb-2 mr-8">
<p><strong>définition</strong></p>
</div><div class="pl-8 mr-8">
<p>Une <strong><em>couverture valuée</em></strong> d'un graphe $G=(V, E)$ valué par $p$ est une fonction $c:V\to \mathbb{R}^+$ telle que : $c(x) + c(y)\geq p(xy)$ pour tout $xy \in E$.</p>
<p>Le <strong><em>coût</em></strong> d'une couverture valué est $c(V) = \sum_{x\in V}c(x)$.</p>
</div></div>

<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
</svg>
<div class="pl-8 mb-2 mr-8">
<p><strong>Proposition</strong></p>
</div><div class="pl-8 mr-8">
<p>Soit $G=(v, E)$ un graphe valué par $p$, $c$ une de ses couverture valuée et $M$ un de ses couplages. On a :</p>
<div>
$$
c(V) \geq p(M)
$$
</div>
</div></div>

<div class="relative drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-indigo-500 bg-indigo-100">
<details class="group" open="">
<summary class="list-none py-0.5">
<svg class="group-open:hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M9 5l7 7-7 7"></path>
</svg>
<svg class="group-open:block hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7"></path>
</svg>
<div class="pl-8 font-bold inline-block">
<p>preuve</p>
</div>
<svg class="group-open:hidden inline-block pl-3 w-10 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M5 12h.01M12 12h.01M19 12h.01M6 12a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0z"></path>
</svg>
</summary>
<div class="mx-8 pb-2">
<p>Pour toute arête $xy$ de $M$ on a $c(x)+c(y)\geq p(xy)$ et comme chaque sommet apparaît au plus une fois dans le couplage on a bien l'inégalité demandée.</p>
</div>
</details>     
</div>
<p>On en conclut que s'il existe une couverture valuée dont la valeur est égale au couplage alors le couplage est forcément maximum. La partie suivante montre la réciproque en donnant un algorithme permettant de trouver un couplage maximum de poids maximum.</p>
<h2>Résolution par Primal/Dual</h2>
<p>Le principe de l'algorithme que l'on va utiliser pour résoudre le problème utilise le principe de dualité entre couverture et couplage pour les graphes bipartis et implémente une méthode fondamentale en optimisation appelée primal/dual (très utilisée en programmation linéaire et qui s'applique à de nombreux autres cas, comme ici) : une solution augmente pendant que l'autre diminue, la solution étant trouvée lorsque les deux coïncident.</p>
<p>L'algorithme va petit à petit augmenter un couplage en diminuant une couverture valuée jusqu'à arriver à une valuation égale ce qui prouvera l'optimalité.</p>
<h3>Algorithme</h3>
<ul>
<li>Donnée : une valuation $p$ du graphe biparti complet $K_{n,n} =(A\cup B, E)$ (avec $A$ et $B$ ses 2 stables)</li>
<li>algorithme
<ol>
<li>on note $c$ la valuation des sommets telle que :
<ul>
<li>$c(x) = \max(\{ p(xy) \vert xy \in E \})$ si $x\in A$</li>
<li>$c(x) = 0$ si $x\in B$</li>
</ul>
</li>
<li>soit $G[c] = (A\cup B, E[c])$ le graphe tel que $xy \in E$ si et seulement si $c(x) + c(y) - p(xy) = 0$</li>
<li>Soit $M$ un couplage maximum de $G[c]$</li>
<li><strong>si</strong> $M$ couvre $A$ <strong>rendre</strong> $M$ et $c$</li>
<li>soit $C$ une couverture de taille $\vert M \vert$. On pose :
<ul>
<li>$A' = A \cap C$</li>
<li>$B' = B \cap C$</li>
<li>$\lambda = \min(\{c(x) + c(y) - p(xy) \vert x\in A\backslash A', y\in B\backslash B' \})$</li>
<li>$c(x) = c(x) -\lambda$ si $x \in A\backslash A'$</li>
<li>$c(x) = c(x)  + \lambda$ si $x \in B\backslash B'$</li>
</ul>
</li>
<li>retour à l'étape 2.</li>
</ol>
</li>
</ul>
<blockquote>
<p>TBD on utilise l'algorithme de la partie précédente pour trouver et le couplage et la couverture associée</p>
</blockquote>
<h3>Optimalité</h3>
<p>L'algorithme va forcément trouver un couplage parfait car à chaque étape $G[c]$ va avoir strictement plus d'arête :</p>
<ul>
<li>si $c(x) + c(y) - p(xy) = 0$ à une étape donné c'est vrai aussi à l'étape suivante</li>
<li>à l'étape 5. aucune arête $xy$ avec $x\in A\backslash A'$ et $y \in B\backslash B'$ n'est dans $G[c]$, ce qui implique que $\lambda &gt; 0$</li>
</ul>
<p>De plus, à la fin on a clairement que $c(A\cup B) = p(M)$ ce qui montre que le couplage est bien de poids maximum et la couverture valuée de poids minimum.</p>
<h3>Complexité</h3>
<p>Tout ce fait de façon polynomiale puisque :</p>
<ul>
<li>l'on peut trouver polynomialement un couplage de taille maximum dans un graphe bi-parti</li>
<li>l'on peut trouver polynomialement une couverture de taille minimum dans un graphe bi-parti à partir d'un de ses couplages de taille maximum</li>
</ul>
<h2>Méthode hongroise</h2>
<div class="quote relative py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-emerald-500 bg-emerald-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-emerald-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
  <path stroke-linecap="round" stroke-linejoin="round" d="M13.19 8.688a4.5 4.5 0 011.242 7.244l-4.5 4.5a4.5 4.5 0 01-6.364-6.364l1.757-1.757m13.35-.622l1.757-1.757a4.5 4.5 0 00-6.364-6.364l-4.5 4.5a4.5 4.5 0 001.242 7.244"></path>
</svg>
<div class="pl-8 mr-8">
<ul>
<li><a href="https://www.youtube.com/watch?v=fMAmtE0UyzI">Méthode hongroise</a></li>
<li><a href="https://fr.wikipedia.org/wiki/Algorithme_hongrois">Algorithme hongrois</a></li>
</ul>
</div></div>

<p>La méthode hongroise est l'application de la méthode du primal dual en utilisant des matrices de coûts, sans aucune considération de graphes. Elle se décrit plus facilement lorsque l'on cherche à minimiser le coût plutôt que de maximiser la satisfaction et c'est pourquoi nous la décrirons ainsi :</p>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
</svg>
<div class="pl-8 mb-2 mr-8">
<p><strong>Problème</strong></p>
</div><div class="pl-8 mr-8">
<p>Soit une matrice carrée $C = (c_{i, j})_{1\leq i \leq n, 1\leq i \leq m}$ de coût. On cherche à associer chaque ligne (une heroine de roman, un ouvrier, etc) à une colonne (un héros de roman, une tâche, etc) de telle sorte que la somme des coûts choisis soit minimal.</p>
</div></div>

<p>Ce problème s'écrit facilement comme la recherche d'un couplage parfait dans $K_{n, n}$ à coût minimal.</p>
<p>Si l'on cherche à maximiser des préférences rangées dans une matrice $n \times n$ $P = (p_{i, j})$, il suffit de considérer la matrice  $n \times n$ $C = (K - p_{i, j})$ avec $K = \sum_{u, v}p_{u, v}$. Comme on cherche un couplage parfait son poids sera de $n\cdot K-\sum_{i, j \in I} p_{i, j}$ ce qui correspond bien à la maximisation des préférences.</p>
<h3>Algorithme de la méthode hongroise</h3>
<div class="quote relative  py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-cyan-500 bg-cyan-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-cyan-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z"></path>
</svg>
<div class="pl-8 mr-8">
<p>On reprend ici <a href="https://graal.ens-lyon.fr/~mgallet/_static/teaching/acm/tp-acm-2008-08.pdf">l'algorithme décrit ici</a>.</p>
</div></div>

<div>
$$
\begin{array}{|c|c|c|c|c|}
\hline
17&15&9&5&12\\
\hline
16&16&10&5&10\\
\hline
12&15&14&11&5\\
\hline
4&8&14&17&13\\
\hline
13&9&8&12&17\\
\hline
\end{array}
$$
</div>
<h4>0. Créations de zéros</h4>
<ol>
<li>pour chaque ligne de $C$, prendre le plus petit élément et le soustraire à l’ensemble de la ligne.</li>
<li>pour chaque colonne de $C$, prendre le plus petit élément et le soustraire à l’ensemble de la colonne.</li>
</ol>
<div class="quote relative  py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-cyan-500 bg-cyan-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-cyan-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z"></path>
</svg>
<div class="pl-8 mr-8">
<p>On est maintenant assuré d'avoir au moins un 0 par ligne et par colonne.</p>
</div></div>

<p>Cette étape se réalise en $\mathcal{O}(n^2)$ opérations.</p>
<p>Après l'étape sur les lignes :</p>
<div>
$$
\begin{array}{|c|c|c|c|c|}
\hline
12&10&4&0&7\\
\hline
11&11&5&0&5\\
\hline
7&10&9&6&0\\
\hline
0&4&10&13&9\\
\hline
5&1&0&4&9\\
\hline
\end{array}
$$
</div>
<p>Puis après l'étape sur les colonnes :</p>
<div>
$$
\begin{array}{|c|c|c|c|c|}
\hline
12&9&4&0&7\\
\hline
11&10&5&0&5\\
\hline
7&9&9&6&0\\
\hline
0&3&10&13&9\\
\hline
5&0&0&4&9\\
\hline
\end{array}
$$
</div>
<h4>1. Encadrer des zéros</h4>
<p>On utilise la marque <strong><em>encadrer</em></strong> pour des 0 de la matrice.</p>
<pre class="language-text" tabindex="0" data-language="text"><code class="language-text">pour chaque 0 de la matrice:
   si aucun 0 de sa ligne et de sa colonne ne sont encadrés:
         encadrer le 0</code></pre>
<div class="quote relative  py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-cyan-500 bg-cyan-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-cyan-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z"></path>
</svg>
<div class="pl-8 mr-8">
<p>À la fin de cette itération :</p>
<ul>
<li>on ne peut encadrer qu'au maximum un 0 par ligne et par colonne,.</li>
<li>Ssi on a encadré $n$ zéros, on a terminé et on a un couplage maximum de coût minimum en liant ligne et colonne de chaque 0 encadré.</li>
</ul>
</div></div>

<p>Cette étape se réalise facilement en $\mathcal{O}(n^2)$ opérations en conservant deux tableaux de booléens $T_L$ et $T_C$ de taille $n+1$ tel que $T_L[i] = \text{Vrai}$ (<em>resp.</em> $T_C[i] = \text{Vrai}$) si et seulement si on a encadré un 0 à cette ligne (<em>resp.</em> cette colonne).</p>
<div>
$$
\begin{array}{|c|c|c|c|c|}
\hline
12&9&4&\cellcolor{gray}0&7\\
\hline
11&10&5&\cancel{0}&5\\
\hline
7&9&9&6&\cellcolor{gray}0\\
\hline
\cellcolor{gray}0&3&10&13&9\\
\hline
5&\cellcolor{gray}0&\cancel{0}&4&9\\
\hline
\end{array}
$$
</div>
<p>Attention, on est pas obligé d'être optimal l'étape de reselection est importante car il n'est pas du tout évident d'avoir sélectionné les bon 0. On peut très bien choisir les zéros suivant :</p>
<div>
$$
\begin{array}{|c|c|c|}
\hline
\cellcolor{gray}0&a&\cancel{0}\\
\hline
b&0&\cellcolor{gray}0\\
\hline
\cancel{0}&c&\cancel{0}\\
\hline
\hline
\end{array}
$$
</div>
<p>Alors qu'il existe la solution optimale suivante :</p>
<div>
$$
\begin{array}{|c|c|c|}
\hline
\cellcolor{gray}0&a&\cancel{0}\\
\hline
b&\cellcolor{gray}0&\cancel{0}\\
\hline
\cancel{0}&c&\cellcolor{gray}0\\
\hline
\hline
\end{array}
$$
</div>
<h4>2. Marquer des lignes et des colonnes et des 0</h4>
<p>On va utiliser une nouvelle marque <strong><em>sélectionner</em></strong> que l'on va pouvoir appliquer aux :</p>
<ul>
<li>les lignes et colonnes de la matrice</li>
<li>aux 0 non encadrés</li>
</ul>
<p>Un 0 sera dit <strong><em>couvert</em></strong> s'il se trouve dans une ligne ou une colonne marquée.</p>
<ol>
<li><strong><em>sélectionner</em></strong> toutes les colonnes contenant un 0 encadré</li>
<li>tant qu'il existe un 0 non couvert avec un 0 encadré sur sa ligne:
<ol>
<li>en <strong><em>sélectionner</em></strong> un</li>
<li><strong><em>sélectionner</em></strong> sa ligne</li>
<li><strong><em>désélectionner</em></strong> la colonne de son 0 encadré</li>
</ol>
</li>
</ol>
<p>Cette étape se réalise également en $\mathcal{O}(n^2)$ opérations en utilisant la même astuce que tout à l'heure (conserver un tableau de booléen stockant les lignes et colonnes possédant un 0 encadré)</p>
<div>
$$
\begin{array}{|c|c|c|c|c|r}
X&&&X&X&\\
\hline
12&9&4&\cellcolor{gray}0&7&\\
\hline
11&10&5&0&5&\\
\hline
7&9&9&6&\cellcolor{gray}0\\
\hline
\cellcolor{gray}0&3&10&13&9\\
\hline
5&\cellcolor{gray}0&\cellcolor{green}0&4&9&X\\
\hline
\end{array}
$$
</div>
<h4>3. Ajustement des 0 encadrés si nécessaire</h4>
<p>On utilise cette étape s'il existe un 0 non couvert sans 0 encadré sur sa ligne. Ceci signifie que l'on a pas sélectionné le nombre maximum de 0 : notre couplage n'est pas maximum.</p>
<p>Construire une suite de 0 en alternants zéros sélectionnés et zéros encadrés de la manière suivante :</p>
<ol>
<li>soit $z_0$ un 0 non couvert sans encadré sur sa ligne</li>
<li>le <strong><em>sélectionner</em></strong></li>
<li>$i = 1$</li>
<li>s'il existe un zéro encadré sur la colonne de $z_{i-1}$ :
<ol>
<li>on le note $z_{i}$.</li>
<li>on note $z_{i+1}$ un zéro sélectionné sur sa ligne</li>
</ol>
</li>
<li>$i = i + 2$ et retour à l'item 3 de cette liste</li>
</ol>
<p>A la fin de cette étape on a une suite finissant par un zéro sélectionné sans zéro encadré sur sa colonne. On peut alors :</p>
<ol>
<li>dés-encadrez tous les 0 de cette liste,</li>
<li>désélectionnez tous les 0 de cette liste et encadrez les,</li>
<li>désélectionner toutes les lignes et les colonnes de la matrice,</li>
<li>retourner à l'étape 3 de marquage des lignes et des colonnes.</li>
</ol>
<p>Cette étape se réalise aussi $\mathcal{O}(n^2)$ opérations en conservant, comme toujours nos tableaux auxiliaires $T_C$ et $T_L$.</p>
<div>
$$
\begin{array}{lcccr}
\begin{array}{|c|c|c|r}
&&\\
\hline
\cellcolor{gray}0&a&\cellcolor{green}{0}&X\\
\hline
b&\cellcolor{green}0&\cellcolor{gray}0&X\\
\hline
{0}&c&{0}\\
\hline
\hline
\end{array}&
\rightarrow&
\begin{array}{|c|c|c|r}
&&\\
\hline
\cellcolor{gray}{z_1}&a&\cellcolor{green}{z_2}&X\\
\hline
b&\cellcolor{green}z_4&\cellcolor{gray}{z_3}&X\\
\hline
\cellcolor{green}{z_0}&c&{0}\\
\hline
\hline
\end{array}\rightarrow&
\begin{array}{|c|c|c|r}
&&\\
\hline
{0}&a&\cellcolor{gray}{0}&\\
\hline
b&\cellcolor{gray}0&{0}&\\
\hline
\cellcolor{gray}{0}&c&{0}\\
\hline
\hline
\end{array}
\\
\end{array}
$$
</div>
<h4>4. Mise à jour</h4>
<p>Une fois arrivé là, tous les 0 sont couvert : on a un couplage maximum.</p>
<p>On sépare les cases de la matrices en 3 :</p>
<ul>
<li>2B : les cases qui sont sur une ligne <strong>et</strong> sur une colonne marquée</li>
<li>1B : les cases qui sont sur une ligne marquée <strong>ou exclusivement</strong> sur une colonne marquée</li>
<li>0B : les cases qui sont sur une ligne <strong>et</strong> sur une colonne non marquée</li>
</ul>
<p>Soit $\lambda &gt;0 $ la plus petite valeur de des cases 0B.</p>
<ol>
<li>On supprime cette valeur de toutes les cases 0B</li>
<li>On ajoute cette valeur de toutes les cases 2B</li>
</ol>
<div class="quote relative  py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-cyan-500 bg-cyan-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-cyan-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z"></path>
</svg>
<div class="pl-8 mr-8">
<p>À la fin de cette étape, la nouvelle matrice on a strictement plus de 0 que la précédente.</p>
</div></div>

<p>Cette étape est aussi clairement en $\mathcal{O}(n^2)$ opérations.</p>
<div>
$$
\begin{array}{|c|c|c|c|c|}
\hline
8&5&0&0&3\\
\hline
7&6&1&0&1\\
\hline
7&9&9&10&0\\
\hline
0&3&10&17&9\\
\hline
5&0&0&8&9\\
\hline
\end{array}
$$
</div>
<h4>5. retour</h4>
<p>On supprime toutes les marques (de cases, de lignes et de colonnes) et on recommence à l'étape 1 avec la nouvelle matrice</p>
<p>Dans notre exemple, la prochaine étape 2 va s'arrêter sur :</p>
<div>
$$
\begin{array}{|c|c|c|c|c|}
\hline
8&5&\cellcolor{gray}0&0&3\\
\hline
7&6&1&\cellcolor{gray}0&1\\
\hline
7&9&9&10&\cellcolor{gray}0\\
\hline
\cellcolor{gray}0&3&10&17&9\\
\hline
5&\cellcolor{gray}0&0&8&9\\
\hline
\end{array}
$$
</div>
<p>Ce qui va donner le couplage parfait à coût minimum suivant sur la matrice originelle :</p>
<div>
$$
\begin{array}{|c|c|c|c|c|}
\hline
17&15&\cellcolor{gray}9&5&12\\
\hline
16&16&10&\cellcolor{gray}5&10\\
\hline
12&15&14&11&\cellcolor{gray}5\\
\hline
\cellcolor{gray}4&8&14&17&13\\
\hline
13&\cellcolor{gray}9&8&12&17\\
\hline
\end{array}
$$
</div>
<h3>Complexité totale de la méthode hongroise</h3>
<p>Chaque étape se fait en $\mathcal{O}(n^2)$ opérations  et il faut au pire les répéter $\mathcal{O}(n^2)$ fois (jusqu'à ce qu'il n'y ait plus que des 0). La complexité totale est donc en $\mathcal{O}(n^4)$, qui est quadratique par rapport à la taille des données (une matrice $n\times n$).</p>
<blockquote>
<p>TBD comparer la complexité avec l'algorithme de Busacker-Gowen appliqué au couplage.
complexité identique. O(mn) = O(n^3) pour une augmentation et n itérations qui est une majoration de coupe.</p>
</blockquote>


</article>
    </main>

    <footer class="min-h-[50px] border-t-2 border-gray-200 mt-4">
      <div class="max-w-[1200px] mx-auto px-4 relative">
        <div class="min-h-[50px] flex justify-center items-center">
          <p>
            Cours d'informatique de François Brucker
          </p>
        </div>
        <div class="min-h-[50px] flex justify-center items-center absolute right-0 top-0">
          <button onclick="goTop()" id="myBtn" title="Go to top">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
              <path stroke-linecap="round" stroke-linejoin="round" d="M15 11.25l-3-3m0 0l-3 3m3-3v7.5M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
            </svg>
          </button>

          <button onclick="goBottom()" id="myBtn" title="Go to top">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
              <path stroke-linecap="round" stroke-linejoin="round" d="M9 12.75l3 3m0 0l3-3m-3 3v-7.5M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
            </svg>
          </button>
        </div>

      </div>
    </footer>

    <script>
      MathJax
        .startup
        .document
        .getMathItemsWithin(document.body);
    </script>

  </body>
</html>