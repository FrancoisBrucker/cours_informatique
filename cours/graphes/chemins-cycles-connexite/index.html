<!DOCTYPE html>
<html lang="fr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1"/>

    <title>Chemins, cycles et connexité</title>

    <link href=/cours_informatique/assets/node_modules/prismjs/themes/prism-solarizedlight.min.css rel="stylesheet">
    <link href=/cours_informatique/assets/node_modules/prismjs/plugins/line-numbers/prism-line-numbers.min.css rel="stylesheet">

    <link href=/cours_informatique/assets/stylesheets/main.css rel="stylesheet">

  </head>
  <body>
    <script>
      window.MathJax = {
        tex: {
          inlineMath: [
            [
              '$', '$'
            ],
            [
              '\\(', '\\)'
            ]
          ]
        },
        svg: {
          fontCache: 'global'
        }
      };
    </script>
    <script type="text/javascript" id="MathJax-script" 
  src=/cours_informatique/assets/node_modules/mathjax/es5/tex-svg-full.js></script>

    <header class="border-b-2 border-gray-200 mb-4">
      <div class="max-w-[1000px] mx-auto px-4">
        <div class="min-h-[50px] flex justify-between items-center">
          <a class="mx-2" href="/cours_informatique/">Home</a>
          <a class="mx-2" href="/cours_informatique/about">About</a>
        </div>
      </div>
    </header>

    <main class="max-w-[1000px] mx-auto px-4">
      
<article>

  <h1  class="mb-1">Chemins, cycles et connexité</h1>
  <div class="mb-4">
    

    
      <div class=" px-4 flex items-center">
        
          <div class="font-bold">Auteur : </div>
        
        <ul class="flex not-prose list-none my-0 last:after:content-['•'] last:after:px-1 mx-0 px-1">
          
            <li class="before:content-['•'] before:px-1">François Brucker</li>
          
        </ul>
      </div>
    
  </div>

  
    
<div class="quote relative  py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-purple-500 bg-purple-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-purple-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M5 19a2 2 0 01-2-2V7a2 2 0 012-2h4l2 2h4a2 2 0 012 2v1M5 19h14a2 2 0 002-2v-5a2 2 0 00-2-2H9a2 2 0 00-2 2v5a2 2 0 01-2 2z" />
</svg>
<div class="pl-8 mr-8">

<a href="/cours_informatique/cours/">Cours</a><span class="px-1">/</span><a href="/cours_informatique/cours/graphes/">Graphes</a><span class="px-1">/</span><a href="/cours_informatique/cours/graphes/chemins-cycles-connexite/">Chemins, cycles et connexité</a>

</div></div>

  

  <!-- début résumé -->
<p>Chemins, cycle et connexité dans les graphes : définitions et premières propriétés.</p>
<!-- fin résumé -->
<p>Un graphe $G=(V, E)$ rend compte d'une <em>relation</em> (les arêtes) entre des objets (les sommets). Une grande part des applications des graphes viennent du fait que l'on cherche à décrire ou parcourir objets en suivant localement les relations. Cette curte partie vise à poser les diverses définitions relatives à ces notions et à exhiber quelques propriétés soit utiles, soit belles à démontrer, soit les deux.</p>
<h2>Chemin, cycles et circuits</h2>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
</svg>
<div class="pl-8  mb-2 mr-8">
<p><strong>Définition :</strong></p>
</div><div class="pl-8 mr-8">
<p>Soit $G = (V, E)$ un (multi-)graphe (non) orienté. Un <strong>chemin allant de $v_0$ à $v_{k-1}$</strong> est une suite finie :</p>
<p>$$C = v_0v_1\dots v_i \dots v_{k-1}$$</p>
<p>de sommets du graphe telle que :</p>
<ol>
<li>$v_iv_{i+1}$ soit une arête (<em>resp.</em> arc) du graphe quelque soit $0 \leq i &lt; k-1$</li>
<li>les arcs (<em>resp.</em> arêtes) sont deux à deux distinctes.</li>
</ol>
<p>Le chemin $C$ à une <strong>longueur</strong> de $k$ (c'est le nombre d'arêtes). Un chemin de longueur $0$ est le chemin conteant un unique sommet, sans arc (<em>resp.</em> arête).</p>
</div></div>
<p>On peut affaiblir la notion de chemin pour les graphes orienté :</p>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
</svg>
<div class="pl-8  mb-2 mr-8">
<p><strong>Définition :</strong></p>
</div><div class="pl-8 mr-8">
<p>Soit $G = (V, E)$ un (multi-)graphe orienté. Une <strong>chaîne</strong> est une suite :</p>
<p>$$C = v_0v_1\dots v_i \dots v_{k-1}$$</p>
<p>de sommets du graphe telle que :</p>
<ol>
<li>soit $v_iv_{i+1}$ soit $v_{i+1}v_i$ est un arc du graphe pour tout $0 \leq i &lt; k-1$</li>
<li>les arcs sont deux à deux distincts.</li>
</ol>
<p>La chaîne $C$ à une <strong>longueur</strong> de $k$ (c'est le nombre d'arcs).</p>
</div></div>
<p>Un chemin nous permet de définir un cycle pour les graphes non-orientés :</p>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
</svg>
<div class="pl-8  mb-2 mr-8">
<p><strong>Définition :</strong></p>
</div><div class="pl-8 mr-8">
<p>Soit $G = (V, E)$ un (multi-)graphe non orienté. Un <strong>cycle</strong> est un chemin</p>
<p>$$C = v_0v_1\dots v_i \dots v_k$$</p>
<p>tel que $v_0 = v_k$</p>
<p>La cycle $C$ à une <strong>longueur</strong> de $k$ (c'est le nombre d'arêtes).</p>
</div></div>
<p>Pour les graphes orientés, ça se complique un peu car on a coutume de différentier cycle (le sens de l'arc est indifférent) de circuit (on peut parcourir le cycle dans l'ordre) :</p>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
</svg>
<div class="pl-8  mb-2 mr-8">
<p><strong>Définition :</strong></p>
</div><div class="pl-8 mr-8">
<p>Soit $G = (V, E)$ un (multi-)graphe orienté. Un <strong>cycle</strong>  est une suite finie :</p>
<p>$$C = v_0v_1\dots v_i \dots v_k$$</p>
<p>de sommets du graphe telle que :</p>
<ol>
<li>soit $v_iv_{i+1}$ soit $v_{i+1}v_i$ est un arc du graphe quelque soit $0 \leq i &lt; k$</li>
<li>les arcs sont deux à deux distinctes.</li>
<li>$v_0 = v_k$</li>
</ol>
</div></div>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
</svg>
<div class="pl-8  mb-2 mr-8">
<p><strong>Définition :</strong></p>
</div><div class="pl-8 mr-8">
<p>Soit $G = (V, E)$ un (multi-)graphe orienté. Un <strong>circuit</strong> est un cycle :</p>
<p>$$C = v_0v_1\dots v_i \dots v_k$$</p>
<p>de sommets du graphe telle que $v_iv_{i+1}$ est un arc du graphe quelque soit $0 \leq i &lt; k$</p>
</div></div>
<h3>Chemins et cycles élémentaires</h3>
<p>Les définitions de chemins et cycles supposent que les arêtes ou arcs n'apparaissent pas deux fois. Si cette précaution permet d'éviter les chemin de taille infini, certains problèmes nécessitent de pouvoir passer plusieurs fois par les mêmes arêtes ou au contraire de ne passer qu'une seule fois par chaque sommet :</p>
<p><span id="pseudo-"></span></p>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
</svg>
<div class="pl-8  mb-2 mr-8">
<p><strong>Définition</strong></p>
</div><div class="pl-8 mr-8">
<p>Soit $G = (V, E)$ un graphe orienté. Un <strong>pseudo-chemin</strong> est une suite finie $C = v_0v_1\dots v_i \dots v_{k-1}$ une suite de sommets du graphe telle que $v_iv_{i+1}$ est un arc du graphe quelque soit $0 \leq i &lt; k-1$.</p>
</div></div>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
</svg>
<div class="pl-8  mb-2 mr-8">
<p><strong>Définition</strong></p>
</div><div class="pl-8 mr-8">
<p>Soit $G = (V, E)$ un graphe orienté. Un <strong>chemin élémentaire</strong> (<em>resp.</em> cycle ou circuit élémentaire) est un chemin (<em>resp.</em> cycle ou circuit) $C = v_0v_1\dots v_i \dots v_{k-1}$ tel que $v_i \neq v_j$ quelque soit $i \neq j.</p>
</div></div>
<div class="quote relative  py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-cyan-500 bg-cyan-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-cyan-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z" />
</svg>
<div class="pl-8 mr-8">
<p>Notez qu'un pseudo-chemin/pseudo-cycle/pseudo-circuit où chaque sommet n'apparaît qu'une seule fois est forcément un chemin/cycle/circuit élémentaire !</p>
</div></div>
<p>Ces notions sont bien sûr liées comme le montre les deux propositions ci-dessous :</p>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
</svg>
<div class="pl-8  mb-2 mr-8">
<p><strong>Proposition</strong></p>
</div><div class="pl-8 mr-8">
<ul>
<li>De tout pseudo-chemin, pseudo-chaîne, pseudo-cycle ou pseudo-circuit allant de $x$ à $y$ on peut extraire un chemin, chaîne, cycle ou circuit allant de $x$ à $y$.</li>
<li>De tout chemin, chaîne, cycle ou circuit  allant de $x$ à $y$, on peut extraire un chemin, chaîne, cycle ou circuit élémentaire  allant de $x$ à $y$.</li>
</ul>
</div></div>
<div class="relative drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-indigo-500 bg-indigo-100">
<details class="group">
<summary class="list-none py-0.5">
<svg class="group-open:hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M9 5l7 7-7 7" />
</svg>
<svg class="group-open:block hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7" />
</svg>
<div class="pl-8 font-bold inline-block">
<p>Preuve</p>
</div>
<svg class="group-open:hidden inline-block pl-3 w-10 text-indigo-500" xmlns="http://www.w3.org/2000/svg"  fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M5 12h.01M12 12h.01M19 12h.01M6 12a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0z" />
</svg>
</summary>
<div class="mx-8 pb-2">
<p>Nous n'allons faire la preuve que pour les chemins. Les autres preuves sont équivalentes.</p>
<p>Soit $G=(V, E)$ un graphe et $c=v_0 \dots v_p$ un de ses pseudo-chemins qui n'est pas un chemin. Il existe donc $i &lt; j$ tel que $v_iv_{i+1} = v_jv_{j+1}$ et $c'= v_0\dots v_iv_{j+1}\dots v_k$ est un autre pseudo-chemin allant de $v_0$ à $v_k$ ayant strictement moins de répétition d'arêtes que $c$ : on peut itérativement supprimer les répétitions d'arêtes d'un pseudo-chemin pour obtenir un chemin.</p>
<p>De là même manière, si $c=v_0 \dots v_p$ est un chemins non élémentaire, il existe $i &lt; j$ tel que $v_i = v_j$ : le chemin $c' = v_0 \dots v_iv_{j+1}\dots v_k$ est un autre chemin allant de $v_0$ à $v_k$ ayant strictement moins de répétition de sommets que $c$ : on peut itérativement supprimer les répétitions de sommets d'un chemin pour obtenir un chemin élémentaire.</p>
</div>
</details>     
</div>
<div class="quote relative py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-red-500 bg-red-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-red-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" />
</svg>
<div class="pl-8 mr-8">
<p>La réduction d'un pseudo-cycles (ou pseudo-circuit) peut engendrer un cycle (ou circuit) de longueur nulle ! e n'est pas le cas pour tous les autres cas.</p>
</div></div>
<h2>Connexité</h2>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
</svg>
<div class="pl-8  mb-2 mr-8">
<p><strong>Définition :</strong></p>
</div><div class="pl-8 mr-8">
<p>Un graphe est dit <strong>connexe</strong> si pour toute paire de sommets $x$ et $y$ il existe un chemin allant de $x$ à $y$ dans $G$.</p>
<p>Si le graphe est orienté :</p>
<ul>
<li>il est <strong>connexe</strong> si pour toute paire de sommets $x$ et $y$ il existe un chemin allant de $x$ à $y$ ou un chemin allant de $y$ à $x$ dans $G$.</li>
<li>il est dit <strong>fortement connexe</strong> s'il existe pour toute paire $x$ et $y$ de sommet un chemin allant de $x$ à $y$ et un chemin allant de $y$ à $x$.</li>
</ul>
</div></div>
<p>La connexité est une notion très importante en théorie des graphes. Elle permet de relier deux sommets entre eux par des relations. D'un point de vue pratique on aime bien les graphes connexes, pensez à <em>google maps</em> où l'on aime bien pouvoir faire des aller-retours.</p>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
</svg>
<div class="pl-8  mb-2 mr-8">
<p><strong>Définition :</strong></p>
</div><div class="pl-8 mr-8">
<p>Soit $G=(V, E)$ un graphe orienté ou non.</p>
<ul>
<li>Un <strong>ensemble connexe</strong> $Y \subseteq V$ de $G$ est tel que quelque soit $x \neq y \in Y$ il existe un chemin entre $x$ et $y$ ou entre $y$ et $x$.</li>
<li>Un <strong>ensemble fortement connexe</strong> $Y \subseteq V$ de $G$ est tel que quelque soit $x \neq y \in Y$ il existe un chemin entre $x$ et $y$ et entre $y$ et $x$.</li>
<li>Une <strong>composante (fortement) connexe</strong> $Y \subseteq V$ de $G$ est un ensemble (fortement) connexe maximal pour l'inclusion.</li>
</ul>
</div></div>
<p>Les composantes connexes d'un graphe $G$ forment ainsi un Souvent (toujours) si un graphe n'est pas connexe on le partitionnera en ses <strong>composantes connexes</strong> qui peuvent être vues en vertu de la proposition suivante comme des graphes distincts que l'on peut analyser séparément.</p>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
</svg>
<div class="pl-8  mb-2 mr-8">
<p><strong>Proposition :</strong></p>
</div><div class="pl-8 mr-8">
<ul>
<li>
<p>Si $G=(V, E)$ est un graphe, l'ensemble $\mathcal{C} = { V_1, \dots, V_p }$ de ses composantes connexe est une partition :</p>
</li>
<li>
<p>$V_i \cap V_j = \varnothing$ si $i \neq j$</p>
</li>
<li>
<p>quelque soit $x \in V_i$ et $y\in V_j$ avec $i \neq j$, $xy \notin E$</p>
</li>
<li>
<p>$ \sum_i V_i = V$</p>
</li>
</ul>
<p>Si le le graphe est orienté, on a le même résultat en considérant l'ensemble de des composantes fortement connexes.</p>
</div></div>
<div class="relative drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-indigo-500 bg-indigo-100">
<details class="group">
<summary class="list-none py-0.5">
<svg class="group-open:hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M9 5l7 7-7 7" />
</svg>
<svg class="group-open:block hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7" />
</svg>
<div class="pl-8 font-bold inline-block">
<p>Preuve :</p>
</div>
<svg class="group-open:hidden inline-block pl-3 w-10 text-indigo-500" xmlns="http://www.w3.org/2000/svg"  fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M5 12h.01M12 12h.01M19 12h.01M6 12a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0z" />
</svg>
</summary>
<div class="mx-8 pb-2">
<p>L'union de deux ensemble fortement connexes non disjointes est encore un ensemble fortement connexe : deux composantes fortement connexes sont forcément disjointes.</p>
</div>
</details>     
</div>
<div class="quote relative py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-red-500 bg-red-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-red-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" />
</svg>
<div class="pl-8 mr-8">
<p>Les composantes connexes d'un graphe orienté ne sont pas forcément disjointes, comme le montre l'exemple ci-après :</p>
<p><img src="./connexe_pas_fortement.png" alt="g carré g solution"></p>
</div></div>
<p>Enfin, Du point de vue de la connexité, certains sommet ou arêtes sont plus important que d'autres :</p>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
</svg>
<div class="pl-8  mb-2 mr-8">
<p><strong>Définition :</strong></p>
</div><div class="pl-8 mr-8">
<p>Soit $G$ un graphe connexe.</p>
<ul>
<li>Un <strong>isthme</strong> est une arête qui déconnecte le graphe si on la supprime</li>
<li>Un <strong>nœud d'articulation</strong> est une arête qui déconnecte le graphe si on le supprime</li>
</ul>
</div></div>
<p>Par exemple, dans des réseau routiers, les isthme et les nœuds n'articulations vont créer des bouchons s'ils sont saturés (le tunnel sous Fourvière par exemple).</p>
<h2>Propriétés fondamentales d'existence</h2>
<p>On le verra plus précisément lorsque l'on parlera d'arbres, mais les notions de connexités, de chemins et de cycles (notions globales) sont très liés aux degrés des différents sommets (conditions locales). Les propositions fondamentales d'existence ci après le montrent. Bien qu'elles soient très simples, elles se révèlent souvent utile, soit par les propriétés elles-mêmes soit par leurs schémas de preuves qui s'appliquent très souvent.</p>
<p>Commençons par donner des condition d'existence de chemins et cycles de longueur donnée :</p>
<p><span id="prop-cycles-graphe"></span></p>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
</svg>
<div class="pl-8  mb-2 mr-8">
<p><strong>Proposition :</strong></p>
</div><div class="pl-8 mr-8">
<p>Soit $G = (V, E)$ un graphe. S'il existe un entier $k &gt; 1$ tel que $\delta(x) \geq k$ pour tout $x \in V$, alors :</p>
<ul>
<li>pour tout $x \in V$ il existe un chemin élémentaire de longueur $k$ partant de $x$ ,</li>
<li>il existe un cycle élémentaire de longueur au moins $k+1$,</li>
</ul>
</div></div>
<div class="relative drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-indigo-500 bg-indigo-100">
<details class="group">
<summary class="list-none py-0.5">
<svg class="group-open:hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M9 5l7 7-7 7" />
</svg>
<svg class="group-open:block hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7" />
</svg>
<div class="pl-8 font-bold inline-block">
<p>preuve</p>
</div>
<svg class="group-open:hidden inline-block pl-3 w-10 text-indigo-500" xmlns="http://www.w3.org/2000/svg"  fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M5 12h.01M12 12h.01M19 12h.01M6 12a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0z" />
</svg>
</summary>
<div class="mx-8 pb-2">
<p>Soit $c = v_0\dots v_i$ un chemin de longueur $i &lt; k$ partant de $x = v_0$ (pour $i = 0&lt; k$, ce chemin est réduit au seul point $x$).</p>
<p>Comme $\delta(v_i) = k &gt; i$ il existe un voisin $y$ de $v_i$ qui n'est pas un élément du chemin. On peut donc nommer $v_{i+1} = y$ et étendre $c$ d'un élément à $c= v_0\dots v_iv_{i+1}$. Ceci montre que l'on peut étendre $c$ à un chemin de longueur $k$.</p>
<p>Une fois que $c = v_0\dots v_i$ a atteint la longueur $k$, on peut continuer cette procédure en cherchant à agrandir $c$ par un sommet $v_{i+1}$ tel que :</p>
<ul>
<li>$v_iv_{i+1}$ est une arête du graphe</li>
<li>n'ayant aucun sommet $v_j$ avec $i+1 - k &lt; j &lt; i+1$ comme voisin (il y en a $k-1$)</li>
</ul>
<p>De deux choses l'une :</p>
<ol>
<li>soit $v_{i+1}$ n'a aucun voisin dans $c$, on peut agrandir $c$ et recommencer</li>
<li>soit $v_{i+1}$ a un voisin dans $c$ et on a trouvé un cycle de longueur au moins $k+1$</li>
</ol>
<p>Par finitude du graphe il arrivera forcément un moment où l'on atteindra le cas 2 ce qui conclut la preuve.</p>
</div>
</details>     
</div>
<p>De même pour garantir la connexité d'un graphe :</p>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
</svg>
<div class="pl-8  mb-2 mr-8">
<p><strong>Proposition :</strong></p>
</div><div class="pl-8 mr-8">
<p>Un graphe $G=(V, E)$ tel que (avec $\vert V \vert = n$ et $\vert E \vert = m$) :</p>
<p>$$<br>
m &gt; \frac{(n-1)(n-2)}{2}<br>
$$</p>
<p>est connexe.</p>
</div></div>
<div class="relative drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-indigo-500 bg-indigo-100">
<details class="group">
<summary class="list-none py-0.5">
<svg class="group-open:hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M9 5l7 7-7 7" />
</svg>
<svg class="group-open:block hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7" />
</svg>
<div class="pl-8 font-bold inline-block">
<p>preuve</p>
</div>
<svg class="group-open:hidden inline-block pl-3 w-10 text-indigo-500" xmlns="http://www.w3.org/2000/svg"  fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M5 12h.01M12 12h.01M19 12h.01M6 12a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0z" />
</svg>
</summary>
<div class="mx-8 pb-2">
<p>On montre la preuve par récurrence. Si $n=2$, il faut évidemment avoir $m &gt; 0$ pour que le graphe soit connexe. On suppose la propriété vraie pour $\vert V \vert = n-1$ et on se place à $\vert V \vert = n \geq 2$.</p>
<p>Si le graphe est complet on a $m = \frac{n(n-1)}{2} &gt; \frac{(n-1)(n-2)}{2}$ et le graphe est trivialement connexe. Il existe donc un sommet $x$ de degré $\delta(x) &lt; n-1$. De plus, s'il existait un sommet sans voisin, le nombre d'arêtes serait strictement plus petit $\frac{(n-1)(n-2)}{2}$ ce qui est impossible. On a donc également $\delta(x) \geq 1$.</p>
<p>Le nombre d'arêtes $m'$ du sous-graphe $G'$ induit par la suppression de $x$ dans $G$ vaut :</p>
<div>
$$
\begin{array}{ccl}
m' & = & m - \delta(x) \\
&\geq &m - (n-2) \\
&> &\frac{(n-1)(n-2)}{2} - (n-2)\\
&> &\frac{(n-2)(n-3)}{2}\\
\end{array}
$$
</div>
<p>Le graphe $G'$ est donc connexe par hypothèse de récurrence, donc $G$ l'est aussi puisque $\delta(x) &gt; 0$ (la composante connexe contenant $x$ intersecte $V \backslash { x}$ qui est un ensemble connexe de $G$).</p>
</div>
</details>     
</div>
<p>Notez bien que ces propositions ne sont que des implications. Si l'on prend le graphe $G=(\{v_1, \dots, v_n\}, E)$ avec $E = \{ v_iv_{i+1} \mid 1 \leq i \leq n \} \cup \{ v_1v_n \}$ il :</p>
<ul>
<li>est connexe alors qu'il a $n &lt; \frac{(n-1)(n-2)}{2}$ arêtes si $n \geq 5$,</li>
<li>admet un cycle de longueur $n$ alors que le degré de chaque élément est $2$.</li>
</ul>
<h2>Algorithmes</h2>
<p>On utilisera le graphe suivant pour nos algorithmes :</p>
<pre class="language-python " style="counter-reset: linenumber 0"><code class="language-python">G <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token string">"a"</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token string">"b"</span><span class="token punctuation">,</span> <span class="token string">"c"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token string">"b"</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token string">"c"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token string">"c"</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token string">"b"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token string">"d"</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
</svg>
<div class="pl-8 mr-8">
<p>L'encodage par défaut des graphes sera toujours celui <a href="../encodage#dict">par dictionnaires</a>.</p>
</div></div>
<h3>Algorithme de recherche de composante connexe</h3>
<pre class="language-python line-numbers" style="counter-reset: linenumber 0"><code class="language-python"><span class="token keyword">def</span> <span class="token function">composante_connexe</span><span class="token punctuation">(</span>G<span class="token punctuation">,</span> origine<span class="token punctuation">)</span><span class="token punctuation">:</span>
    composante <span class="token operator">=</span> <span class="token punctuation">{</span>origine<span class="token punctuation">}</span>
    suivant <span class="token operator">=</span> <span class="token punctuation">[</span>origine<span class="token punctuation">]</span>

    <span class="token keyword">while</span> suivant<span class="token punctuation">:</span>
        x <span class="token operator">=</span> suivant<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>

        <span class="token keyword">for</span> y <span class="token keyword">in</span> G<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> y <span class="token keyword">not</span> <span class="token keyword">in</span> composante<span class="token punctuation">:</span>
                composante<span class="token punctuation">.</span>add<span class="token punctuation">(</span>y<span class="token punctuation">)</span>
                suivant<span class="token punctuation">.</span>append<span class="token punctuation">(</span>y<span class="token punctuation">)</span>

    <span class="token keyword">return</span> composante
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>On utilise :</p>
<ul>
<li>méthodes des <a href="https://docs.python.org/fr/3/tutorial/datastructures.html#more-on-lists">liste</a> :
<ul>
<li>la méthode <code class="language-">pop</code> qui permet de supprimer le dernier élément de la liste et le rendre</li>
<li>la méthode <code class="language-">append</code> qui permet d'ajouter un élément à la fin de la liste</li>
</ul>
</li>
<li>méthodes des <a href="https://docs.python.org/fr/3/tutorial/datastructures.html#sets">ensembles</a> :
<ul>
<li>création avec les accolades</li>
<li>méthode <code class="language-">add</code> qui ajoute un élément à l'ensemble</li>
</ul>
</li>
</ul>
<h4><span id="comp-conn-complexité"></span> Complexité</h4>
<p>L'algorithme précédent utilise un ensemble pour stocker la composante connexe car :</p>
<ul>
<li>ajouter un élément à un ensemble prend $\mathcal{O}(1)$ opérations en moyenne</li>
<li>savoir si un élément est dans un ensemble prend $\mathcal{O}(1)$ opérations en moyenne</li>
</ul>
<p>Pour une liste :</p>
<ul>
<li>l'ajout d'un élément à la liste avec la méthode <code class="language-">append</code> prend $\mathcal{O}(1)$ opérations</li>
<li>la suppression d'un élément à la liste avec la méthode <code class="language-">pop</code> prend $\mathcal{O}(1)$ opérations</li>
</ul>
<p>La complexité de l'algorithme va ainsi dépendre :</p>
<ul>
<li>du nombre de fois où la boucle while de la ligne 5 va être exécutée</li>
<li>de la nature des éléments $x$ de la boucle</li>
</ul>
<p>Pour notre encodage, Toutes les opérations élémentaires de l'algorithme sont donc en $\mathcal{O}(1)$ opérations au maximum sauf le test de la ligne 9 et l'ajout à la composante de la ligne 10 qui est en $\mathcal{O}(1)$ opérations en moyenne.</p>
<p>Enfin, comme chaque sommet ne peut-être ajouté à suivant que s'il n'est pas encore dans la composante, chaque sommet ne peut y être ajouté qu'une fois : il y a au pire $\vert V \vert$ itérations de la boucle <code class="language-">while</code> de la ligne 5 et chaque sommet ne peut être choisi qu'au pire 1 fois comme élément <code class="language-">x</code> de la ligne 6. Et pour chaque élément la complexité de la boucle while sera de l'ordre de $\mathcal{O}(\delta(x))$ opérations en moyenne (le nombre de fois où l'on rentre dans la la boucle for)</p>
<p>On en conclut :</p>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
</svg>
<div class="pl-8 mr-8">
<p>La complexité de l'algorithme <code class="language-">composante_connexe</code> est pour un graphe encodé par dictionnaire de $\mathcal{O}(\vert E\vert)$ opérations en moyenne.</p>
<p>Il est donc linéaire en moyenne par rapport à la taille du graphe en entrée.</p>
</div></div>
<div class="quote relative py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-orange-500 bg-orange-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-orange-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M8.228 9c.549-1.165 2.03-2 3.772-2 2.21 0 4 1.343 4 3 0 1.4-1.278 2.575-3.006 2.907-.542.104-.994.54-.994 1.093m0 3h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>
<div class="pl-8 mr-8">
<p>Dans le cas où l'encodage du graphe est une liste d'adjacence, on peut changer la structure de <code class="language-">composante</code> pour que sa complexité (maximale) soit en $\mathcal{O}(\vert E \vert)$ opérations.</p>
<p>Quelle est cette structure ?</p>
</div></div>
<div class="relative drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-indigo-500 bg-indigo-100">
<details class="group">
<summary class="list-none py-0.5">
<svg class="group-open:hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M9 5l7 7-7 7" />
</svg>
<svg class="group-open:block hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7" />
</svg>
<div class="pl-8 font-bold inline-block">
<p>solution</p>
</div>
<svg class="group-open:hidden inline-block pl-3 w-10 text-indigo-500" xmlns="http://www.w3.org/2000/svg"  fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M5 12h.01M12 12h.01M19 12h.01M6 12a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0z" />
</svg>
</summary>
<div class="mx-8 pb-2">
<p>Dans le codage par liste d'adjacence, les sommets sont des entiers entre $0$ et $n-1$. On peut alors utiliser une liste de $n$ booléens pour composante. On place <code class="language-">composante[i]</code> à <code class="language-">True</code> lorsque l'on place le sommet $i$ dans la composante.</p>
<p>Toutes les opérations sur <code class="language-">composante</code> effectuée par l'algorithme sont en $\mathcal{O}(1)$ opérations au maximum.</p>
</div>
</details>     
</div>
<h4><span id="comp-conn-preuve"></span> Preuve</h4>
<p>L'algorithme va progresser de voisinage en voisinage et ajouter petit à petit les éléments qu'il n'a pas encore vu. S'il existe un chemin entre $x$ et $y$, $y$ chaque élément de ce chemin va être petit à petit intégré à la composante.</p>
<h3>Trouver un chemin</h3>
<p>L'algorithme suivant, nommé <code class="language-">chemin</code>, prend un graphe et deux sommets $a$ et $b$ en paramètres. Il rend soit un chemin entre $a$ et $b$ s'il existe soit le chemin vide si $a$ et $b$ sont dans deux composantes connexes différentes.</p>
<pre class="language-python line-numbers" style="counter-reset: linenumber 0"><code class="language-python"><span class="token keyword">def</span> <span class="token function">chemin</span><span class="token punctuation">(</span>G<span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">:</span>
    examinés <span class="token operator">=</span> <span class="token punctuation">{</span>a<span class="token punctuation">}</span>
    chemin <span class="token operator">=</span> <span class="token punctuation">[</span>a<span class="token punctuation">]</span>

    x <span class="token operator">=</span> a
    <span class="token keyword">while</span> x <span class="token operator">!=</span> b<span class="token punctuation">:</span>
        suivants <span class="token operator">=</span> G<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">-</span> examinés
        <span class="token keyword">if</span> suivants<span class="token punctuation">:</span>
            y <span class="token operator">=</span> suivants<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>
            examinés<span class="token punctuation">.</span>add<span class="token punctuation">(</span>y<span class="token punctuation">)</span>
            chemin<span class="token punctuation">.</span>append<span class="token punctuation">(</span>y<span class="token punctuation">)</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            chemin<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>

        <span class="token keyword">if</span> chemin<span class="token punctuation">:</span>
            x <span class="token operator">=</span> chemin<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            <span class="token keyword">break</span>

    <span class="token keyword">return</span> chemin
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>On utilise :</p>
<ul>
<li>méthodes des <a href="https://docs.python.org/fr/3/tutorial/datastructures.html#more-on-lists">liste</a> :
<ul>
<li>la méthode <code class="language-">pop</code> qui permet de supprimer le dernier élément de la liste et le rendre</li>
<li>la méthode <code class="language-">append</code> qui permet d'ajouter un élément à la fin de la liste</li>
<li>le fait quel'on puisse accéder au dernier élément d'une liste avec un indice de <code class="language-">-1</code></li>
</ul>
</li>
<li>méthodes des <a href="https://docs.python.org/fr/3/tutorial/datastructures.html#sets">ensembles</a> :
<ul>
<li>création avec les accolades</li>
<li>méthode <code class="language-">add</code> qui ajoute un élément à l'ensemble</li>
<li>la soustraction de deux ensembles qui rend un nouvel ensemble contenant les éléments du premier ensemble non présent dans le second.</li>
</ul>
</li>
<li>la commande <code class="langage-">break</code> qui sort de la boucle la plus imbriquée, ici la boucle <code class="language-">while</code> de la ligne 6.</li>
<li>les tests des lignes 8 et 15 qui rendent faut si l'ensemble ou la liste sont respectivement vides.</li>
</ul>
<h4><span id="chemin-complexité"></span> Complexité</h4>
<p>La complexité de chaque itération <code class="language-">while</code> de la ligne 6 et de l'ordre de $\mathcal{O}(\delta(x))$ opérations car il faut trouver un voisin non encore examiné. Comme à chaque fois qu'un voisin est utilisé, il est examiné, un même sommet pourra être le <code class="language-">x</code> de la boucle while au maximum $\delta(x)$ fois. De là, la complexité globale de l'algorithme est de l'ordre de :</p>
<p>$$<br>
C = \mathcal{O}(\sum_x (\delta(x))^2) \leq \mathcal{O}((\sum_x \delta(x))^2) = \mathcal{O}((2 \vert E \vert)^2) = \mathcal{O}(\vert E \vert^2)<br>
$$</p>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
</svg>
<div class="pl-8 mr-8">
<p>Notez que cet algorithme recalcule plein de fois la même chose : tous les voisins de $x$. Une version optimisée de cet algorithme, appelé parcours en profondeur et que nous verrons plus tard, permet de faire la même chose avec une complexité linéaire (c'est à dire la taille du graphe): $\mathcal{O}(\vert E \vert)$.</p>
</div></div>
<h4><span id="chemin-preuve"></span> Preuve</h4>
<p>Le preuve de l'algorithme repose sur la proposition suivante :</p>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
</svg>
<div class="pl-8  mb-2 mr-8">
<p><strong>Proposition :</strong></p>
</div><div class="pl-8 mr-8">
<p>Soit $G = (V, E)$ un graphe connexe et $a, b\in V$.</p>
<p>S'il existe  un chemin allant de $a$ à $x$ :</p>
<ul>
<li>ne passant pas par $b$</li>
<li>tel que tous les voisins de $x$ soient dans le chemin</li>
</ul>
<p>Alors il existe un chemin allant de $a$ à $b$ ne passant pas par $x$.</p>
</div></div>
<div class="relative drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-indigo-500 bg-indigo-100">
<details class="group">
<summary class="list-none py-0.5">
<svg class="group-open:hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M9 5l7 7-7 7" />
</svg>
<svg class="group-open:block hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7" />
</svg>
<div class="pl-8 font-bold inline-block">
<p>preuve</p>
</div>
<svg class="group-open:hidden inline-block pl-3 w-10 text-indigo-500" xmlns="http://www.w3.org/2000/svg"  fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M5 12h.01M12 12h.01M19 12h.01M6 12a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0z" />
</svg>
</summary>
<div class="mx-8 pb-2">
<p>Soit $c= a\dots x = v_0\dots v_p$ le chemin allant de $a$ à $x$ et $c' = a \dots b = w_0\dots w_q$ un chemin allant de $a$ à $b$ passant par $x$.</p>
<p>On note $1 \leq i &lt; q$ le plus grand indice tel qu'il existe $1\leq j &lt; p$ avec $w_i = v_j$. Comme $x$ est sur $c'$ :</p>
<ul>
<li>cet élément existe</li>
<li>il est placé après $x$ dans $c'$</li>
</ul>
<p>Le chemin $v_0 \dots v_i w_{j+1} \dots w_q$ est un chemin allant de $a$ à $b$ ne passant pas pas $x$.</p>
</div>
</details>     
</div>
<blockquote>
<p>TBD : preuve détaillée de l'algorithme.</p>
</blockquote>
<h3>Trouver un circuit ou un cycle</h3>
<p>Pour trouver un cycle, l'algorithme <code class="language-">chemin</code> précédent ne fonctionne pas directement en prenant $a=b$. En effet, c'est le cycle de longueur nulle qui est rendu. Il faut ajouter une <em>sentinelle</em> pour que la sortie ne se fasse que si la longueur du chemin est strictement positive.</p>
<p>Ceci n'est cependant pas suffisant car comme $a$ est dans l'ensemble <code class="language-">examiné</code> dès le départ, il ne pourra jamais être retrouvé par l'algorithme. Il faut donc commencer par un ensemble de sommets examinés vide.</p>
<p>Ceci est suffisant pour trouver des circuits dans des graphes orienté. On obtient l'algorithme suivant :</p>
<p><span id="algo-cycle-oriente"></span></p>
<pre class="language-python line-numbers" style="counter-reset: linenumber 0"><code class="language-python"><span class="token keyword">def</span> <span class="token function">circuit</span><span class="token punctuation">(</span>G<span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">:</span>
    examinés <span class="token operator">=</span> <span class="token builtin">set</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    chemin <span class="token operator">=</span> <span class="token punctuation">[</span>a<span class="token punctuation">]</span>

    x <span class="token operator">=</span> a
    <span class="token keyword">while</span> <span class="token punctuation">(</span>x <span class="token operator">!=</span> a<span class="token punctuation">)</span> <span class="token keyword">or</span> <span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>chemin<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        suivants <span class="token operator">=</span> G<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">-</span> examinés
        <span class="token keyword">if</span> suivants<span class="token punctuation">:</span>
            y <span class="token operator">=</span> suivants<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>
            examinés<span class="token punctuation">.</span>add<span class="token punctuation">(</span>y<span class="token punctuation">)</span>
            chemin<span class="token punctuation">.</span>append<span class="token punctuation">(</span>y<span class="token punctuation">)</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            chemin<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>

        <span class="token keyword">if</span> chemin<span class="token punctuation">:</span>
            x <span class="token operator">=</span> chemin<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            <span class="token keyword">break</span>

    <span class="token keyword">return</span> chemin
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>Si les graphes sont non orientés, on risque de trouver de <em>faux</em> cycle de type $[a, b, a]$ où on réutilise la même arête deux fois (prise une fois dans $G[a]$ et l'autre fois dans $G[b]$). Il ne faut donc permettre à l'algorithme de choisir $a$ que si la longueur du chemin est strictement plus grande que 1. On obtient finalement l'algorithme suivant pour les graphes non-orienté :</p>
<p><span id="algo-cycle-non-oriente"></span></p>
<pre class="language-python line-numbers" style="counter-reset: linenumber 0"><code class="language-python"><span class="token keyword">def</span> cycle_non_orienté<span class="token punctuation">(</span>G<span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">:</span>
    examinés <span class="token operator">=</span> <span class="token builtin">set</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    chemin <span class="token operator">=</span> <span class="token punctuation">[</span>a<span class="token punctuation">]</span>

    x <span class="token operator">=</span> a
    <span class="token keyword">while</span> <span class="token punctuation">(</span>x <span class="token operator">!=</span> a<span class="token punctuation">)</span> <span class="token keyword">or</span> <span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>chemin<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        suivants <span class="token operator">=</span> G<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">-</span> examinés
        <span class="token keyword">if</span> suivants<span class="token punctuation">:</span>
            y <span class="token operator">=</span> suivants<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token keyword">if</span> y <span class="token operator">==</span> a <span class="token keyword">and</span> <span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>chemin<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                <span class="token keyword">if</span> suivants<span class="token punctuation">:</span>
                    y <span class="token operator">=</span> suivants<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>
                    examinés<span class="token punctuation">.</span>add<span class="token punctuation">(</span>y<span class="token punctuation">)</span>
                    chemin<span class="token punctuation">.</span>append<span class="token punctuation">(</span>y<span class="token punctuation">)</span>
                <span class="token keyword">else</span><span class="token punctuation">:</span>
                    chemin<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                examinés<span class="token punctuation">.</span>add<span class="token punctuation">(</span>y<span class="token punctuation">)</span>
                chemin<span class="token punctuation">.</span>append<span class="token punctuation">(</span>y<span class="token punctuation">)</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            chemin<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>

        <span class="token keyword">if</span> chemin<span class="token punctuation">:</span>
            x <span class="token operator">=</span> chemin<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            <span class="token keyword">break</span>

    <span class="token keyword">return</span> chemin
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


</article>
    </main>

    <footer class="min-h-[50px] border-t-2 border-gray-200 mt-4">
      <div class="max-w-[1000px] mx-auto px-4">
        <div class="min-h-[50px] flex justify-center items-center">
          <p>
            Cours d'informatique à l'école centrale Marseille
          </p>
        </div>
      </div>
    </footer>

    <script>
      MathJax
        .startup
        .document
        .getMathItemsWithin(document.body);
    </script>

  </body>
</html>