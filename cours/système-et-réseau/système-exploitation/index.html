<!DOCTYPE html>
<html lang="fr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>Système d&#39;exploitation</title>

    <link href="/cours_informatique/assets/node_modules/prismjs/themes/prism-solarizedlight.css" rel="stylesheet">
    
    <link href="/cours_informatique/assets/node_modules/prismjs/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet">
    <script src="/cours_informatique/assets/node_modules/prismjs/plugins/line-numbers/prism-line-numbers.min.js"></script>

    <link href="/cours_informatique/assets/stylesheets/main.css" rel="stylesheet">

  </head>
  <body>
    <script>
      window.MathJax = {
        tex: {
          inlineMath: [
            [
              '$', '$'
            ],
            [
              '\\(', '\\)'
            ]
          ]
        },
        svg: {
          fontCache: 'global'
        }
      };

      function goTop() {
        window.scrollTo({top: 0});
      }
      function goBottom() {
        window.scrollTo({top: document.body.scrollHeight});
      }
    </script>
    <script type="text/javascript" id="MathJax-script" src="/cours_informatique/assets/node_modules/mathjax/es5/tex-svg-full.js"></script>

    <header class="border-b-2 border-gray-200 mb-4">
      <div class="max-w-[1200px] mx-auto px-4 relative">
        <div class="min-h-[50px] flex justify-between items-center">
          <a class="mx-2" href="/cours_informatique/">Home</a>
        </div>

        <div class="min-h-[50px] flex justify-center items-center absolute right-0 top-0">
          <a class="mx-2" href="/cours_informatique/about">About</a>
          <button onclick="goTop()" id="myBtn" title="Go to top">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
              <path stroke-linecap="round" stroke-linejoin="round" d="M15 11.25l-3-3m0 0l-3 3m3-3v7.5M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
            </svg>
          </button>

          <button onclick="goBottom()" id="myBtn" title="Go to top">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
              <path stroke-linecap="round" stroke-linejoin="round" d="M9 12.75l3 3m0 0l3-3m-3 3v-7.5M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
            </svg>
          </button>
        </div>

      </div>
    </header>

    <main class="max-w-[1200px] mx-auto px-4">
      
<article>

  <h1>Système d&#39;exploitation</h1>
  <div>
    

    
  </div>

  

    
<div class="quote relative  py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-purple-500 bg-purple-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-purple-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M5 19a2 2 0 01-2-2V7a2 2 0 012-2h4l2 2h4a2 2 0 012 2v1M5 19h14a2 2 0 002-2v-5a2 2 0 00-2-2H9a2 2 0 00-2 2v5a2 2 0 01-2 2z"></path>
</svg>
<div class="pl-8 mr-8">

<a class="interne" href="/cours_informatique/cours/">Cours</a><span class="px-1">/</span><a class="interne" href="/cours_informatique/cours/système-et-réseau/">Système et réseau</a><span class="px-1">/</span><a class="interne" href="/cours_informatique/cours/système-et-réseau/système-exploitation/">Système d&#39;exploitation</a>

</div></div>



    
  

  <p>Le but d'un <a href="https://fr.wikipedia.org/wiki/Ordinateur">ordinateur</a> est d'exécuter des <a href="https://fr.wikipedia.org/wiki/Processus_(informatique)">processus</a>. Pour que chaque processus n'ait pas à tout gérer (accès au processeur, à la mémoire, au disque dur, au réseau, ...) comme on le ferait avec un circuit imprimé par exemple, on utilise un <a href="https://fr.wikipedia.org/wiki/Syst%C3%A8me_d%27exploitation">système d'exploitation</a> (ou <em><strong>OS</strong></em> pour <em>operating system</em>).</p>
<p>Son but est de faire le lien entre le <a href="https://fr.wikipedia.org/wiki/Mat%C3%A9riel_informatique">matériel</a> (<em>hardware</em>) et le <a href="https://fr.wikipedia.org/wiki/Logiciel">logiciel</a> (<em>software</em>).</p>
<p><img src="os.png" alt="os"></p>
<p>Le matériel comporte tous les éléments physique d'une machine :</p>
<ul>
<li>processeur</li>
<li>mémoire</li>
<li>disques dur</li>
<li>clavier, souris, écran</li>
<li>carte réseau</li>
<li>...</li>
</ul>
<p>Que l'on peut regrouper en trois grandes catégories :</p>
<ul>
<li>processeur</li>
<li>mémoire</li>
<li>les <a href="https://en.wikipedia.org/wiki/Peripheral">périphériques</a> ou <em>devices</em> qui regroupent tout le reste. C'est ce qui se branche sur la <a href="https://fr.wikipedia.org/wiki/Carte_m%C3%A8re">carte mère</a>.</li>
</ul>
<p>Les logiciels, que d'un point de vue système on appellera <a href="https://fr.wikipedia.org/wiki/Processus_(informatique)">process</a> ou processus auront besoin pour fonctionner d'accéder :</p>
<ul>
<li>au processeur pour effectuer les différentes opérations de leur code,</li>
<li>à la mémoire pour stocker leurs variables</li>
<li>souvent à des devices comme un disque dur (pour lire un fichiers), à la carte réseau (pour aller lire le contenu du site <a href="https://news.ycombinator.com/">hacker news</a>), en encore au clavier</li>
</ul>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
</svg>
<div class="pl-8 mr-8">
<p>Le but d'un système d'exploitation est double :</p>
<ul>
<li>il doit permettre d'utiliser les devices de l'ordinateur grâce à des <a href="https://fr.wikipedia.org/wiki/Pilote_informatique">drivers</a></li>
<li>il permet l'exécution de process :
<ul>
<li>de façon <a href="https://fr.wikipedia.org/wiki/Programmation_concurrente">concurrente</a> (on peut écrire dans un gdoc tout en écoutant de la musique)</li>
<li>de façon sécurisée : le gdoc ne peut accéder aux variables de l'application jouant de la musique</li>
</ul>
</li>
</ul>
</div></div>

<div class="quote relative  py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-cyan-500 bg-cyan-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-cyan-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z"></path>
</svg>
<div class="pl-8 mr-8">
<p><a href="https://www.youtube.com/watch?v=r2__Rw8vu1M">Parallèle vs concurrent</a> :</p>
<ul>
<li>concurrent : le début d'un process est entre la début et la fin de l'autre</li>
<li>parallèle : en même temps</li>
</ul>
</div></div>

<h2>Couches Systèmes</h2>
<p>Un système d’exploitation n'est pas monolithique, il est constitué de multiple partie qui forment un tout cohérent.</p>
<p>L'organisation logicielle d'un ordinateur (ou plus généralement tout système logiciel assez important) est constitué de <em>couches</em>, comme le stipule le</p>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
</svg>
<div class="pl-8 mb-2 mr-8">
<p><strong><a href="https://en.wikipedia.org/wiki/Fundamental_theorem_of_software_engineering">théorème fondamental de l’ingénierie logicielle</a></strong></p>
</div><div class="pl-8 mr-8">
<p>On peut régler tous les problèmes en ajoutant une couche d'indirection</p>
</div></div>

<pre><code>       compliqué
A --------------------&gt; B
   simple      simple
A --------&gt; C --------&gt; B
</code></pre>
<p>Un autre exemple célèbre de couches en ingénierie système est le découpage en <a href="https://fr.wikipedia.org/wiki/Suite_des_protocoles_Internet">couches d'un réseau</a>. Ce principe universel est une instanciation de la <a href="https://fr.wikipedia.org/wiki/Discours_de_la_m%C3%A9thode#Deuxi%C3%A8me_partie">deuxième partie du discours de la méthode</a> : il faut diviser chaque difficulté en autant de parties facile à résoudre séparément.
D'un point de vue ingénierie, ceci permet en plus de  clairement les responsabilités de chaque couche, une maintenance plus aisée.</p>
<p>Un ordinateur et son utilisation peut être séparé quatre couches :</p>
<ol>
<li>Matériel
<ul>
<li>mémoire RAM</li>
<li>devices</li>
</ul>
</li>
<li>Noyau
<ul>
<li>drivers matériels</li>
<li>gestion de la mémoire</li>
<li>ordonnancement des processus</li>
</ul>
</li>
<li>process
<ul>
<li>interface graphique</li>
<li>terminal</li>
<li>...</li>
</ul>
</li>
<li>utilisateurs
<ul>
<li>qui à le droit de faire quoi</li>
</ul>
</li>
</ol>
<p>Les utilisateurs lancent les process. Ceux-ci s'exécutent de façon parallèle grâce au noyau et utilisent les ressources matériels via des <a href="https://fr.wikipedia.org/wiki/Appel_syst%C3%A8me">appels systèmes</a>.</p>
<h2>Mémoire</h2>
<div class="quote relative py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-fuchsia-500 bg-fuchsia-100">
  <svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-fuchsia-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
    <path stroke-linecap="round" stroke-linejoin="round" d="M5.25 5.653c0-.856.917-1.398 1.667-.986l11.54 6.348a1.125 1.125 0 010 1.971l-11.54 6.347a1.125 1.125 0 01-1.667-.985V5.653z"></path>
  </svg>
<div class="pl-8 mr-8">
<p><a href="m%C3%A9moire" class="interne">Mémoire</a></p>
</div></div>

<h2>Système d'exploitation</h2>
<p>Seul le noyau a accès au matériel et a un contrôle total de la machine. Il doit donc être le plus petit possible car le moindre bug fait planter la machine. C'est pourquoi on distingue deux états d'une machine :</p>
<ul>
<li>le <em>kernel mode</em> : le noyau travail</li>
<li>le <em>user mode</em> : un process travaille</li>
</ul>
<div class="quote relative py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-emerald-500 bg-emerald-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-emerald-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
  <path stroke-linecap="round" stroke-linejoin="round" d="M13.19 8.688a4.5 4.5 0 011.242 7.244l-4.5 4.5a4.5 4.5 0 01-6.364-6.364l1.757-1.757m13.35-.622l1.757-1.757a4.5 4.5 0 00-6.364-6.364l-4.5 4.5a4.5 4.5 0 001.242 7.244"></path>
</svg>
<div class="pl-8 mr-8">
<p><a href="https://learn.microsoft.com/fr-fr/windows-hardware/drivers/gettingstarted/user-mode-and-kernel-mode">User et Kernel mode sous windows 11</a></p>
</div></div>

<p>Un système d'exploitation ne peut donc être uniquement composé d'un noyau, ce serait inefficace (rien ne pourrait être exécuté en parallèle) et dangereux (le moindre bug logiciel ou matériel ferait tout planter). On sépare habituellement un système d'exploitation en 3 parties :</p>
<ul>
<li><strong>le</strong> <a href="https://fr.wikipedia.org/wiki/Noyau_de_syst%C3%A8me_d%27exploitation">noyau</a> (<em>kernel</em>) dont le but est de gérer :
<ul>
<li>les appels systèmes</li>
<li>l'ordonnancement des process</li>
<li>communications entre les 3 entités d'un ordinateur (process, matériel, noyau)</li>
</ul>
</li>
<li><strong>des</strong> <a href="https://en.wikipedia.org/wiki/Interface_(computing)#Software_interfaces">interfaces logicielles</a> qui permettent d'accéder aux devices (comme accéder à une clé usb)</li>
<li><strong>des</strong> <a href="https://fr.wikipedia.org/wiki/Daemon_(informatique)">démons</a> qui gèrent l'environnement (le fait de réagir à l'insertion d'une clé usb dans l'ordinateur par exemple)</li>
</ul>
<p>Les démons et les interfaces sont des process comme les autres. Ils sont cependant exécutés par un utilisateur spécial, souvent nommé <a href="https://fr.wikipedia.org/wiki/Utilisateur_root"><code>root</code></a>, qui est le [super-utilisateur] qui est le représentant utilisateur du système.</p>
<p><img src="os-2.png" alt="os 2"></p>
<h2>Utilisateurs</h2>
<p>On peut séparer les utilisateurs d'un système en trois grandes catégorie.</p>
<h3><code>root</code></h3>
<p>L'utilisateur <code>root</code> est l'utilisateur lié au système d'exploitation. Il est le propriétaire des process (démons) et interfaces du système d'exploitation. Cet utilisateur a ainsi tous les droits (peut aller partout, réserver autant de mémoire qu'il veut, etc).</p>
<p>Comme <strong>Tout</strong> processus a un propriétaire, l'existence de cet utilisateur est garantie.</p>
<h3>Administrateurs systèmes</h3>
<div class="quote relative py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-emerald-500 bg-emerald-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-emerald-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
  <path stroke-linecap="round" stroke-linejoin="round" d="M13.19 8.688a4.5 4.5 0 011.242 7.244l-4.5 4.5a4.5 4.5 0 01-6.364-6.364l1.757-1.757m13.35-.622l1.757-1.757a4.5 4.5 0 00-6.364-6.364l-4.5 4.5a4.5 4.5 0 001.242 7.244"></path>
</svg>
<div class="pl-8 mr-8">
<p><a href="https://fr.wikipedia.org/wiki/Administrateur_syst%C3%A8me">administrateur système</a></p>
</div></div>

<p>Ces utilisateurs ont des droits particulier, ils peuvent modifier des paramètres systèmes et exécuter ou stopper des démons. Ces utilisateur ne sont pas forcément root, en effet,  souvent l'utilisateur principal d'une machine est administrateur.</p>
<p>Cela permet, si nécessaire, d'installer ou de configurer son système sans être connecté en tant que root.</p>
<h3>Simple utilisateur</h3>
<p>Enfin, il existe la foule des autres utilisateurs (vous sur les ordinateurs de l'école ou la fac par exemple) qui ne peuvent pas administer la machine, ni lancer de démons. Vous avez en revanche le droit d'exécuter la plupart des process et d'installer vos propres programme dans l'espace disque qui vous est réservé.</p>
<h3>Groupes d'utilisateurs</h3>
<blockquote>
<p>TBD : permet d'exécution de process, ou l'accès à certains utilisateurs. Par exemple : le groupe web qui permet de stocker ses fichiers html quelque part, au démon serveur d'accéder aux fichiers, etc. Cela permet de séparer les responsabilités.</p>
</blockquote>
<h2>Process</h2>
<p>Un process est l'unité de base d'un programme. Un process est un ensemble d'instruction exécutées par le système d'exploitation. Tout process est la propriété le l'utilisateur du système qui l'a exécuté.</p>
<div class="quote relative py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-fuchsia-500 bg-fuchsia-100">
  <svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-fuchsia-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
    <path stroke-linecap="round" stroke-linejoin="round" d="M5.25 5.653c0-.856.917-1.398 1.667-.986l11.54 6.348a1.125 1.125 0 010 1.971l-11.54 6.347a1.125 1.125 0 01-1.667-.985V5.653z"></path>
  </svg>
<div class="pl-8 mr-8">
<p><a href="process" class="interne">Process</a></p>
</div></div>

<h2>Noyau</h2>
<p>Le noyau est partie intégrante de tout process. Il est toujours là et s'exécute de temps en temps pour effectuer ses tâches.</p>
<div class="quote relative py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-fuchsia-500 bg-fuchsia-100">
  <svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-fuchsia-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
    <path stroke-linecap="round" stroke-linejoin="round" d="M5.25 5.653c0-.856.917-1.398 1.667-.986l11.54 6.348a1.125 1.125 0 010 1.971l-11.54 6.347a1.125 1.125 0 01-1.667-.985V5.653z"></path>
  </svg>
<div class="pl-8 mr-8">
<p><a href="noyau" class="interne">Noyau</a></p>
</div></div>

<h2>Multi Process</h2>
<p>Les systèmes d'exploitation permettent tous d'exécuter plusieurs threads de façon concurrente :</p>
<ul>
<li>plusieurs thread d'un même process : ils partagent la même organisation en mémoire</li>
<li>plusieurs thread de process différents : chaque process à sa propre organisation en mémoire</li>
</ul>
<p>Ceci peut se passer même si l'ordinateur ne possède qu'un seul core. La quasi totalité des ordinateurs actuellement sont <a href="https://fr.wikipedia.org/wiki/Symmetric_multiprocessing">multi-core</a>, ce qui permet même d'exécuter des threads de façon parallèle.</p>
<p>Chaque thread sur une machine peut–être dans 3 états distincts :</p>
<ul>
<li>bloqué : en attente d'une instruction d'entrée/sortie par exemple</li>
<li>actif : en cours d'exécution</li>
<li>prêt : prêt à être exécuté</li>
</ul>
<p>Le principe du multi-processing est est simple. Prenons l'exemple de 2 threads (A et B) à exécuter sur un unique core.
Lorsque le noyau lance l'exécution du premier thread, il va demander au processeur de se faire réveiller au bout de 10ms par une interruption. Le thread A s'exécute donc pendant 10ms avant qu'une interruption ne rappelle le noyau qui va pouvoir stopper le thread A (qu'il va placer en mode activable) et réactiver le thread B (il passe de activable à activé). Une fois ceci fait, le noyau se rendort pour 10ms (via une interruption) et le cycle continue.</p>
<p>Si l'ordinateur possède plusieurs core, le noyau choisi sur quel lancer le thread mais le principe est le même : il se réveille à intervalles déterminés pour gérer l'activation et la désactivation des threads.</p>
<p>Cette activation/ désactivation s'appelle le context switching et n'est pas immédiate, il faut en effet s'assurer que le thread B n'endommage pas l'exécution du thread A.</p>
<h3>Context switching</h3>
<p>L'exécution d'un thread dépend :</p>
<ul>
<li>de la mémoire du process dont le thread fait partie</li>
<li>de sa pile (chaque thread a une pile qui lu est propre)</li>
<li>des registres du processeur (IP, SP, et tous les autres)</li>
</ul>
<p>Si l'on exécuter un thread B sur un core qui exécute déjà un thread A il faut :</p>
<ul>
<li>sauver les registres du core (ils dépendent du thread A) et les remplacer par ceux sauvé du thread B</li>
<li>sauver la mémoire (c'est celle associée au thread A) et la remplacer par celle sauvée du thread B :
<ul>
<li>toute la mémoire si les deux threads sont dans 2 process différents</li>
<li>uniquement la pile si les deux threads pont partie du même process</li>
</ul>
</li>
</ul>
<p>S'il est facile de sauver/restaurer tout les registres d'un core (il n'y en a pas beaucoup et sont de petite taille) il n'est pas possible de sauver toute la mémoire.</p>
<p>Même si on ne considère que la mémoire effectivement utilisée par le process (les segments de code, données, pile, tas et bibliothèques partagées) il y en a beaucoup trop pour que le transfert vert le disque dur ne soit pas prohibitif niveau temps.
En revanche, ces segments sont loin de remplir toute la mémoire : il y a (normalement) la place de contenir les segments utilisées pour deux threads</p>
<p>L'idée est donc de trouver un moyen efficace en temps pour :</p>
<ul>
<li>stocker les segments des deux threads en mémoire</li>
<li>conserver l'illusion pour chaque thread qu'il est seul en mémoire</li>
</ul>
<p>Pour cela, on commence par découper toute la mémoire en <a href="https://en.wikipedia.org/wiki/Page_table">pages</a> (habituellement de 4KiB) et d'avoir une correspondance entre une mémoire logique, celle que voit le thread et la mémoire physique, en RAM.</p>
<p>On (le noyau) conserve pour chaque thread la correspondance des adresses physiques pour chaque page utilisée par ses segments :</p>
<pre><code>mémoire physique  process A    process B    segments
      a              a           a           noyau
      b              f           b           pile
      c                          e
      d
      e
      f              c           c           bibliothèques partagées
      g
      h              d           k           tas
      j
      j              h           g           data
      l              i           j           code
      0
</code></pre>
<p>On voit que le process A et B partagent certaines pages (le code du noyau et les bibliothèques partagées), et qu'il reste de la place pour au moins un troisième process en mémoire.</p>
<div class="quote relative  py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-cyan-500 bg-cyan-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-cyan-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z"></path>
</svg>
<div class="pl-8 mr-8">
<p>Lorsque la mémoire RAM physique ne suffit plus pour stocker toutes les données de tous les process, le système d’exploitation possède une partie spécifique du disque dur appelée <a href="https://fr.wikipedia.org/wiki/Espace_d%27%C3%A9change">swap</a> qui permet de transférer de la RAM au disque dur et réciproquement si nécessaire.</p>
</div></div>

<p>Avec cette astuce de mémoire logique (vous verrez aussi parfois le terme de virtuelle) et physique, changer de contexte d'exécution pour arrêter un thread et en activer un autre est très rapide ! Encore pus rapide si les deux threads font partie du même process.</p>
<h3>Ordonnancement</h3>
<p>Si on doit exécuter $n$ thread sur $p &lt; n$ cores il faut :</p>
<ul>
<li>choisir sur quel core exécuter chaque thread</li>
<li>choisir quel thread exécuter</li>
<li>choisir le temps pendant lequel exécuter chaque thread</li>
</ul>
<p>Comme chaque thread possède le code du noyau et que chaque core possède un thread : le noyau est présent sur chaque core. Il est ainsi possible pour le noyau :</p>
<ul>
<li>d'avoir une liste globale de tous les process du système</li>
<li>de répartir l'exécution de ces thread sur chaque core.</li>
</ul>
<p>Le noyau peut donc choisir :</p>
<ol>
<li>quel thread exécuter sur chaque core</li>
<li>quel thread activer par core à un moment donné</li>
<li>combien de temps laisser activé un thread avant d'en activer un autre</li>
</ol>
<h4>Exemple</h4>
<div class="quote relative py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-emerald-500 bg-emerald-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-emerald-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
  <path stroke-linecap="round" stroke-linejoin="round" d="M13.19 8.688a4.5 4.5 0 011.242 7.244l-4.5 4.5a4.5 4.5 0 01-6.364-6.364l1.757-1.757m13.35-.622l1.757-1.757a4.5 4.5 0 00-6.364-6.364l-4.5 4.5a4.5 4.5 0 001.242 7.244"></path>
</svg>
<div class="pl-8 mr-8">
<p>Un exemple simple d’ordonnancement avec des entrées sorties qui ralentissent l'exécution des process : <a href="https://www.youtube.com/watch?v=sxSv4ZdQTOQ">https://www.youtube.com/watch?v=sxSv4ZdQTOQ</a></p>
</div></div>

<blockquote>
<p>TBD : à expliciter.</p>
</blockquote>
<h4>Core et thread</h4>
<p>Le noyau possède pour chaque core une liste de threads qu'ils gère et il peut décider de déplacer un thread d'un core à un autre pour garantir une charge de travail équilibrée entre les différents core. Pour cela, le noyau possède un thread par core dont le but est de migrer si nécessaire un thread d'un core à un autre.</p>
<p>Choisir quel thread exécuter sur quel core pour minimiser le temps total d'exécution est un problème difficile, le noyau a donc des heuristiques de choix simples pour pouvoir décider souvent plutôt qu'optimalement.</p>
<div class="quote relative  py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-cyan-500 bg-cyan-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-cyan-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z"></path>
</svg>
<div class="pl-8 mr-8">
<p>Le problème dérive du problème <a href="https://fr.wikipedia.org/wiki/Probl%C3%A8me_de_partition">partition</a> qui est un problème NP-complet,  (c'est à dire universel) : on ne connaît pas d'autre algorithme que de tester toutes les possibilités.</p>
<p>Pour s'en convaincre, prenons une machine à 2 cores et $n$ processus dont on connaît les temps d'exécution. Minimiser le temps d'exécution des $n$ process revient à séparer les $n$ en deux groupe dont la somme des temps d'exécution est égale.</p>
</div></div>

<h4>Activation et désactivation d'un thread</h4>
<p>Plusieurs possibilités existent, chacune avec leurs avantages et inconvénient :</p>
<ul>
<li>chacun son tour. Principe du <a href="https://fr.wikipedia.org/wiki/Round-robin_(informatique)">tourniquet (round-robin)</a></li>
<li>par priorité :
<ul>
<li>celui qui a été le moins de temps exécuté : utilisé par la méthode actuelle, <a href="https://en.wikipedia.org/wiki/Completely_Fair_Scheduler">Completely fair scheduler</a></li>
<li>le premier à finir (utilisé par la nouvelle méthode, <a href="https://en.wikipedia.org/wiki/Earliest_eligible_virtual_deadline_first_scheduling">EEVDF</a>)</li>
<li>...</li>
</ul>
</li>
</ul>
<p>Les algorithmes basé sur la priorité doivent pouvoir rapidement :</p>
<ul>
<li>choisir le thread le plus prioritaire</li>
<li>modifier la priorité d'un thread une fois qu'il est activé</li>
</ul>
<p>Pour cela, on utilise une <a href="https://fr.wikipedia.org/wiki/File_de_priorit%C3%A9">file de priorité</a> implémentée sous la forme d'<a href="https://fr.wikipedia.org/wiki/Arbre_bicolore">un arbre de recherche rouge-noir</a> ce qui permet de garantir des opérations en $\mathcal{O}(\log(N))$.</p>
<div class="quote relative py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-emerald-500 bg-emerald-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-emerald-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
  <path stroke-linecap="round" stroke-linejoin="round" d="M13.19 8.688a4.5 4.5 0 011.242 7.244l-4.5 4.5a4.5 4.5 0 01-6.364-6.364l1.757-1.757m13.35-.622l1.757-1.757a4.5 4.5 0 00-6.364-6.364l-4.5 4.5a4.5 4.5 0 001.242 7.244"></path>
</svg>
<div class="pl-8 mr-8">
<p>Voir <a href="https://www.geeksforgeeks.org/completely-fair-scheduler-cfs-and-brain-fuck-scheduler-bfs/">ce document</a> pour le scheduler par défaut de Linux.</p>
</div></div>

<h4>Temps d'activation</h4>
<div class="quote relative py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-emerald-500 bg-emerald-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-emerald-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
  <path stroke-linecap="round" stroke-linejoin="round" d="M13.19 8.688a4.5 4.5 0 011.242 7.244l-4.5 4.5a4.5 4.5 0 01-6.364-6.364l1.757-1.757m13.35-.622l1.757-1.757a4.5 4.5 0 00-6.364-6.364l-4.5 4.5a4.5 4.5 0 001.242 7.244"></path>
</svg>
<div class="pl-8 mr-8">
<p>Voir
<a href="https://opensource.com/article/19/2/fair-scheduling-linux">https://opensource.com/article/19/2/fair-scheduling-linux</a> pour le scheduler actuel de Linux.</p>
</div></div>

<p>L'algorithme utilisé actuellement (CFS) procède ainsi. Dans un temps donné T, s'il y a $N$ thread à exécuter, on allouera $T/N$ temps à tout le monde.</p>
<p>On s'assure en plus que ce temps est supérieur au temps nécessaire pour le context switching, ce qui assure que tout thread pourra au moins être exécuté 1 cycle.</p>
<h3>Création de process/thread</h3>
<p>L'ensemble des process est organisé en arbre, à partir du premier process lancé par le noyau.</p>
<p>Un process est composé :</p>
<ul>
<li>d'un identifiant (un identifiant noté <a href="https://fr.wikipedia.org/wiki/Identifiant_de_processus">pid</a>)</li>
<li>de l'identifiant de son parent  (noté ppid)</li>
<li>de sa table d'allocation mémoire</li>
<li>d'un ensemble de threads (il y en a au moins 1). Chaque thread étant déterminé par son contexte d'exécution composé de :
<ul>
<li>sa pile</li>
<li>les registres du core sur lequel il est exécuté</li>
</ul>
</li>
</ul>
<h4>Création de thread</h4>
<p>Il suffit d'allouer une page pour sa pile et créer un contexte d'exécution en associant une valeur au pointeur de pile et au pointeur d'instruction (la première instruction du thread, une fonction du code).</p>
<h4>Création de process</h4>
<p>La création d'un nouveau process se fait par duplication d'un autre process. C'est un appel système.</p>
<p>Le nouveau process possède :</p>
<ul>
<li>un identifiant qui lui est propres</li>
<li>l'identifiant de son parent est l'identifiant du process à l'initiative de la duplication</li>
<li>sa table d'allocation mémoire est une copie de la table d'allocation de son parent</li>
<li>d'un nouveau thread dont le pointeur d'instruction est le même que celui du thread à l'origine de la commande ayant initié la duplication</li>
</ul>
<p>Ce qui différencie le nouveau process de l'ancien est que le retour du syscall de duplication vaut :</p>
<ul>
<li>0 pour le thread de l'enfant</li>
<li>le pid (strictement position) du process du thread parent</li>
<li>-1 si une erreur est survenue</li>
</ul>
<p>Pour que la duplication des pages mémoires ne soit pas longue, on utilise la technique du <a href="https://www.youtube.com/watch?v=ViUwLytKzTY">copy on write</a> : on garde la même page pour les deux process, on ne duplique la page mémoire que si un des deux process veut modifier la page.</p>
<p>Les process sont ainsi organisé en arbre. Chaque process ayant un parent, à part le premier process exécuté par le noyau dont le but est de créer tous les démons et de finir par le process de login.</p>
<p>Lorsqu'un process se termine (ou est tué par un signal) il commence par terminer ses enfants (en leur envoyant un signal de fin).</p>
<div class="quote relative py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-emerald-500 bg-emerald-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-emerald-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
  <path stroke-linecap="round" stroke-linejoin="round" d="M13.19 8.688a4.5 4.5 0 011.242 7.244l-4.5 4.5a4.5 4.5 0 01-6.364-6.364l1.757-1.757m13.35-.622l1.757-1.757a4.5 4.5 0 00-6.364-6.364l-4.5 4.5a4.5 4.5 0 001.242 7.244"></path>
</svg>
<div class="pl-8 mr-8">
<p><a href="https://python-course.eu/applications-python/forks-and-forking.php">un exemple en python</a> de l'utilisation de <code class="language-">fork()</code> pour dupliquer un process.</p>
</div></div>

<h2>Système de fichiers</h2>
<p>La mémoire permet de stocker et gérer l'information nécessaire pour l'exécution de process. Il est cependant nécessaire d'avoir un espace de stockage permanent pour stocker les programmes ou les données lorsque l'ordinateur est éteint.</p>
<p>On stocke ces informations sous la forme de <a href="https://fr.wikipedia.org/wiki/Fichier_informatique">fichiers</a> organisés en arborescence.</p>
<div class="quote relative py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-fuchsia-500 bg-fuchsia-100">
  <svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-fuchsia-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
    <path stroke-linecap="round" stroke-linejoin="round" d="M5.25 5.653c0-.856.917-1.398 1.667-.986l11.54 6.348a1.125 1.125 0 010 1.971l-11.54 6.347a1.125 1.125 0 01-1.667-.985V5.653z"></path>
  </svg>
<div class="pl-8 mr-8">
<p><a href="syst%C3%A8me-fichiers" class="interne">Système de fichiers</a></p>
</div></div>

<h2>Démarrage de l'ordinateur</h2>
<p>Les différentes étapes du chargement d'un système d'exploitation</p>
<ol>
<li>boot de l'ordinateur</li>
<li>exécution d'un <a href="https://fr.wikipedia.org/wiki/Chargeur_d%27amor%C3%A7age">chargeur d'amorçage (<em>bootloader</em>)</a></li>
<li>charge le noyau
<ol>
<li>vérification du matériel</li>
<li>vérification des sous-systèmes : réseau, ...</li>
</ol>
</li>
<li>passage en user mode puis charge les démons et les interfaces</li>
<li>login</li>
</ol>
<h2>Bibliographie</h2>
<ul>
<li>deux playlist YouTube :
<ul>
<li><a href="https://www.youtube.com/watch?v=7cQ1PNVYgxw&amp;list=PL2Yggtk_pK6-R9ehjj0AoTnWrNOLChuld">https://www.youtube.com/watch?v=7cQ1PNVYgxw&amp;list=PL2Yggtk_pK6-R9ehjj0AoTnWrNOLChuld</a></li>
<li><a href="https://www.youtube.com/watch?v=TavEuAJ4z9A&amp;list=PLhy9gU5W1fvUND_5mdpbNVHC1WCIaABbP">https://www.youtube.com/watch?v=TavEuAJ4z9A&amp;list=PLhy9gU5W1fvUND_5mdpbNVHC1WCIaABbP</a></li>
</ul>
</li>
<li>du transistor au processeur : <a href="https://www.amazon.fr/Code-Language-Computer-Hardware-Software/dp/0137909101">https://www.amazon.fr/Code-Language-Computer-Hardware-Software/dp/0137909101</a></li>
<li>architecture matérielle : <a href="https://www.amazon.fr/Write-Great-Code-2nd-Understanding/dp/171850036X/">https://www.amazon.fr/Write-Great-Code-2nd-Understanding/dp/171850036X/</a></li>
</ul>


</article>
    </main>

    <footer class="min-h-[50px] border-t-2 border-gray-200 mt-4">
      <div class="max-w-[1200px] mx-auto px-4 relative">
        <div class="min-h-[50px] flex justify-center items-center">
          <p>
            Cours d'informatique de François Brucker
          </p>
        </div>
        <div class="min-h-[50px] flex justify-center items-center absolute right-0 top-0">
          <button onclick="goTop()" id="myBtn" title="Go to top">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
              <path stroke-linecap="round" stroke-linejoin="round" d="M15 11.25l-3-3m0 0l-3 3m3-3v7.5M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
            </svg>
          </button>

          <button onclick="goBottom()" id="myBtn" title="Go to top">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
              <path stroke-linecap="round" stroke-linejoin="round" d="M9 12.75l3 3m0 0l3-3m-3 3v-7.5M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
            </svg>
          </button>
        </div>

      </div>
    </footer>

    <script>
      MathJax
        .startup
        .document
        .getMathItemsWithin(document.body);
    </script>

  </body>
</html>