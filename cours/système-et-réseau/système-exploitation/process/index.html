<!DOCTYPE html>
<html lang="fr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>Process</title>

    <link href="/cours_informatique/assets/node_modules/prismjs/themes/prism-solarizedlight.css" rel="stylesheet">
    
    <link href="/cours_informatique/assets/node_modules/prismjs/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet">
    <script src="/cours_informatique/assets/node_modules/prismjs/plugins/line-numbers/prism-line-numbers.min.js"></script>

    <link href="/cours_informatique/assets/stylesheets/main.css" rel="stylesheet">

  </head>
  <body>
    <script>
      window.MathJax = {
        tex: {
          inlineMath: [
            [
              '$', '$'
            ],
            [
              '\\(', '\\)'
            ]
          ]
        },
        svg: {
          fontCache: 'global'
        }
      };

      function goTop() {
        window.scrollTo({top: 0});
      }
      function goBottom() {
        window.scrollTo({top: document.body.scrollHeight});
      }
    </script>
    <script type="text/javascript" id="MathJax-script" src="/cours_informatique/assets/node_modules/mathjax/es5/tex-svg-full.js"></script>

    <header class="border-b-2 border-gray-200 mb-4">
      <div class="max-w-[1200px] mx-auto px-4 relative">
        <div class="min-h-[50px] flex justify-between items-center">
          <a class="mx-2" href="/cours_informatique/">Home</a>
        </div>

        <div class="min-h-[50px] flex justify-center items-center absolute right-0 top-0">
          <a class="mx-2" href="/cours_informatique/about">About</a>
          <button onclick="goTop()" id="myBtn" title="Go to top">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
              <path stroke-linecap="round" stroke-linejoin="round" d="M15 11.25l-3-3m0 0l-3 3m3-3v7.5M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
            </svg>
          </button>

          <button onclick="goBottom()" id="myBtn" title="Go to top">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
              <path stroke-linecap="round" stroke-linejoin="round" d="M9 12.75l3 3m0 0l3-3m-3 3v-7.5M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
            </svg>
          </button>
        </div>

      </div>
    </header>

    <main class="max-w-[1200px] mx-auto px-4">
      
<article>

  <h1>Process</h1>
  <div>
    

    
  </div>

  

    
<div class="quote relative  py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-purple-500 bg-purple-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-purple-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M5 19a2 2 0 01-2-2V7a2 2 0 012-2h4l2 2h4a2 2 0 012 2v1M5 19h14a2 2 0 002-2v-5a2 2 0 00-2-2H9a2 2 0 00-2 2v5a2 2 0 01-2 2z"></path>
</svg>
<div class="pl-8 mr-8">

<a class="interne" href="/cours_informatique/cours/">Cours</a><span class="px-1">/</span><a class="interne" href="/cours_informatique/cours/système-et-réseau/">Système et réseau</a><span class="px-1">/</span><a class="interne" href="/cours_informatique/cours/système-et-réseau/système-exploitation/">Système d&#39;exploitation</a><span class="px-1">/</span><a class="interne" href="/cours_informatique/cours/système-et-réseau/système-exploitation/process/">Process</a>

</div></div>



    
  

  <p>Un process est l'unité de base d'un programme. Un process contient des données et des instructions pour être exécuté, le tout étant stocké en mémoire.</p>
<h2>Exécution d'un process</h2>
<p>Nous n'allons pas rentrer dans les détails sur ce qu'est une instruction. On y reviendra lorsque l'on parlera précisément des cores.</p>
<p>On va uniquement considérer ici qu'à chaque instruction est associé un byte et que le code d'un process, c'est à dire la suite d'instructions que devra effectuer le processeur, est un tableau <code>M</code> de byte.</p>
<p>L'exécution du process est alors déterminée par un entier <code>IP</code> (<em>instruction pointer</em>)tel que :</p>
<ol>
<li><code>IP</code> vaut initialement 1</li>
<li>le processeur :
<ol>
<li>lit l'instruction I de numéro <code>M[IP]</code></li>
<li>incrémente <code>IP</code></li>
<li>exécute l'instruction I</li>
</ol>
</li>
<li>si I est :
<ul>
<li>l'instruction de fin on stope l'exécution du process</li>
<li>une instruction de saut on affecte à <code>IP</code> la valeur du saut</li>
</ul>
</li>
<li>retour en 2.</li>
</ol>
<p>La variable <code>IP</code> est écrite directement sur le processeur. Sa taille est fixe (8B=64b) et sert uniquement à déterminer l'adresse de la prochaine instruction à effectuer.</p>
<p>Le processeur possède un certain nombre de ce type de variables, appelées <a href="https://fr.wikipedia.org/wiki/Registre_de_processeur">registres</a>. Ce sont des mémoire très rapides d'accès et qui permettent au processeur de fonctionner. Certains registres sont spécialisés et stockes des endroits d'intérêt dans la mémoire. Par exemple IP, mais également SP, ou encore l'adresse des syscall que l'on verra plus tard.</p>
<p>D'autres registres sont génériques et font office de variables locales lorsque l'on code en <a href="https://fr.wikipedia.org/wiki/Langage_machine">langage processeur</a> et servent d'endroit où stocker les paramètres d'instructions.</p>
<h2>Organisation en mémoire</h2>
<p>L'usage veut que l'on représente la mémoire comme une suite de byte allant de bas (adresse 0) en haut (adresse max). De plus, l'adresse est souvent donnée en <a href="https://fr.wikipedia.org/wiki/Syst%C3%A8me_hexad%C3%A9cimal">hexadécimal</a> car sa base est un multiple de 2 assez grand pour être compact et pas trop grand pour ne pas avoir trop de chiffre : <code>0xFF=255</code> et rempli un byte.</p>
<p><a href="https://en.wikipedia.org/wiki/X86-64#Virtual_address_space_details">https://en.wikipedia.org/wiki/X86-64#Virtual_address_space_details</a></p>
<h3>Instructions simples</h3>
<p>Si la seule instruction est d'afficher un retour à la ligne à l'écran, le code serait quelque chose du genre :</p>
<pre><code>0x6   : .
0x5   : .
0x4   : .
0x3   : .
0x2   : .
0x2   : exit
0x1   : print
0x0 :
</code></pre>
<div class="quote relative  py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-cyan-500 bg-cyan-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-cyan-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z"></path>
</svg>
<div class="pl-8 mr-8">
<p>Un process ne <strong>peut jamais</strong> commencer à 0 car une adresse de 0 signifie pas d'adresse (c'est le None de python, ou le null du C).</p>
</div></div>

<h3>Instructions avec paramètre</h3>
<p>Si l'on veut afficher &quot;Hello World&quot; à l'écran, il faut pouvoir stocker la chaîne de caractère &quot;Hello World&quot; dans la mémoire et demander à notre programme de l'afficher. Il ne peut en effet pas y avoir d'instruction différente pour chaque chaîne de caractère à afficher.</p>
<pre><code>0x10  : .
0x0F  : .
0x0E  : 0
0x0D  : 'd'
0x0C  : 'l'
0x0B  : 'r'
0x0A  : 'o'
0x09  : 'W'
0x08  : ' '
0x07  : 'o'
0x06  : 'l'
0x05  : 'l'
0x04  : 'e'
0x03  : 'H'
0x02  : exit
0x01  : print chaîne 3
0x00  :
</code></pre>
<p>L'instruction print est maintenant différente :</p>
<ul>
<li>lon lui demande d'afficher une chaîne de caractère. L'usage est d'afficher les caractères un à un à partir de l'adresse du premier caractère jusqu'à arriver au caractère valant 0.</li>
<li>l'adresse du premier caractère est 0x3</li>
</ul>
<p>La chaîne de caractère est nécessairement séparée du code pour éviter qu'il puisse être exécuté (c'est à dire convertir la chaîne de caractères en instructions).</p>
<p>Le process doit donc avoir au moins 2 parties distinctes :</p>
<ul>
<li>le <a href="https://en.wikipedia.org/wiki/Code_segment">segment de code</a>, aussi nommé <code>text</code></li>
<li>le <a href="https://en.wikipedia.org/wiki/Data_segment">segment de données</a></li>
</ul>
<pre><code>données
code
</code></pre>
<p>Chaque constante est adressée par son indice. Il faut donc que le code connaissent exactement la position de la constante en mémoire. Ceci n'est pas toujours possible car peut-être que le code n'est pas exécuté à partir de 0, ce qui casserait tout :</p>
<pre><code>0x14     : .
0x13     : .
0x12     : .
0x11     : .
0x05-10  : 'Hello World\0'
0x04     : exit
0x03     : print chaîne 3
0x02     : .
0x01     : .
0x00     : .
</code></pre>
<p>En revanche, le code connaît la position relative de la constante par rapport à son exécution, ici 3 + 2. Comme le pointeur IP pointe sur la <strong>prochaine instruction</strong>, le code suivant fonctionne donc toujours, le paramètre se trouve 2 cases plus loin que l'instruction courante donc 1 de plus que la prochaine instruction :</p>
<pre><code>0x14     : .
0x13     : .
0x12     : .
0x11     : .
0x05-10  : 'Hello World\0'
0x04     : exit
0x03     : print chaîne IP+1
0x02     : .
0x01     : .
0x00     : .
</code></pre>
<div class="quote relative  py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-cyan-500 bg-cyan-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-cyan-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z"></path>
</svg>
<div class="pl-8 mr-8">
<p>Les adresses de départ exactes sont modifiées aléatoirement par le système d'exploitation pour des raisons de sécurités.</p>
</div></div>

<p>Vous pourrez m'objecter, qu'il n'est pas possible d'avoir une commande différente pour chaque saut de paramètre. Cela ferait trop de commande.</p>
<p>Effectivement, ce n'est pas comme ça que c'est géré. On utilise des commandes de taille variables où :</p>
<ul>
<li>le premier byte détermine toujours l'instruction</li>
<li>le second contient le premier paramètre</li>
<li>le troisième le deuxième paramètre s'il y en a</li>
<li>ainsi de suite</li>
</ul>
<p>Comme le processeur les connaît, il incrémentera automatiquement le compteur d'instruction de la taille de l'instruction plus le nombre de ses paramètres. Notre code devient :</p>
<pre><code>0x15     : .
0x14     : .
0x13     : .
0x12     : .
0x11     : 'Hello World\0'
0x05-10  : exit
0x04     : 1
0x03     : print chaîne avec un paramètre
0x02     : .
0x01     : .
0x00     : .
</code></pre>
<div class="quote relative  py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-cyan-500 bg-cyan-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-cyan-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z"></path>
</svg>
<div class="pl-8 mr-8">
<p>Notez que le paramètre doit être de taille fixe (ici 1 byte) pour que tout fonctionne. Il n'est pas possible pour cette commande de faire des sauts de plus de 255 byte (il faudrait une autre commande qui prend un word à la place d'un byte comme paramètre)</p>
</div></div>

<p>Pour des raisons de lisibilité, nous n'allons pas recopier directement le code dans ce qui suit. On va utiliser des règles qui vont faciliter la lecture des programme et qui sont immédiatement transposable :</p>
<ul>
<li>nous n'allons plus numéroter les cases de la mémoire et écrire le programme dans l'ordre de lecture, de haut en bas</li>
<li>nous allons continuer à placer les paramètres dans le corps des commandes</li>
<li>nous allons marquer des labels dans le code pour nous rappeler de l'endroit où aller</li>
<li>on sépare clairement la partie code (nommée .text) de la partie donnée (nommée .data)</li>
<li>nous allons oublier l'instruction exit, lorsque l'on arrive à la fin du code, programme s'arrête</li>
</ul>
<pre><code>section .data

  hello DB &quot;Hello World&quot;, 0
data_F:                            ; facultatif

section .text

main:                              ; label d'adresse
    print chaîne hello
</code></pre>
<p>Le code précédent devient alors plus lisible sans perdre de sa généralité :</p>
<ul>
<li>les données sont listées les unes à la suite des autres et ont des noms (qui seront transcrit en décalage dans l'exécution) et des types : DB signifie un tableau de bytes.</li>
<li>le label <code>main:</code> est le label vers le début du code.</li>
</ul>
<p>Ceci donne en mémoire :</p>
<pre><code>data_F :
       : 0
       : 'd'
       : 'l'
       : 'r'
       : 'o'
       : 'W'
       : ' '
       : 'o'
       : 'l'
       : 'l'
       : 'e'
hello  : 'H'
         exit
main   : print chaîne hello
       :
...
0x0    :
</code></pre>
<h2>Du fichier au programme</h2>
<p>A priori tout programme peut fonctionner uniquement avec des instructions et des valeurs initiales, le étant déterminé pendant l'exécution.</p>
<p>Le fichier stockant le programme est donc uniquement composé des constantes et des instructions. S'il suit exactement ce principe :</p>
<pre><code>code
données
</code></pre>
<p>et que les appels aux constantes sont des déplacements relatifs, le code exécuté peut être stocké directement dans un fichier pour être réutilisé plus tard sans aucun changement.</p>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
</svg>
<div class="pl-8 mr-8">
<p>Le code en mémoire et le code fichier est identique identique</p>
</div></div>

<h2>Instructions avec variables</h2>
<p>Regardons le code python suivant :</p>
<pre class="language-python " style="counter-reset: linenumber 0"><code class="language-python"><span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
  <span class="token keyword">print</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>
</code></pre>
<div class="quote relative  py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-yellow-500 bg-yellow-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-yellow-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z"></path>
  <path stroke-linecap="round" stroke-linejoin="round" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path>
</svg>
<div class="pl-8 mr-8">
<p>Écrivez le code comme précédemment. En ajoutant des instructions</p>
<p>Rappelez-vous que le code :</p>
<ul>
<li>ne peut pas posséder de constantes.</li>
<li>les paramètres sont placés après l'appel à l'instruction</li>
</ul>
</div></div>

<div class="relative drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-indigo-500 bg-indigo-100">
<details class="group" open="">
<summary class="list-none py-0.5">
<svg class="group-open:hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M9 5l7 7-7 7"></path>
</svg>
<svg class="group-open:block hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7"></path>
</svg>
<div class="pl-8 font-bold inline-block">
<p>solution</p>
</div>
<svg class="group-open:hidden inline-block pl-3 w-10 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M5 12h.01M12 12h.01M19 12h.01M6 12a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0z"></path>
</svg>
</summary>
<div class="mx-8 pb-2">
<pre><code>section .data

i B 0

section .text

main:
    place 0 dans i
boucle:
    print byte [i]
    incrémente [i]
    si [i] &lt; 10 saute en boucle
</code></pre>
<p>On utilise <code>[i]</code> plutôt que i pour indiquer que l'on considère la valeur <code>M[i]</code> si M est le tableau en mémoire et pas l'adresse i.</p>
</div>
</details>     
</div>
<p>Outre le fait d'inventer des commandes plausibles (<code>print byte</code>, incrémente et l'instruction de saut), on a utilisé une case consacrée à nos données pour stocker une variable (la variable <code class="language-">i</code> du code python)</p>
<p>On remarque que la position de la variable dans la pile ne bouge pas</p>
<p>Ce nest pas très optimisé puisqu'on devra sauvegarder cette variable dans le fichier du code et alourdira inutilement notre fichier. de plus, <code class="language-">i</code> est une variable, elle ne devrait pas être présente dans le code &quot;en dur&quot; mais créée à la volé par le programme.</p>
<div class="quote relative  py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-cyan-500 bg-cyan-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-cyan-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z"></path>
</svg>
<div class="pl-8 mr-8">
<p>On pourrait utiliser un segment spécifique pour les données non initialisées, de nom de section <a href="https://en.wikipedia.org/wiki/.bss">bss</a>, mais son usage est très particulier et réservées aux variables globales.</p>
</div></div>

<h3>Utilisation d'une pile</h3>
<p>La gestion des variable est faite par une <a href="https://fr.wikipedia.org/wiki/Pile_(informatique)">pile</a></p>
<p>Commençons par voir comment tout ceci est fait avant de voir comment l'implémenter en mémoire.</p>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
</svg>
<div class="pl-8 mr-8">
<p>Une <strong><em>pile</em></strong> est une structure de donnée qui comprend deux fonctions :</p>
<ul>
<li>empilage(d) : ajoute l'élément d à la pile et rend son indice de stockage</li>
<li>dépilage() : supprime un élément à la pile</li>
<li>accès(i) : accède au i+1 ème élément de la pile en lecture ou en écriture</li>
</ul>
</div></div>

<p>Exemple :</p>
<pre class="language-python " style="counter-reset: linenumber 0"><code class="language-python">empile<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
empile<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>accès<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># rendra 2</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>accès<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># rendra 1</span>
dépile<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>accès<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># rendra 1</span>
</code></pre>
<p>Cette structure permet deux choses fondamentale :</p>
<ul>
<li>stocker et supprimer des choses</li>
<li>utiliser les éléments stockés car les accès ne vont pas bouger</li>
</ul>
<p>C'est exactement ce qu'il faut pour gérer des variables.</p>
<p>De plus, une pile se gère comme un tableau ! Soit SP un indice de la mémoire qui contient le dernier élément de la pile.</p>
<ul>
<li>Empiler le byte $x$ dans la pile revient à :
<ul>
<li>décrémenter l'indice SP</li>
<li>placer la valeur $x$ à l'endroit de la mémoire adressée par SP</li>
</ul>
</li>
<li>Accéder au $i+1$ élément de la pile revient à accéder à l'élément placé à SP + i dans la mémoire</li>
<li>Dépiler un élément de la pile revient à incrémenter SP</li>
</ul>
<p>Après les deux premières lignes du programme précédent on a :</p>
<pre><code>SP+1 :         1
SP   :         2
SP-1 :
</code></pre>
<p>De là le code complet est :</p>
<pre class="language-nasm " style="counter-reset: linenumber 0"><code class="language-nasm"><span class="token keyword">section .text</span>

<span class="token label function">main:</span>
    empile <span class="token number">0</span>
    empile <span class="token number">2</span>
    print byte <span class="token operator">[</span><span class="token register variable">SP</span><span class="token operator">]</span>
    print byte <span class="token operator">[</span><span class="token register variable">SP</span><span class="token operator">+</span><span class="token number">1</span><span class="token operator">]</span>
    dépile
    print byte <span class="token operator">[</span><span class="token register variable">SP</span><span class="token operator">]</span>
</code></pre>
<p>Pour continuer nos <a href="https://fr.wikipedia.org/wiki/Sucre_syntaxique">sucres syntaxiques</a> on utilise :</p>
<ul>
<li>SP pour donner la valeur de SP (c'est à dire un indice d'une case mémoire)</li>
<li>[SP] pour donner la valeur de la case mémoire d'indice SP (M[SP] si M est le tableau de mémoire)</li>
</ul>
<p>Ce concept est fondamental. Si vous avez compris, félicitations vous avez compris les pointeurs :</p>
<ul>
<li>SP est un pointeur (une adresse)</li>
<li>[SP] est la valeur pointée</li>
</ul>
<p>Il est tout à fait possible de n'utiliser que ces deux registres pour exécuter un ordinateur comme on le fait ici.</p>
<p>On peut calculer en calculant la <a href="https://fr.wikipedia.org/wiki/Notation_polonaise_inverse">notation polonaise inverse</a>, utiliser le langage <a href="https://fr.wikipedia.org/wiki/Forth_(langage)">Forth</a> ou encore lorsque vous <a href="https://www.fevrierdorian.com/carnet/pages/python-sous-le-capot-chapitre-1-fonctionnement-de-la-vm-cpython.html">exécutez des programmes python</a></p>
<p>Ce n'est cependant pas ce qui est fait usuellement car les registres sont d'accès bien plus rapide que la mémoire. Les processeurs possèdent tous un petit nombre de registres de taille fixe (on utilise majoritairement ceux de 64b mais il en existe de 8b à 128b, voir plus) utilisées pour les passages de paramètres et les retours de ses instructions.</p>
<h2>Process en mémoire avec pile</h2>
<pre><code>pile
...
...
données
code
</code></pre>
<p>La pile se remplit en diminuant de valeur. Elle commence à la plus haute adresse possible et ne peut aller plus bas que le dernier élément des données.</p>
<p>Le code (section text) commence à la plus petite valeur strictement positive possible (c'est plus que 1 à cause de la pagination. Pour une pagination de 4KiB, la première adresse possible est 0x1000).</p>
<p>La pile est nécessaire à l'exécution du programme mais pas pour sa conception. Le fichier contenant le programme ne contient pas la pile.</p>
<ul>
<li>Le pointeur de code est IP (<em>instruction pointer</em>), sa valeur vaut l'adresse de la prochaine instruction à exécuter</li>
<li>Le pointeur de pile est SP (<em>stack pointer</em>), sa valeur vaut l'adresse de la prochaine instruction à exécuter</li>
</ul>
<h3>Gestion des variables avec la pile</h3>
<p>Reprenons notre petite boucle python :</p>
<pre class="language-python " style="counter-reset: linenumber 0"><code class="language-python"><span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
  <span class="token keyword">print</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>
</code></pre>
<p>Et utilisons la pile pour gérer i :</p>
<pre><code>section .text

main:
    empile 0
boucle:
    print byte [SP]
    incrémente [SP]
    si [SP] &lt; 10 saute en boucle
    dépile
</code></pre>
<p>Où <code>incrémente [SP]</code> signifie <code>M[SP] += 1</code></p>
<ul>
<li>la variable i est créée par empilage et supprimée par dépilage.</li>
<li>c'est toujours le même accès au 1er élément de la pile</li>
</ul>
<p>Une variable est définie par sa visibilité dans le programme déterminé par le bloc dans le quel elle apparaît. Par exemple en python :</p>
<pre class="language-python " style="counter-reset: linenumber 0"><code class="language-python"><span class="token keyword">def</span> <span class="token function">f</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">:</span>
  code de f

<span class="token keyword">while</span> condition<span class="token punctuation">:</span>
  code
  <span class="token keyword">if</span> condition <span class="token number">2</span><span class="token punctuation">:</span>
    code du <span class="token keyword">if</span>
    appel de f

<span class="token keyword">for</span> <span class="token builtin">range</span><span class="token punctuation">:</span>
  code du <span class="token keyword">for</span>
  appel de f

</code></pre>
<p>Contient 4 blocs :</p>
<ul>
<li>le bloc du while</li>
<li>le bloc du if, qui est <strong>dans</strong> le bloc du while</li>
<li>le bloc du for</li>
<li>le bloc de la fonction, qui sera un sous-bloc du bloc du if et un sous-bloc du bloc du for</li>
</ul>
<p>Gérer les variables se fait alors comme suit :</p>
<ul>
<li>au début du bloc on crée toutes les variables du bloc en les empilant dans la pile</li>
<li>pendant l'exécution du bloc : on accède aux variables car on connaît leurs indices</li>
<li>à la fin du bloc : on supprime toutes les variables par dépilage</li>
</ul>
<p>Ceci permet de ne jamais stocker des variables inutiles et de toujours pouvoir accéder aux variables d'un bloc.</p>
<div class="quote relative  py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-yellow-500 bg-yellow-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-yellow-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z"></path>
  <path stroke-linecap="round" stroke-linejoin="round" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path>
</svg>
<div class="pl-8 mr-8">
<p>Écrivez le code suivant avec la pile et en utilisant les règles de création et de suppression des variables :</p>
<pre class="language-python " style="counter-reset: linenumber 0"><code class="language-python"><span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
  <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>i<span class="token operator">+</span>j<span class="token punctuation">)</span>
</code></pre>
</div></div>

<div class="relative drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-indigo-500 bg-indigo-100">
<details class="group">
<summary class="list-none py-0.5">
<svg class="group-open:hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M9 5l7 7-7 7"></path>
</svg>
<svg class="group-open:block hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7"></path>
</svg>
<div class="pl-8 font-bold inline-block">
<p>solution</p>
</div>
<svg class="group-open:hidden inline-block pl-3 w-10 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M5 12h.01M12 12h.01M19 12h.01M6 12a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0z"></path>
</svg>
</summary>
<div class="mx-8 pb-2">
<p>On crée une variable pour chaque bloc :</p>
<pre class="language-nasm " style="counter-reset: linenumber 0"><code class="language-nasm"><span class="token keyword">section .text</span>

<span class="token label function">main:</span>
    empile <span class="token number">0</span>
<span class="token label function">boucle:</span>
    empile <span class="token number">0</span>
<span class="token label function">boucle2:</span>
    print byte <span class="token operator">[</span><span class="token register variable">SP</span><span class="token operator">+</span><span class="token number">1</span><span class="token operator">]</span> <span class="token operator">+</span> <span class="token operator">[</span><span class="token register variable">SP</span><span class="token operator">]</span>
    incrémente <span class="token operator">[</span><span class="token register variable">SP</span><span class="token operator">]</span>
    <span class="token register variable">si</span> <span class="token operator">[</span><span class="token register variable">SP</span><span class="token operator">]</span> <span class="token operator">&lt;</span> <span class="token number">20</span> saute en boucle2
    dépile
    incrémente <span class="token operator">[</span><span class="token register variable">SP</span><span class="token operator">]</span>
    <span class="token register variable">si</span> <span class="token operator">[</span><span class="token register variable">SP</span><span class="token operator">]</span> <span class="token operator">&lt;</span> <span class="token number">10</span> saute en boucle
    dépile
</code></pre>
<p>On aurait aussi pu créer les deux variables en une fois :</p>
<pre class="language-nasm " style="counter-reset: linenumber 0"><code class="language-nasm"><span class="token keyword">section .text</span>

<span class="token label function">main:</span>
    empile <span class="token number">0</span>
    empile <span class="token number">0</span>
<span class="token label function">boucle:</span>
    print byte <span class="token operator">[</span><span class="token register variable">SP</span><span class="token operator">+</span><span class="token number">1</span><span class="token operator">]</span> <span class="token operator">+</span> <span class="token operator">[</span><span class="token register variable">SP</span><span class="token operator">]</span>
    incrémente <span class="token operator">[</span><span class="token register variable">SP</span><span class="token operator">]</span>
    <span class="token register variable">si</span> <span class="token operator">[</span><span class="token register variable">SP</span><span class="token operator">]</span> <span class="token operator">&lt;</span> <span class="token number">20</span> saute en boucle
    place dans <span class="token operator">[</span><span class="token register variable">SP</span><span class="token operator">]</span> la valeur <span class="token number">0</span>
    incrémente <span class="token operator">[</span><span class="token register variable">SP</span><span class="token operator">+</span><span class="token number">1</span><span class="token operator">]</span>
    <span class="token register variable">si</span> <span class="token operator">[</span><span class="token register variable">SP</span><span class="token operator">+</span><span class="token number">1</span><span class="token operator">]</span> <span class="token operator">&lt;</span> <span class="token number">10</span> saute en boucle
    dépile
</code></pre>
<p>Cette dernière implémentation combine les deux boucle for en une seule boucle</p>
</div>
</details>     
</div>
<h3>Appels de fonctions</h3>
<p>La pile, si pratique pour gérer toutes nos variables est également d'une efficacité redoutable pour gérer les appels de fonctions.</p>
<p>Prenons le code python :</p>
<pre class="language-python " style="counter-reset: linenumber 0"><code class="language-python"><span class="token keyword">def</span> <span class="token function">ma_fct</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>x<span class="token operator">+</span>i<span class="token punctuation">)</span>

<span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
  ma_boucle<span class="token punctuation">(</span>i<span class="token punctuation">)</span>
</code></pre>
<p>Et écrivons ce programme avec la pile :</p>
<pre class="language-nasm " style="counter-reset: linenumber 0"><code class="language-nasm"><span class="token keyword">section .text</span>

<span class="token label function">main:</span>
    empile <span class="token number">0</span>
<span class="token label function">boucle:</span>
    empile <span class="token operator">[</span><span class="token register variable">SP</span><span class="token operator">]</span>                           <span class="token comment">; paramètre</span>
    empile retour                         <span class="token comment">; retour de la fonction</span>
    saut ma_fct
<span class="token label function">retour:</span>
    dépile                                <span class="token comment">; supprime le retour</span>
    dépile                                <span class="token comment">; supprime le paramètre</span>
    incrémente <span class="token operator">[</span><span class="token register variable">SP</span><span class="token operator">]</span>
    <span class="token register variable">si</span> <span class="token operator">[</span><span class="token register variable">SP</span><span class="token operator">]</span> <span class="token operator">&lt;</span> <span class="token number">10</span> saute en boucle
    dépile
    saute en fin
<span class="token label function">ma_fct:</span>
    empile <span class="token number">0</span>                              <span class="token comment">; variable de la fonction</span>
<span class="token label function">fct_boucle:</span>
    print byte <span class="token operator">[</span><span class="token register variable">SP</span><span class="token operator">+</span><span class="token number">2</span><span class="token operator">]</span> <span class="token operator">+</span> <span class="token operator">[</span><span class="token register variable">SP</span><span class="token operator">]</span>              <span class="token comment">; SP+2 contient l'argument</span>
    incrémente <span class="token operator">[</span><span class="token register variable">SP</span><span class="token operator">]</span>
    <span class="token register variable">si</span> <span class="token operator">[</span><span class="token register variable">SP</span><span class="token operator">]</span> <span class="token operator">&lt;</span> <span class="token number">20</span> saute en fct_boucle
    dépile
    saute en <span class="token operator">[</span><span class="token register variable">SP</span><span class="token operator">]</span>
<span class="token label function">fin:</span>
</code></pre>
<p>La pile nous a permis de stocker les paramètres et le saut de retour de la fonction. En appliquant le même principe pour toutes les fonctions :</p>
<ul>
<li>empilage du saut de retour</li>
<li>empilage des paramètres</li>
<li>saut vers la fonction</li>
<li>dépilage des paramètres</li>
<li>dépilage de la valeur de saut de retour</li>
</ul>
<p>On a crée un moyen simple et efficace de gérer des fonctions (c'est même récursif !) C'est ce qu'o appelle une <a href="https://en.wikipedia.org/wiki/X86_calling_conventions#x86-64_calling_conventions">ABI</a>.</p>
<p>Les processeurs possèdent souvent deux instructions pour gérer l'appel (mais pas les paramètres) des fonctions :</p>
<ul>
<li><code>call adresse</code> : empile IP (qui vaut l'instruction suivante, donc le retour) puis saute à l’adresse demandée</li>
<li><code>ret</code> : qui saute en [SP] puis dépile.</li>
</ul>
<p>Les appelles et retour de fonctions ont souvent leurs propres instructions qui gèrent le saut, l'empilage et le dépilage de la valeur de retour.</p>
<h3>Limitation de la pile</h3>
<p>La pile est un moyen efficace de gérer les variables et les appels de fonctions. Elle possède cependant un inconvénient :</p>
<ul>
<li>on ne peut y placer que des élément dont on connaît la taille</li>
<li>une fois la variable dans la pile, sa taille ne peut plus changer.</li>
</ul>
<p>On ne peut mettre que des choses pas trop grosse, la taille globale de la pile est relativement petite (10MiB), et dont on connaît la taille. De plus une fois que la donnée est dans la pile on ne peut plus modifier sa taille.</p>
<h4>Taille inconnue</h4>
<p>Si l'on demande à un utilisateur de taper un texte, ou si l'on veut récupérer le contenu d'une page web on ne peut être sur de la taille nécessaire pour contenir le résultat : cela va dépendre du moment où l'on exécute le code.</p>
<p>On ne peut donc pas dans ce cas là réserver une plage de byte dans la pile pour stocker cette variable, elle peut, selon la page chargée ou le texte tapée être aussi grande que l'on veut.</p>
<h4>Taille changeante</h4>
<pre class="language-python " style="counter-reset: linenumber 0"><code class="language-python">x <span class="token operator">=</span> <span class="token number">0</span>
<span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
  x <span class="token operator">+=</span> i
  <span class="token keyword">print</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>
</code></pre>
<div class="quote relative  py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-yellow-500 bg-yellow-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-yellow-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z"></path>
  <path stroke-linecap="round" stroke-linejoin="round" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path>
</svg>
<div class="pl-8 mr-8">
<p>Écrivez le code associé au programme ci-dessus en supposant que x est un byte</p>
</div></div>

<div class="relative drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-indigo-500 bg-indigo-100">
<details class="group">
<summary class="list-none py-0.5">
<svg class="group-open:hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M9 5l7 7-7 7"></path>
</svg>
<svg class="group-open:block hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7"></path>
</svg>
<div class="pl-8 font-bold inline-block">
<p>solution</p>
</div>
<svg class="group-open:hidden inline-block pl-3 w-10 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M5 12h.01M12 12h.01M19 12h.01M6 12a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0z"></path>
</svg>
</summary>
<div class="mx-8 pb-2">
<pre class="language-nasm " style="counter-reset: linenumber 0"><code class="language-nasm"><span class="token keyword">section .text</span>

<span class="token label function">main:</span>
    empile <span class="token number">0</span>
    empile <span class="token number">0</span>
<span class="token label function">boucle:</span>
    place dans <span class="token register variable">SP</span><span class="token operator">+</span><span class="token number">1</span> la valeur <span class="token operator">[</span><span class="token register variable">SP</span><span class="token operator">]</span> <span class="token operator">+</span> <span class="token operator">[</span><span class="token register variable">SP</span><span class="token operator">+</span><span class="token number">1</span><span class="token operator">]</span>
    print byte <span class="token operator">[</span><span class="token register variable">SP</span><span class="token operator">+</span><span class="token number">1</span><span class="token operator">]</span>
    incrémente <span class="token operator">[</span><span class="token register variable">SP</span><span class="token operator">]</span>
    <span class="token register variable">si</span> <span class="token operator">[</span><span class="token register variable">SP</span><span class="token operator">]</span> <span class="token operator">&lt;</span> <span class="token number">100</span> saute en boucle
    dépile
    dépile
</code></pre>
</div>
</details>     
</div>
<p>A un moment donné la valeur de $x$ stockée dans la pile à l'adresse A de la mémoire va déborder en A+1.</p>
<ul>
<li>si on a de la chance, cela va aller au-delà de la mémoire adressable et le programme va planter</li>
<li>sin on a pas de la chance, on a mis $x$ avant $i$ en pile et le fait de faire grossir $x$ va déborder sur l'endroit où est stocké $i$ et donc le modifier. La boucle va faire n'importe quoi et accrochez vous pour trouver le bug.</li>
</ul>
<h2>Tas</h2>
<p>Pour palier les limitations de la pile il faut ajouter la possibilité de réserver de la mémoire pour y stocker des choses. Il faut bien sûr prendre de la mémoire qui ne sert pas au process : entre la fin des données et le début de la pile.</p>
<p>Cette mémoire utilisée par le processus qui n'est ni des données, ni du code ni la pile est appelée <strong><em>tas</em></strong>. On a alors un schéma de ce type en mémoire :</p>
<pre><code>pile
...
...
tas
données
code
</code></pre>
<p>Au départ, le tas est vide, mais le programme peut le remplir. Prenons le squelette de code ci-après :</p>
<pre class="language-nasm " style="counter-reset: linenumber 0"><code class="language-nasm"><span class="token keyword">section .data</span>

    ...      <span class="token comment">; ici toutes les déclarations de données</span>

début_tas:

<span class="token keyword">section .text</span>

<span class="token label function">main:</span>

    ...   <span class="token comment">; ici le code</span>

<span class="token label function">fin_code:</span>

<span class="token label function">main:</span>
</code></pre>
<ul>
<li>les données commencent à la fin du code, donc à l'adresse <code>fin_code</code></li>
<li>le tas commence à la fin des données, donc au label <code>début_tas</code> et augmente avec des adresses croissantes.</li>
</ul>
<p>Le tas peut théoriquement aller jusqu'au début de la pile. En pratique ce n'est pas le cas, c'est le système d'exploitation qui contrôle sa taille (via l'appel système brk). Ceci permet de contrôler la mémoire que prend un process lorsqu'il y a plusieurs process sur un système (tout le temps en fait).</p>
<h3>Utilisation du tas</h3>
<p>Les données stockées dans le tas sont déterminées par leur adresse. En connaissant leur type on peut les manipuler comme les autres variable, à une indirection prêt. Allons-y :</p>
<p>Comme toutes les variables sont stockées dans la pile, la variable qui représente une donnée du tas sera son adresse. De là :</p>
<ol>
<li>soit x l'adresse d'un byte stockée sur le tas.</li>
<li>on l'empile : <code>[SP]</code> (la valeur <code>M[SP]</code>) vaut x</li>
<li>la valeur du byte stocké dans le tas vaut : <code>[[SP]]</code> (<code>M[x] = M[M[SP]]</code>).</li>
</ol>
<p>À vous :</p>
<div class="quote relative  py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-yellow-500 bg-yellow-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-yellow-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z"></path>
  <path stroke-linecap="round" stroke-linejoin="round" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path>
</svg>
<div class="pl-8 mr-8">
<p>Utilisez le tas pour stocker la variable $i$ du code python suivant :</p>
<pre class="language-python " style="counter-reset: linenumber 0"><code class="language-python"><span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
  <span class="token keyword">print</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>
</code></pre>
</div></div>

<div class="relative drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-indigo-500 bg-indigo-100">
<details class="group">
<summary class="list-none py-0.5">
<svg class="group-open:hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M9 5l7 7-7 7"></path>
</svg>
<svg class="group-open:block hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7"></path>
</svg>
<div class="pl-8 font-bold inline-block">
<p>solution</p>
</div>
<svg class="group-open:hidden inline-block pl-3 w-10 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M5 12h.01M12 12h.01M19 12h.01M6 12a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0z"></path>
</svg>
</summary>
<div class="mx-8 pb-2">
<pre class="language-nasm " style="counter-reset: linenumber 0"><code class="language-nasm"><span class="token keyword">section .data</span>

    ...      <span class="token comment">; ici toutes les déclarations de données</span>

début_tas:

<span class="token keyword">section .text</span>

<span class="token label function">main:</span>
    empile début_tas
    affecte <span class="token number">0</span> à l'adresse <span class="token operator">[</span><span class="token register variable">SP</span><span class="token operator">]</span>
    print byte <span class="token operator">[</span><span class="token operator">[</span><span class="token register variable">SP</span><span class="token operator">]</span><span class="token operator">]</span>
    <span class="token register variable">si</span> <span class="token operator">[</span><span class="token operator">[</span><span class="token register variable">SP</span><span class="token operator">]</span><span class="token operator">]</span> <span class="token operator">&lt;</span> <span class="token number">10</span> saute en main
    dépile
<span class="token label function">fin_code:</span>

<span class="token label function">main:</span>
</code></pre>
</div>
</details>     
</div>
<h3>Limitation du tas</h3>
<p>Le tas est un endroit de stockage vierge et libre. Il faut se souvenir de qui à stocké quoi dedans sous peine de faire n'importe quoi.</p>
<h2>Bibliothèques partagées</h2>
<div class="quote relative py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-emerald-500 bg-emerald-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-emerald-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
  <path stroke-linecap="round" stroke-linejoin="round" d="M13.19 8.688a4.5 4.5 0 011.242 7.244l-4.5 4.5a4.5 4.5 0 01-6.364-6.364l1.757-1.757m13.35-.622l1.757-1.757a4.5 4.5 0 00-6.364-6.364l-4.5 4.5a4.5 4.5 0 001.242 7.244"></path>
</svg>
<div class="pl-8 mr-8">
<p><a href="https://en.wikipedia.org/wiki/Shared_library">https://en.wikipedia.org/wiki/Shared_library</a></p>
</div></div>

<p>Il manque encore une chose à notre process. La fonction <code>print</code> et ses avatars <code>print chaîne</code> et <code>print byte</code> sont complexes. Elles ne peuvent être des opération du processeur qui ne fait que des choses basique comme additionner des trucs, sauter à des endroit ou mettre des choses à des adresses précises.</p>
<p>Cette fonction a été écrite par quelqu'un d'autre qui la met à notre disposition. Elle est de plus tellement pratique que quasi tous les processus vont l'utiliser. Une telle bibliothèque existe, c'est la <a href="https://fr.wikipedia.org/wiki/GNU_C_Library">libc</a> (quasi tous les processus d'une machine Linux vont utiliser des fonctions de cette bibliothèque).</p>
<p>On appelle ces bibliothèques des <strong><em>bibliothèques partagées</em></strong>. Ce sont les <code>.dll</code> de windows, les <code>.so</code> de Linux et les <code>.dylib</code> de Macos.</p>
<p>Il n'est pas nécessaire de stocker le code de ces bibliothèques dans notre fichier de code, plein de place serait gaspillée puisque cette bibliothèque se retrouverait dans tous les fichiers, il suffit que l'ordinateur en possède une copie.</p>
<h3>Bibliothèque partagée en mémoire</h3>
<p>La bibliothèque est un ensemble de fonctions. Elles sont placées entre le tas et la pile :</p>
<pre><code>pile
...
fonctions partagées
...
tas
données
code
</code></pre>
<ul>
<li>Le tas ne peut croître (le tas augmente vers les adresses de plus en pus grandes) au delà du début des fonctions partagées</li>
<li>la pile ne peut croître (la pile augmente vers les adresses de plus en pus petite) au delà de la fin des fonctions partagées</li>
</ul>
<h3>Bibliothèque partagée dans le fichier du programme</h3>
<p>Il faut ajouter au début du fichier des informations sur :</p>
<ul>
<li>les bibliothèques partagées utilisées</li>
<li>l'endroit dans le code o¨elle sont utilisées</li>
</ul>
<p>Lorsque l'OS chargera le fichier, il analysera cette partie puis :</p>
<ul>
<li>placera la bibliothèque partagée en mémoire</li>
<li>remplacera dans le code tous les sauts vers des fonctions de la bibliothèque par l'endroit en mémoire où ces fonctions ont été placées</li>
</ul>
<h2><span id="forme-finale"></span>Forme finale d'un process</h2>
<p>En mémoire, l'OS ajoute devant chaque groupe d'adresse (une page) ce que le process à le droit de faire :</p>
<ul>
<li>exécuter : uniquement placé pour la section code</li>
<li>lire/écrire : la section données, la pile et le tas</li>
<li>lire : les bibliothèques partagées (si le tas ou la pile déborde, cela fait planter le process)</li>
</ul>
<p>On a alors quelque chose du genre :</p>
<pre><code>pile                   ; droit de lecture et d'écriture
...
fonctions partagées    ; droit de lecture
...
tas                    ; droit de lecture et d'écriture
données                ; droit de lecture et d'écriture
code                   ; droit d'exécution et de lecture
</code></pre>
<h3>Sur le disque dur</h3>
<p>Le fichier contient l'ensemble des sections text et data plus des données de relocalisation pour les bibliothèques partagées.</p>
<p>Le format de fichier Linux pour les ficher est le format <a href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format">elf : executable and linkable format</a></p>
<div class="quote relative py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-emerald-500 bg-emerald-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-emerald-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
  <path stroke-linecap="round" stroke-linejoin="round" d="M13.19 8.688a4.5 4.5 0 011.242 7.244l-4.5 4.5a4.5 4.5 0 01-6.364-6.364l1.757-1.757m13.35-.622l1.757-1.757a4.5 4.5 0 00-6.364-6.364l-4.5 4.5a4.5 4.5 0 001.242 7.244"></path>
</svg>
<div class="pl-8 mr-8">
<p>Format elf :</p>
<ul>
<li><a href="https://www.youtube.com/watch?v=nC1U1LJQL8o">un tuto</a></li>
<li><a href="https://linux-audit.com/elf-binaries-on-linux-understanding-and-analysis/">le détail</a></li>
</ul>
</div></div>

<p>relocation des la bibliothèque partagée</p>
<h3>pile et tas quand les utiliser</h3>
<ul>
<li>tas : grosses données et/ou taille inconnue au départ</li>
<li>tas : partageable entre fonctions : modifie des pointeurs</li>
<li>pile rapide mais : taille connu et petit (10MiB)</li>
</ul>
<h2>Variables et données d'un process</h2>
<p>Cette partie est à retenir, elle est cruciale pour comprendre comment sont organisées les programmes en C.</p>
<h3>Constantes et données globales</h3>
<p>sans la section data. Stockées dans le fichier du programme. Il faut donc qu'elles soient de taille connues : le programme stockant directement la constante ou laisse assez de place pour stocker les données globales.</p>
<h3>Variables</h3>
<p>Les variables sont utilisées dans des blocs de codes. Elles sont :</p>
<ol>
<li>de taille fixe et connue</li>
<li>stockées dans la pile</li>
</ol>
<p>Une variable est soit :</p>
<ul>
<li>une donnée et sa taille est 1, 2, 4 ou 8 byte. Les données pouvant être :
<ul>
<li>un entier</li>
<li>un réel</li>
<li>un caractère</li>
<li>une adresse mémoire</li>
</ul>
</li>
<li>un tableau de données regroupe un nombre <strong>fixe</strong> de donnée dans un espace contiguë en mémoire</li>
<li>une structure regroupant un nombre fixé de données ou de tableaux.</li>
</ul>
<p>La taille des variable doit être connue à l'écriture du code. De plus la pile étant souvent de taille réduite (10MiB) par rapport la totalité de la mémoire disponible (plusieurs GiB), on réservera cette approche (variable = tableau) pour les <em>petit</em> tableaux.</p>
<h3>Mémoire</h3>
<p>Lorsque les tableaux que l'on veut créer ne sont pas de taille fixe, ou trop grand pour être considéré comme une variable, on procède avec une indirection :</p>
<ul>
<li>la donnée est stockée dans le tas</li>
<li>la variable représentant cette donnée est son adresse de début dans le tas</li>
</ul>
<p>La taille de la variable est fixe : 8B tout en conservant une taille variable de la donnée.</p>
<h2>Thread</h2>
<p>Un process continent :</p>
<ul>
<li>un environnement mémoire</li>
<li>un ou plusieurs threads qui exécutent le code</li>
</ul>
<p>Chaque thread possède un pointeur IP et une pile qui lui est propre (ainsi que son BP associé), cela s'appelle un <strong><em>contexte d'exécution</em></strong> le reste est partagé avec les autres threads du process. Plusieurs threads ne peuvent pas écrire dans la pile de l'autres mais peuvent se partager les variables du tas et de la section donnée.</p>
<p>Le process est une organisation d'un programme, le thread son exécution.</p>
<p>L'intérêt est que l'OS peut exécuter plusieurs thread d'un process de façon concurrente pour aider à l'exécution du process.</p>
<p>Par exemple pour un jeu :</p>
<ul>
<li>un thread dédié à l'affichage graphique</li>
<li>un thread pour gérer le serveur</li>
<li>un thread pour gérer le monde</li>
</ul>
<p>Ou plus prosaïquement pour multiplier deux matrice, plusieurs thread peuvent chacun calculer un élément du produit sans se gêner.</p>


</article>
    </main>

    <footer class="min-h-[50px] border-t-2 border-gray-200 mt-4">
      <div class="max-w-[1200px] mx-auto px-4 relative">
        <div class="min-h-[50px] flex justify-center items-center">
          <p>
            Cours d'informatique de François Brucker
          </p>
        </div>
        <div class="min-h-[50px] flex justify-center items-center absolute right-0 top-0">
          <button onclick="goTop()" id="myBtn" title="Go to top">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
              <path stroke-linecap="round" stroke-linejoin="round" d="M15 11.25l-3-3m0 0l-3 3m3-3v7.5M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
            </svg>
          </button>

          <button onclick="goBottom()" id="myBtn" title="Go to top">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
              <path stroke-linecap="round" stroke-linejoin="round" d="M9 12.75l3 3m0 0l3-3m-3 3v-7.5M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
            </svg>
          </button>
        </div>

      </div>
    </footer>

    <script>
      MathJax
        .startup
        .document
        .getMathItemsWithin(document.body);
    </script>

  </body>
</html>