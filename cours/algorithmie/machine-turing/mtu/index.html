<!DOCTYPE html>
<html lang="fr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>Machine de Turing universelle</title>

    <link href="/cours_informatique/assets/node_modules/prismjs/themes/prism-solarizedlight.min.css" rel="stylesheet">
    <link href="/cours_informatique/assets/node_modules/prismjs/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet">

    <link href="/cours_informatique/assets/stylesheets/main.css" rel="stylesheet">

  </head>
  <body>
    <script>
      window.MathJax = {
        tex: {
          inlineMath: [
            [
              '$', '$'
            ],
            [
              '\\(', '\\)'
            ]
          ]
        },
        svg: {
          fontCache: 'global'
        }
      };

      function goTop() {
        window.scrollTo({top: 0});
      }
      function goBottom() {
        window.scrollTo({top: document.body.scrollHeight});
      }
    </script>
    <script type="text/javascript" id="MathJax-script" src="/cours_informatique/assets/node_modules/mathjax/es5/tex-svg-full.js"></script>

    <header class="border-b-2 border-gray-200 mb-4">
      <div class="max-w-[1200px] mx-auto px-4 relative">
        <div class="min-h-[50px] flex justify-between items-center">
          <a class="mx-2" href="/cours_informatique/">Home</a>
        </div>

        <div class="min-h-[50px] flex justify-center items-center absolute right-0 top-0">
          <a class="mx-2" href="/cours_informatique/about">About</a>
          <button onclick="goTop()" id="myBtn" title="Go to top">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
              <path stroke-linecap="round" stroke-linejoin="round" d="M15 11.25l-3-3m0 0l-3 3m3-3v7.5M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
            </svg>
          </button>

          <button onclick="goBottom()" id="myBtn" title="Go to top">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
              <path stroke-linecap="round" stroke-linejoin="round" d="M9 12.75l3 3m0 0l3-3m-3 3v-7.5M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
            </svg>
          </button>
        </div>

      </div>
    </header>

    <main class="max-w-[1200px] mx-auto px-4">
      
<article>

  <h1>Machine de Turing universelle</h1>
  <div>
    

    
  </div>

  

    
<div class="quote relative  py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-purple-500 bg-purple-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-purple-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M5 19a2 2 0 01-2-2V7a2 2 0 012-2h4l2 2h4a2 2 0 012 2v1M5 19h14a2 2 0 002-2v-5a2 2 0 00-2-2H9a2 2 0 00-2 2v5a2 2 0 01-2 2z"></path>
</svg>
<div class="pl-8 mr-8">

<a class="interne" href="/cours_informatique/cours/">Cours</a><span class="px-1">/</span><a class="interne" href="/cours_informatique/cours/algorithmie/">Algorithmie</a><span class="px-1">/</span><a class="interne" href="/cours_informatique/cours/algorithmie/machine-turing/">Machine de Turing</a><span class="px-1">/</span><a class="interne" href="/cours_informatique/cours/algorithmie/machine-turing/mtu/">Machine de Turing universelle</a>

</div>
</div>


    
  

  <p>Ce qui différencie une machine de Turing d'une autre c'est la fonction de transition.</p>
<p>Un des résultats les plus surprenant de Turing est qu'en fait on ne peut construire qu'<strong>une seule machine</strong> qui simulera toutes les autres. Cette machine est appelée <a href="https://fr.wikipedia.org/wiki/Machine_de_Turing_universelle">Machine de Turing universelle</a> et possède deux paramètres, le premier, $M$ représentant le programme d'une machine de Turing et le second $E$ une entrée.</p>
<p>Nous allons dans cette partie faire deux choses :</p>
<ol>
<li>encoder une machine de Turing sous la forme d'une suite de <code>0</code> et de <code>1</code></li>
<li>écrire une machine, nommée <a href="https://fr.wikipedia.org/wiki/Machine_de_Turing_universelle">Machine de Turing Universelle</a> (MTU), qui prend ses encodages en paramètre et les exécute</li>
</ol>
<div class="quote relative  py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-cyan-500 bg-cyan-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-cyan-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z"></path>
</svg>
<div class="pl-8 mr-8">
<p>Nous utiliserons ici dès que nous le pourrons et sans perte de généralité les <a href="../d%C3%A9finitions-alternatives/#MT-01#">Machines de Turing <code>01#</code></a> ce qui nous permettra, entre autres, d'avoir plusieurs paramètres d'entrée.</p>
</div>
</div>
<h2>code associé à une machine</h2>
<p>Une machine de Turing $M$, est définie par sa fonction de transition. Coder $M$ revient à lui associer de façon bijective une suite binaire, il faut donc un moyen d'encoder les 3 fonctions constituant la fonction de transition :</p>
<ul>
<li>$\delta_e: Q \times \{1, 0\} \mapsto Q$</li>
<li>$\delta_c: Q \times \{1, 0\} \mapsto \{1, 0\}$</li>
<li>$\delta_d: Q \times \{1, 0\} \mapsto \{\leftarrow, \rightarrow\}$</li>
</ul>
<p>Par des suites de <code>0</code> et de <code>1</code>.</p>
<h3>Encodage</h3>
<p>Pour cela considérons les bijections :</p>
<ul>
<li>$\phi_q: Q \mapsto [\![ 0, |Q|-1]\!]$ telle que :
<ul>
<li>$\phi_q(\text{START}) = 0$</li>
<li>$\phi_q(\text{STOP}) = 1$</li>
</ul>
</li>
<li>$\phi_d: \{\leftarrow, \rightarrow\} \mapsto \{0, 1\}$ telle que :
<ul>
<li>$\phi_d(\leftarrow) = 0$</li>
<li>$\phi_d(\rightarrow) = 1$</li>
</ul>
</li>
</ul>
<p>Encoder une transition par un quintuplet :</p>
<p>$$<br>
T(q, r) = (\phi_q(q), r, \phi_q(\delta_e(q, r)), \delta_c(q, r), \phi_d(\delta_d(q, r)))<br>
$$</p>
<p>Et finalement associer à la fonction de transition le tableau constitué de la concaténation ($+$ est ici l'opération de concaténation des tableaux):</p>
<p>$$<br>
T = T(q_0, 0) + T(q_0, 1) + \dots + T(q_i, 0) + T(q_i, 1) + \dots + T(q_{|Q|-1}, 0) + T(q_{|Q|-1}, 1)<br>
$$</p>
<p>On a alors les correspondances :</p>
<ul>
<li>$\delta_e(q, r) = T[5 \cdot (k + r) + 2]$</li>
<li>$\delta_c(q, r) = T[5 \cdot (k + r) + 3]$</li>
<li>$\delta_d(q, r) = T[5 \cdot (k + r) + 4]$</li>
</ul>
<p>Avec $k$ le plus petit indice tel que $T[5\cdot k] = \phi_q(q)$</p>
<p>Par exemple, <a href="../d%C3%A9finitions/#exemple-oscillation" class="interne">la machine oscillation</a> pourra par exemple être encodée par :</p>
<div>
$$
\begin{array}{rl}
T = (0, 0, 2, 0, 0,\\
     0, 1, 0, 0, 0, & \text{quintuplet jamais utilisé} \\
     1, 0, 0, 0, 0, & \text{quintuplet jamais utilisé} \\
     1, 1, 0, 0, 0, & \text{quintuplet jamais utilisé} \\
     2, 0, 3, 1 , 1,\\
     2, 1, 0, 0, 0,& \text{quintuplet jamais utilisé} \\
     3, 0, 4, 0, 1,\\
     3, 1, 3, 1, 1,\\
     4, 0, 1, 1, 0,\\
     4, 1, 3, 1, 1)\\
\end{array}
$$
</div>
<p>Il nous reste à transformer cette liste d'entiers en suite de <code>0</code> et de <code>1</code>. Chaque entier peut évidemment s'écrire sous sa forme binaire, ce qui donne pour l'oscillateur :</p>
<div>
$$
\begin{array}{rl}
T = (0, 0, 10, 0, 0,\\
     0, 1, 0, 0, 0, \\
     1, 0, 0, 0, 0,\\
     1, 1, 0, 0, 0, \\
     10, 0, 11, 1 , 1,\\
     10, 1, 0, 0, 0, \\
     11, 0, 100, 0, 1,\\
     11, 1, 11, 1, 1,\\
     100, 0, 1, 1, 0,\\
     100, 1, 11, 1, 1)\\
\end{array}
$$
</div>
<p>Mais il nous faut aussi encoder la virgule ce qui nous fait 3 symboles à encoder avec seulement des <code>0</code> et des <code>1</code>.</p>
<p>On utilise alors l'astuce classique d'encoder :</p>
<ul>
<li><code>0</code> par <code>00</code>,</li>
<li><code>1</code> par <code>01</code>,</li>
<li><code>,</code> par <code>11</code>.</li>
</ul>
<p>Ce qui double la taille des nombre (on lit un chiffre sur 2) mais permet d'encoder nos 3 caractères. On a alors pour l'oscillateur :</p>
<div>
$$
\begin{array}{rl}
T = 0011001101001100110011\\
    00110111001100110011 \\
    01110011001100110011\\
    01110111001100110011\\
    010011001101011101110111\\
    0100110111001100110011 \\
    01011100110100001100110111\\
    010111011101011101110111\\
    010000110011011101110011\\
    010000110111010111011101\\
\end{array}
$$
</div>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
</svg>
<div class="pl-8  mb-2 mr-8">
<p><strong>Définition</strong></p>
</div><div class="pl-8 mr-8">
<p>On note $&lt;M&gt;$ l'encodage de la fonction de transition associé à la machine de Turing $M$.</p>
</div>
</div>
<h3>Décodage</h3>
<p>Pour le décodage, on peut supposer qu'on le fait avec une machine de Turing <code>01#</code> à plusieurs rubans, donc on examine les couples $T[2i:2(i+1)]$ pour tous les $i$ de façons croissante et on associe dans un autre ruban :</p>
<ul>
<li><code>0</code> à <code>00</code>,</li>
<li><code>1</code> à <code>01</code>,</li>
<li><code>#</code> à <code>11</code>.</li>
</ul>
<p>À la fin de cette opération on aura le tableau représentant la machine dans un ruban dédié. Pour l'oscillateur cela donnerait :</p>
<pre><code>ruban      : 0#0#10#0#0#0#1#0#0#0#1#0#0#0#0#1#1#0#0#0#10#0#11#1#1#10#1#0#0#0#11#0#100#0#1#11#1#11#1#1#100#0#1#1#0#100#1#11#1#1
transition : 0 0        0 1       1 0       1 1        2 0         2 1        3 0          3 1          4 0         4 1
indice     : 0 1 2  3 4 0 1 2 3 4 0 1 2 3 4 0 1 2 3 4  0 1  2 3 4  0 1 2 3 4  0 1   2 3 4  0 1  2 3 4   0 1 2 3 4   0 1  2 3 4
</code></pre>
<h2><span id="MTU"></span> Machine de Turing Universelle (MTU)</h2>
<h3><span id="pseudo-code-MTU"></span>Algorithme</h3>
<p>Le pseudo-code ci-après décrit le principe d'une machine de Turing universelle.</p>
<pre><code>Nom : MTU
Entrées : 
    T : une fonction de transition sous la forme d'un tableau
    E : une suite de 0 et de 1
Programme :
    Soit R un ruban initialement rempli par E et un curseur c qui pointe sur une le premier caractère de E.
    q = 0

    Tant que q ≠ 1:
      Soit r la valeur de la case du ruban pointée par c    

      Trouver le plus petit k tel que T[5k] = q
      Si on ne trouve pas k:
        rendre 0

      écrire T[5(k+r) + 3] sur R
      déplacer le curseur à droite si T[5(k+r) + 4] == 1 et vers la gauche sinon
      q = T[5(k+r) + 2]

    Rendre R
</code></pre>
<p>On voit que la MTU va simuler toute machine de Turing encodée par T et si le tableau T n'est pas une machine elle s'arrête immédiatement. Enfin, la complexité d'exécution est identique à celle la machine originelle :</p>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
</svg>
<div class="pl-8  mb-2 mr-8">
<p><strong>Proposition</strong></p>
</div><div class="pl-8 mr-8">
<p>La complexité de l'exécution de <code class="language-">MTU(T, E)</code> est la même que celle de <code class="language-">T(E)</code></p>
</div>
</div>
<div class="relative drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-indigo-500 bg-indigo-100">
<details class="group" open="">
<summary class="list-none py-0.5">
<svg class="group-open:hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M9 5l7 7-7 7"></path>
</svg>
<svg class="group-open:block hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7"></path>
</svg>
<div class="pl-8 font-bold inline-block">
<p>preuve</p>
</div>
<svg class="group-open:hidden inline-block pl-3 w-10 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M5 12h.01M12 12h.01M19 12h.01M6 12a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0z"></path>
</svg>
</summary>
<div class="mx-8 pb-2">
<p>En effet, le seul changement est le parcours des différents états pour trouver la prochaine transition : chaque transition sera effectuée en un temps proportionnel qu nombre d'état de la machine.</p>
<p>Comme le nombre d'état est une constante pour la machine <code>T</code> : la complexité est la même.</p>
</div>
</details>     
</div>
<p>La machine de Turing Universelle est donc un outil très puissant :</p>
<ol>
<li>elle permet d'exécuter n'importe quelle machine avec une complexité identique</li>
<li>si l'encodage passer en entrée n'est pas une machine on ne trouve pas de transition et la MTU s'arrête immédiatement</li>
</ol>
<p>Enfin, on peut facilement n'exécuter que $k$ opération d'une machine donnée avec la variation suivante de la MTU :</p>
<pre><code>Nom : K-MTU
Entrées :
    T : un tableau de 0 et de 1
    E : une suite de 0 et de 1
    K : un entier
Programme :
    Soit R un ruban initialement rempli par E et un curseur c qui pointe sur une le premier caractère de E.
    q = 0

    Tant que q ≠ 1 et K &gt; 0:
      Soit r la valeur de la case du ruban pointée par c    
      Trouver le plus petit k tel que T[5k] = q
      Si on ne trouve pas k:
        rendre 0

      écrire T[5(k+r) + 3] sur R
      déplacer le curseur à droite si T[5(k+r) + 4] == 1 et vers la gauche sinon
      q = T[5(k+r) + 2]

      K = K-1

    Si q == 1:
      Rendre R
    Sinon:
      Rendre 0
</code></pre>
<p>La machine <code>K-MTU</code> exécute au maximum K-opérations d'une machine de Turing.<br>
Ceci permet de justifier rigoureusement l'algorithme de <a href="../../recherche-universelle">la recherche universelle</a> que l'on a précédemment vu.</p>
<h3>Création effective</h3>
<p>Pour terminer la preuve, il nous reste à montrer que le pseudo-code précédent et T peuvent être converti en une machine de Turing et son entrée.</p>
<p>Ceci est plus facile qu'attendu car on peut simuler une <a href="../d%C3%A9finitions-alternatives/#MT-01#" class="interne">machines de Turing <code>01#</code></a> à plusieurs rubans par une machine de Turing.</p>
<p>Commençons par voir le nombre de rubans qu'il nous faudrait pour être bien :</p>
<ul>
<li>pour la machine à simuler, on peut demander 6 rubans :
<ul>
<li><code>R-S</code> : un ruban contenant le ruban de la machine simulée</li>
<li>cinq rubans permettant de stocker la transition :
<ul>
<li><code>R-T0</code> : un ruban contenant les éléments $E[5\cdot k]$ séparé par des <code>#</code></li>
<li><code>R-T1</code> : un ruban contenant les éléments $E[5\cdot k + 1]$ séparé par des <code>#</code></li>
<li><code>R-T2</code> : un ruban contenant les éléments $E[5\cdot k + 2]$ séparé par des <code>#</code></li>
<li><code>R-T3</code> : un ruban contenant les éléments $E[5\cdot k + 3]$ séparé par des <code>#</code></li>
<li><code>R-T4</code> : un ruban contenant les éléments $E[5\cdot k + 4]$ séparé par des <code>#</code></li>
</ul>
</li>
</ul>
</li>
<li>pour le simulateur 2 rubans supplémentaires devraient suffire :
<ul>
<li>un ruban <code>R-Q</code> pour stocker l'état courant <code>q</code> : On supposera que le curseur est toujours placé au début de l'état. On initialisera ce ruban en recopiant le premier élément de l'entrée $E$</li>
<li><code>R-I</code> : un dernier ruban pour les opérations internes de la MTU</li>
</ul>
</li>
</ul>
<p>Enfin, il faut adapter le pseudo-code de la MTU à notre machine. Ceci est aisé puisque :</p>
<ul>
<li>les différents paramètres sont des chaînes formées des caractères <code>0</code> et <code>1</code> séparées par 1 caractères <code>#</code> qui ne sont utilisé que comme séparateur</li>
<li>dés que l'on rencontre la chaîne  <code>##</code>, on est en bout de ruban (la suite à gauche ou à droite sera uniquement composées de <code>#</code>)</li>
<li>on peut bouger les curseurs de façon indépendante et donc avec des sous-programmes qui ne manipulent que certains rubans.</li>
</ul>
<p>On obtient alors l'algorithme ci-après qui est une écriture de l’algorithme de la MTU sous une forme où chaque étape est facilement implémentable avec une machine de Turing <code>01#</code> :</p>
<ol>
<li>Initialisation. Elle peut aisément être fait par une machine de Turing qui dispatche l'entrée sur les différents rubans
<ol>
<li>Le ruban <code>R-Q</code> contient la chaîne <code>0</code>. Son curseur est placé sur le caractère non <code>#</code> le plus à gauche</li>
<li>le ruban <code>R-T0</code> contient tous les éléments $E[5\cdot k]$, de $k=0$ jusqu'au premier élément $k_\max$ tel que $E[5\cdot k_\max] = \sharp$. Son curseur est placé sur le caractère non <code>#</code> le plus à gauche</li>
<li>le ruban <code>R-T1</code> contient tous les éléments $E[5\cdot k + 1]$, de $k=0$ jusqu'au premier élément $k_\max$ tel que $E[5\cdot k_\max + 1] = \sharp$. Son curseur est placé sur le caractère non <code>#</code> le plus à gauche</li>
<li>le ruban <code>R-T2</code> contient tous les éléments $E[5\cdot k + 2]$, de $k=0$ jusqu'au premier élément $k_\max$ tel que $E[5\cdot k_\max + 2] = \sharp$. Son curseur est placé sur le caractère non <code>#</code> le plus à gauche</li>
<li>le ruban <code>R-T3</code> contient tous les éléments $E[5\cdot k + 3]$, de $k=0$ jusqu'au premier élément $k_\max$ tel que $E[5\cdot k_\max + 3] = \sharp$. Son curseur est placé sur le caractère non <code>#</code> le plus à gauche</li>
<li>le ruban <code>R-T4</code> contient tous les éléments $E[5\cdot k + 4]$, de $k=0$ jusqu'au premier élément $k_\max$ tel que $E[5\cdot k_\max + 4] = \sharp$. Son curseur est placé sur le caractère non <code>#</code> le plus à gauche</li>
<li>le rubans <code>R-S</code> contient <code>E</code> et le curseur est placé sur le premier caractère non <code>#</code> le plus à gauche.</li>
<li>le ruban <code>R-I</code> est initialement vide.</li>
</ol>
</li>
<li>Trouver la transition courante :
<ol>
<li>recopier le paramètre du ruban <code>R-Q</code> sur <code>R-I</code> se décaler d'un cran à droite sur <code>R-I</code> et se replacer au début du paramètre sur <code>R-Q</code></li>
<li>recopier le paramètre du ruban <code>R-T0</code> sur <code>R-I</code> se décaler sur la gauche sur <code>R-I</code> jusqu'à être au début du ruban (à gauche du curseur il y a deux caractères <code>#</code> à la suite) et se replacer au début du paramètre sur <code>R-T0</code></li>
<li>exécuter un programme qui s'arrête sur un <code>1</code> sur <code>R-I</code> si les deux paramètres du ruban <code>R-I</code> sont égaux et qui s'arrête sur un <code>0</code> sinon</li>
<li>Si le résultat vaut <code>0</code> :
<ol>
<li>effacer le ruban <code>R-I</code></li>
<li>décaler les rubans <code>R-T0</code> à <code>R-T4</code> d'un paramètre à droite</li>
</ol>
</li>
<li>Si le résultat vaut <code>1</code> :
<ol>
<li>si la valeur du ruban de <code>R-S</code> vaut la valeur sur le ruban <code>R-T1</code>, aller en 3.</li>
<li>sinon décaler les rubans <code>R-T0</code> à <code>R-T4</code> d'un paramètre à droite et retour en 2.</li>
</ol>
</li>
</ol>
</li>
<li>Faire la transition courante sur <code>R-S</code>
<ol>
<li>nouvel état : efface le ruban <code>R-Q</code> et écriture du paramètre de <code>R-T2</code> sur <code>R-Q</code></li>
<li>écriture du ruban : écriture de la case sous <code>R-T3</code> sur <code>R-S</code></li>
<li>déplacement du ruban : déplacement de <code>R-S</code> vers la droite si la case du ruban <code>R-T4</code> vaut <code>1</code> et déplacement vers la gauche sinon</li>
</ol>
</li>
<li>Retour au début des paramètres pour les rubans <code>R-Q</code> et de <code>R-T0</code> à <code>R-T4</code> (à gauche de chaque curseur il y a deux caractères <code>#</code> à la suite)</li>
<li>retour en 2.</li>
</ol>
<h2>Conclusion</h2>
<p>Nous venons de faire un ordinateur avec une machine de Turing ! La machine de Turing est tout à la fois un programme et une machine pour exécuter automatiquement des programmes.</p>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
</svg>
<div class="pl-8  mb-2 mr-8">
<p><strong>Théorème fondamental de l'algorithmie</strong></p>
</div><div class="pl-8 mr-8">
<p>On peut encoder toute machine de Turing $M$ par une chaîne $&lt;M&gt;$ composée de <code>0</code> et de <code>1</code>, de telle sorte que l'exécution de la machine de Turing universelle $\text{MTU}(&lt;M&gt;, E)$ simule l'exécution de $M$ avec une entrée $E$ avec la même complexité.</p>
</div>
</div>
<p>La machine de Turing universelle est donc <a href="https://fr.wikipedia.org/wiki/Anneau_unique">la machine qui les gouverne toutes</a> : une machine qui permet de simuler efficacement toutes les autres machine.</p>
<p>Il suffit de construire une seule machine pour avoir toutes les machines de Turing possible via leur encodage.</p>


</article>
    </main>

    <footer class="min-h-[50px] border-t-2 border-gray-200 mt-4">
      <div class="max-w-[1200px] mx-auto px-4 relative">
        <div class="min-h-[50px] flex justify-center items-center">
          <p>
            Cours d'informatique à l'école centrale Marseille
          </p>
        </div>
        <div class="min-h-[50px] flex justify-center items-center absolute right-0 top-0">
          <button onclick="goTop()" id="myBtn" title="Go to top">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
              <path stroke-linecap="round" stroke-linejoin="round" d="M15 11.25l-3-3m0 0l-3 3m3-3v7.5M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
            </svg>
          </button>

          <button onclick="goBottom()" id="myBtn" title="Go to top">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
              <path stroke-linecap="round" stroke-linejoin="round" d="M9 12.75l3 3m0 0l3-3m-3 3v-7.5M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
            </svg>
          </button>
        </div>

      </div>
    </footer>

    <script>
      MathJax
        .startup
        .document
        .getMathItemsWithin(document.body);
    </script>

  </body>
</html>