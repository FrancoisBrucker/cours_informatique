<!DOCTYPE html>
<html lang="fr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>Fonctions booléennes et pseudo-code</title>

    

    <link href="https://prismjs.catppuccin.com/latte.css" rel="stylesheet">

    <link href="/cours_informatique/assets/node_modules/prismjs/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet">
    <script src="/cours_informatique/assets/node_modules/prismjs/plugins/line-numbers/prism-line-numbers.min.js"></script>
    
    <link href="/cours_informatique/assets/stylesheets/main.css" rel="stylesheet">

  </head>
  <body>
    <script>
      window.MathJax = {
        tex: {
          inlineMath: [
            [
              '$', '$'
            ],
            [
              '\\(', '\\)'
            ]
          ]
        },
        svg: {
          fontCache: 'global'
        }
      };

      function goTop() {
        window.scrollTo({top: 0});
      }
      function goBottom() {
        window.scrollTo({top: document.body.scrollHeight});
      }
    </script>
    <script type="text/javascript" id="MathJax-script" src="/cours_informatique/assets/node_modules/mathjax/es5/tex-svg-full.js"></script>

    <header class="border-b-2 border-gray-200 mb-4">
      <div class="max-w-[1200px] mx-auto px-4 relative">
        <div class="min-h-[50px] flex justify-between items-center">
          <a class="mx-2" href="/cours_informatique/">Home</a>
        </div>

        <div class="min-h-[50px] flex justify-center items-center absolute right-0 top-0">
          <a class="mx-2" href="/cours_informatique/about">About</a>
          <button onclick="goTop()" id="myBtn" title="Go to top">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
              <path stroke-linecap="round" stroke-linejoin="round" d="M15 11.25l-3-3m0 0l-3 3m3-3v7.5M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
            </svg>
          </button>

          <button onclick="goBottom()" id="myBtn" title="Go to top">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
              <path stroke-linecap="round" stroke-linejoin="round" d="M9 12.75l3 3m0 0l3-3m-3 3v-7.5M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
            </svg>
          </button>
        </div>

      </div>
    </header>

    <main class="max-w-[1200px] mx-auto px-4">
      
<article>

  <h1>Fonctions booléennes et pseudo-code</h1>
  <div>
    

    
  </div>

  

    
<div class="quote relative  py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-purple-500 bg-purple-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-purple-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M5 19a2 2 0 01-2-2V7a2 2 0 012-2h4l2 2h4a2 2 0 012 2v1M5 19h14a2 2 0 002-2v-5a2 2 0 00-2-2H9a2 2 0 00-2 2v5a2 2 0 01-2 2z"></path>
</svg>
<div class="pl-8 mr-8">

<a class="interne" href="/cours_informatique/cours/">Cours</a><span class="px-1">/</span><a class="interne" href="/cours_informatique/cours/algorithmie/">Algorithmie</a><span class="px-1">/</span><a class="interne" href="/cours_informatique/cours/algorithmie/fonctions-booléennes/">Fonctions booléennes et pseudo-code</a>

</div></div>



    
  

  <blockquote>
<p>TBD chapeau</p>
</blockquote>
<p><a href="../bases-th%C3%A9oriques/calculabilit%C3%A9/#algorithme-fonction" class="interne">On a vu</a> qu'un algorithme était une fonction $f: \{0, 1\}^\star \rightarrow \{0, 1\}^\star$. Nous allons voir celles que l'on peut décrire par <a href="../pseudo-code/" class="interne">un pseudo-code</a>.</p>
<h2>Fonctions booléennes vectorielles</h2>
<p><span id="définition-fonction-booléenne"></span></p>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
</svg>
<div class="pl-8 mb-2 mr-8">
<p><strong>Définition</strong></p>
</div><div class="pl-8 mr-8">
<p>Une <strong><em>fonction booléenne</em></strong> est une fonction</p>
<div>
$$
f: \{0, 1\}^n \rightarrow \{0, 1\}
$$
</div>
<blockquote>
<p>TBD exemple de la projection</p>
<p>Et une <strong><em>fonction booléenne vectorielle</em></strong> est une fonction booléenne qui rend un vecteur :</p>
</blockquote>
<div>
$$
f: \{0, 1\}^n \rightarrow \{0, 1\}^m
$$
</div>
</div></div>

<blockquote>
<p>TBD exemple de la duplication</p>
</blockquote>
<h3>Fonctions logiques</h3>
<p>Parmi les fonctions booléennes, les fonctions $f: \{0, 1\} \rightarrow \{0, 1\}$ et $f: \{0, 1\}^2 \rightarrow \{0, 1\}$ sont appelées <strong><em>opérateurs logiques</em></strong>.</p>
<h4>Fonctions à un bit</h4>
<p>Il y a 4 fonctions différentes dont l'entrée est réduite à 1 bit :</p>
<ul>
<li>la fonction identité définie telle que $id(x) = x$ pour tout $x$,</li>
<li>la fonction $\mathbb{1}$ définie telle que $\mathbb{1}(x) = 1$ pour tout $x$,</li>
<li>la fonction $\mathbb{0}$ définie telle que $\mathbb{0}(x) = 0$ pour tout $x$,</li>
<li>la fonction négation définie telle que $\text{NOT}(0) = \neg 0 = \overline{0} = 1$ et $\text{NOT}(1) = \neg 1 = \overline{1} = 0$</li>
</ul>
<h4>Fonctions à deux bits</h4>
<p>On les décrit avec leurs On les représentent via leurs <a href="https://fr.wikipedia.org/wiki/Table_de_v%C3%A9rit%C3%A9">tables de vérité</a> :</p>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
</svg>
<div class="pl-8 mb-2 mr-8">
<p><strong>Définition</strong></p>
</div><div class="pl-8 mr-8">
<p>On décrit les 3 fonctions $f: \{0, 1\}^2 \rightarrow \{0, 1\}$ <strong><em>OU</em></strong>, <strong><em>ET</em></strong> <strong><em>OU exclusif</em></strong> comme étant :</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">OU</th>
<th style="text-align:center">ET</th>
<th style="text-align:center">OU exclusif</th>
</tr>
<tr>
<th style="text-align:center">x</th>
<th style="text-align:center">y</th>
<th style="text-align:center">OR(x, y)</th>
<th style="text-align:center">AND(x, y)</th>
<th style="text-align:center">XOR(x, y)</th>
</tr>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">$x \lor y$</th>
<th style="text-align:center">$x \land y$</th>
<th style="text-align:center">$x \oplus y$</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
</tr>
</tbody>
</table>
</div></div>

<p>Nous n'en avons décrit que 3 parmi les 16 possibles car il est possible de toutes les obtenir en combinant les fonctions NON, OU et ET. Par exemple :</p>
<div>
$$
x \oplus y = (x \lor y) \land \overline{x \land y}
$$
</div>
<div class="quote relative py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-orange-500 bg-orange-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-orange-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M8.228 9c.549-1.165 2.03-2 3.772-2 2.21 0 4 1.343 4 3 0 1.4-1.278 2.575-3.006 2.907-.542.104-.994.54-.994 1.093m0 3h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
<div class="pl-8 mr-8">
<p>Démontrez que :</p>
<div>
$$
x \oplus y = (x \lor y) \land \overline{x \land y}
$$
</div>
</div></div>

<div class="relative drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-indigo-500 bg-indigo-100">
<details class="group">
<summary class="list-none py-0.5">
<svg class="group-open:hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M9 5l7 7-7 7"></path>
</svg>
<svg class="group-open:block hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7"></path>
</svg>
<div class="pl-8 font-bold inline-block">
<p>corrigé</p>
</div>
<svg class="group-open:hidden inline-block pl-3 w-10 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M5 12h.01M12 12h.01M19 12h.01M6 12a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0z"></path>
</svg>
</summary>
<div class="mx-8 pb-2">
<p>On le fait avec une table :</p>
<table>
<thead>
<tr>
<th style="text-align:center">x</th>
<th style="text-align:center">y</th>
<th style="text-align:center">$x \lor y$</th>
<th style="text-align:center">$\overline{x \land y}$</th>
<th style="text-align:center">$x \oplus y$</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
</tbody>
</table>
</div>
</details>     
</div>
<p>On peut maintenant terminer le travail :</p>
<div class="quote relative py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-orange-500 bg-orange-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-orange-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M8.228 9c.549-1.165 2.03-2 3.772-2 2.21 0 4 1.343 4 3 0 1.4-1.278 2.575-3.006 2.907-.542.104-.994.54-.994 1.093m0 3h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
<div class="pl-8 mr-8">
<p>Montrer que toute fonction de $\{0, 1\}^2 \rightarrow \{0, 1\}$ peut s'écrire comme combinaison des fonctions $\text{NOT}(x)$, $\text{AND}(x, y)$, et $\text{OR}(x, y)$.</p>
</div></div>

<div class="relative drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-indigo-500 bg-indigo-100">
<details class="group">
<summary class="list-none py-0.5">
<svg class="group-open:hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M9 5l7 7-7 7"></path>
</svg>
<svg class="group-open:block hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7"></path>
</svg>
<div class="pl-8 font-bold inline-block">
<p>corrigé</p>
</div>
<svg class="group-open:hidden inline-block pl-3 w-10 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M5 12h.01M12 12h.01M19 12h.01M6 12a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0z"></path>
</svg>
</summary>
<div class="mx-8 pb-2">
<p>Il y a 16 possibilités de fonctions :</p>
<table>
<thead>
<tr>
<th>x</th>
<th>y</th>
<th>01</th>
<th>02</th>
<th>03</th>
<th>04</th>
<th>05</th>
<th>06</th>
<th>07</th>
<th>08</th>
<th>09</th>
<th>10</th>
<th>11</th>
<th>12</th>
<th>13</th>
<th>14</th>
<th>15</th>
<th>16</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>On a :</p>
<ul>
<li>la fonction $f_i = \overline{f_{i+8}}$ pour $1\leq i \leq 8$</li>
<li>$f_1$ est la fonction constante valant 0</li>
<li>$f_{2+8}(x, y)$ est la fonction $x \lor y$</li>
<li>$f_{3}(x, y) = f_{4}(y, x)$ et $f_{3+8}$ est la fonction $\bar{x} \lor y$</li>
<li>$f_{5}(x, y)$ est la fonction $x \land y$</li>
<li>$f_{6}(x, y)$ est la fonction $\bar{y}$</li>
<li>$f_{7 + 8}(x, y)$ est la fonction $x$</li>
<li>$f_{8 + 8}(x, y)$ est la fonction $(x \land \bar{y}) \lor (\bar{x} \land y)$</li>
</ul>
</div>
</details>     
</div>
<p>Vous savez quoi, on peut même faire mieux en utilisant la fonction $\text{NAND}(x, y)$.</p>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
</svg>
<div class="pl-8 mb-2 mr-8">
<p><strong>Définition</strong></p>
</div><div class="pl-8 mr-8">
<p>La fonction $\text{NAND}(x, y)$ est définie telle que :</p>
<div>
$$
\text{NAND}(x, y) \coloneqq \overline{x \land y}
$$
</div>
</div></div>

<p>On peut tout retrouver grâce à elle :</p>
<div class="quote relative py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-orange-500 bg-orange-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-orange-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M8.228 9c.549-1.165 2.03-2 3.772-2 2.21 0 4 1.343 4 3 0 1.4-1.278 2.575-3.006 2.907-.542.104-.994.54-.994 1.093m0 3h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
<div class="pl-8 mr-8">
<p>Montrer que toute fonction de $\{0, 1\}^2 \rightarrow \{0, 1\}$ peut s'écrire comme combinaison de la fonction $\text{NAND}(x, y)$.</p>
</div></div>

<div class="relative drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-indigo-500 bg-indigo-100">
<details class="group">
<summary class="list-none py-0.5">
<svg class="group-open:hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M9 5l7 7-7 7"></path>
</svg>
<svg class="group-open:block hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7"></path>
</svg>
<div class="pl-8 font-bold inline-block">
<p>corrigé</p>
</div>
<svg class="group-open:hidden inline-block pl-3 w-10 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M5 12h.01M12 12h.01M19 12h.01M6 12a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0z"></path>
</svg>
</summary>
<div class="mx-8 pb-2">
<p>Il suffit de montrer que l'on peut reconstruire $\text{NOT}(x)$, $\text{AND}(x, y)$, $\text{OR}(x, y)$ et $\text{XOR}(x, y)$ avec $\text{NAND}(x, y)$ :</p>
<ul>
<li>$\text{NOT}(x) = \text{NAND}(x, x)$</li>
<li>$\text{AND}(x, y) = \text{NOT}(\text{NAND}(x, y))$</li>
<li>$\text{OR}(x, y) = \text{NAND}(\text{NOT}(x), \text{NOT}(y))$</li>
<li>$\text{XOR}(x, y) = \text{NAND}(\text{NAND}(x, \text{NAND}( x, y )), \text{NAND}(x, \text{NAND}( x, y )))$ :</li>
</ul>
</div>
</details>     
</div>
<p>Fun fact, cela fonctionne aussi avec une autre fonction :</p>
<div class="quote relative py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-orange-500 bg-orange-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-orange-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M8.228 9c.549-1.165 2.03-2 3.772-2 2.21 0 4 1.343 4 3 0 1.4-1.278 2.575-3.006 2.907-.542.104-.994.54-.994 1.093m0 3h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
<div class="pl-8 mr-8">
<p>Montrer que l'on peut expliciter la fonction $\text{NAND}(x, y)$ avec la fonction $\text{NOR}(x, y) \coloneqq \overline{x \lor y}$.</p>
</div></div>

<div class="relative drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-indigo-500 bg-indigo-100">
<details class="group">
<summary class="list-none py-0.5">
<svg class="group-open:hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M9 5l7 7-7 7"></path>
</svg>
<svg class="group-open:block hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7"></path>
</svg>
<div class="pl-8 font-bold inline-block">
<p>corrigé</p>
</div>
<svg class="group-open:hidden inline-block pl-3 w-10 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M5 12h.01M12 12h.01M19 12h.01M6 12a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0z"></path>
</svg>
</summary>
<div class="mx-8 pb-2">
<ul>
<li>$\text{NOT}(x) = \text{NOR}(x, x)$</li>
<li>$\text{NAND}(x, y) = \text{NOT}(\text{NOR}(x, y))$</li>
</ul>
</div>
</details>     
</div>
<h4>Généralisation</h4>
<p>Commençons par résoudre l'exercice suivant</p>
<div class="quote relative py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-orange-500 bg-orange-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-orange-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M8.228 9c.549-1.165 2.03-2 3.772-2 2.21 0 4 1.343 4 3 0 1.4-1.278 2.575-3.006 2.907-.542.104-.994.54-.994 1.093m0 3h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
<div class="pl-8 mr-8">
<p>En utilisant sa table de vérité, montrez que toute fonction booléenne peut s'écrire sous une <a href="https://fr.wikipedia.org/wiki/Forme_normale_disjonctive">forme normale disjonctive</a>.</p>
</div></div>

<div class="relative drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-indigo-500 bg-indigo-100">
<details class="group">
<summary class="list-none py-0.5">
<svg class="group-open:hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M9 5l7 7-7 7"></path>
</svg>
<svg class="group-open:block hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7"></path>
</svg>
<div class="pl-8 font-bold inline-block">
<p>corrigé</p>
</div>
<svg class="group-open:hidden inline-block pl-3 w-10 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M5 12h.01M12 12h.01M19 12h.01M6 12a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0z"></path>
</svg>
</summary>
<div class="mx-8 pb-2">
<p>Soit $f(x_1, \dots, x_n)$ une fonction de $\{0, 1\}^n$ dans $\{0, 1\}$.</p>
<p>À tout élément $y=(y_1, \dots, y_n)$ de $\{0, 1\}^n$ on peut associer la fonction $l^y(x) = l^y_1(x) \land \dots \land l^y_i(x) \land \dots \land l^y_n(x)$ où $l^y_i(x) = x_i$ si $y_i = 1$ et $l^y_i(x) = \overline{x_i}$ sinon pour tout $x=(x_1, \dots, x_n)$. La fonction $f$ est alors égale à :</p>
<div>
$$
f(x) = \lor \{l^y(x) | f(y) = 1\} = \bigvee_{f(y) = 1} (l^y_1(x) \land \dots \land l^y_i(x) \land \dots \land l^y_n(x))
$$
</div>
</div>
</details>     
</div>
<p>On peut utiliser l'exercice précédent pour montrer que l'on peut aussi écrire une fonction booléenne sous <a href="../probl%C3%A8me-SAT/" class="interne">une forme normale conjonctive, comme une formule SAT</a>, sans utiliser d'artifice compliqué :</p>
<p><span id="proposition-CNF-fonction"></span></p>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
</svg>
<div class="pl-8 mb-2 mr-8">
<p><strong>Proposition</strong></p>
</div><div class="pl-8 mr-8">
<p>Toute fonction booléenne $f$ de $\{0, 1\}^n$ dans $\{0, 1\}$ peut s'écrire sous <a href="https://fr.wikipedia.org/wiki/Forme_normale_conjonctive">forme normale conjonctive</a> avec autant de clauses que de vecteurs $(x_1, \dots, x_n)$ tel que $f(x_1, \dots, x_n) = 0$.</p>
</div></div>

<div class="relative drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-indigo-500 bg-indigo-100">
<details class="group" open="">
<summary class="list-none py-0.5">
<svg class="group-open:hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M9 5l7 7-7 7"></path>
</svg>
<svg class="group-open:block hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7"></path>
</svg>
<div class="pl-8 font-bold inline-block">
<p>preuve</p>
</div>
<svg class="group-open:hidden inline-block pl-3 w-10 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M5 12h.01M12 12h.01M19 12h.01M6 12a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0z"></path>
</svg>
</summary>
<div class="mx-8 pb-2">
<p>On utilise le fait que $\overline{a\land b} = \overline{a}\lor \overline{b}$ et que $\overline{a\lor b} = \overline{a}\land \overline{b}$ et on reprenant la fonction $l^y(x)$ définie dans le corrigé de l'exercice précédent. On a :</p>
<div>
$$
f(x) = \overline{\bigvee_{f(y) = 0} (l^y_1(x) \land \dots \land l^y_i(x) \land \dots \land l^y_n(x))} = \bigwedge_{f(y) = 0} (\overline{l^y_1(x)} \lor \dots \lor \overline{l^y_i(x)} \lor \dots \lor \overline{l^y_n(x)})
$$
</div>
</div>
</details>     
</div>
<p>Ce résultat s'étant aux fonctions booléennes vectorielles :</p>
<p><span id="proposition-CNF-fonction-vect"></span></p>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
</svg>
<div class="pl-8 mb-2 mr-8">
<p><strong>Proposition</strong></p>
</div><div class="pl-8 mr-8">
<p>Toute fonction booléenne vectorielle $f$ de $\{0, 1\}^n$ dans $\{0, 1\}^m$ peut s'écrire sous une forme normale conjonctive $f(x_1, \dots, x_n, y_1, \dots y_m)$ telle que $f(x_1, \dots, x_n, y_1, \dots y_m)$ est vraie si et seulement si $f(x_1, \dots, x_n) = (y_1, \dots y_m)$</p>
</div></div>

<div class="relative drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-indigo-500 bg-indigo-100">
<details class="group" open="">
<summary class="list-none py-0.5">
<svg class="group-open:hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M9 5l7 7-7 7"></path>
</svg>
<svg class="group-open:block hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7"></path>
</svg>
<div class="pl-8 font-bold inline-block">
<p>preuve</p>
</div>
<svg class="group-open:hidden inline-block pl-3 w-10 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M5 12h.01M12 12h.01M19 12h.01M6 12a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0z"></path>
</svg>
</summary>
<div class="mx-8 pb-2">
<p>La fonction booléenne vectorielle $f$ peut s'écrire comme $m$ fonction booléennes $f_i$ de de $\{0, 1\}^n$ dans $\{0, 1\}$ tel que f(x) = (f_1(x), \dots, f_m(x))$. En utilisant le théorème précédent, on a que :</p>
<div>
$$
f_i(x) = \overline{\bigvee_{f_i(y) = 0} (l^y_1(x) \land \dots \land l^y_i(x) \land \dots \land l^y_n(x))} = \bigwedge_{f_i(y) = 0} (\overline{l^y_1(x)} \lor \dots \lor \overline{l^y_i(x)} \lor \dots \lor \overline{l^y_n(x)})
$$
</div>
<p>La formule logique suivante est alors uniquement vraie si $f_i(x) = y_i$ :</p>
<div>
$$
\begin{array}{lcl}
f_i(x, y_i) &=& (y_i \land (\bigwedge_{f_i(y) = 0} (\overline{l^y_1(x)} \lor \dots \lor \overline{l^y_i(x)} \lor \dots \lor \overline{l^y_n(x)})) ) \lor \overline{y_i} \\
& =& (y_i \lor \overline{y_i}) \land (\bigwedge_{f_i(y) = 0} (\overline{l^y_1(x)} \lor \dots \lor \overline{l^y_i(x)} \lor \dots \lor \overline{l^y_n(x)} \lor \overline{y_i}))\\
& =& \bigwedge_{f_i(y) = 0} (\overline{l^y_1(x)} \lor \dots \lor \overline{l^y_i(x)} \lor \dots \lor \overline{l^y_n(x)} \lor \overline{y_i})\\
\end{array}
$$
</div>
<p>On en conclut que la conjonction de clauses suivante n'est vraie que si et seulement si $f(x) = y$ :</p>
<div>
$$
f(x_1, \dots, x_n, y_1, \dots y_m) = \bigwedge_{1\leq i \leq m} f_i((x_1, \dots, x_n), y_i)
$$
</div>
</div>
</details>     
</div>
<h3>Calculabilité des fonctions booléennes (vectorielles)</h3>
<p>On peut conclure cette partie en montrant que toutes les fonctions booléennes vectorielles sont calculables :</p>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
</svg>
<div class="pl-8 mb-2 mr-8">
<p><strong>Proposition</strong></p>
</div><div class="pl-8 mr-8">
<p>Toute fonction booléenne est calculable en $\mathcal{O}(1)$ opérations avec un pseudo-code n'utilisant que la fonction $\text{NAND}$.</p>
</div></div>

<div class="relative drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-indigo-500 bg-indigo-100">
<details class="group" open="">
<summary class="list-none py-0.5">
<svg class="group-open:hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M9 5l7 7-7 7"></path>
</svg>
<svg class="group-open:block hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7"></path>
</svg>
<div class="pl-8 font-bold inline-block">
<p>preuve</p>
</div>
<svg class="group-open:hidden inline-block pl-3 w-10 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M5 12h.01M12 12h.01M19 12h.01M6 12a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0z"></path>
</svg>
</summary>
<div class="mx-8 pb-2">
<p>La taille de l'entrée d'une fonction booléenne est fixe. La taille de la forme normale disjonctive est de taille fixe et peut s'écrire uniquement avec la fonction $\text{NAND}$. Comme une forme normale disjonctive est clairement calculable, on en déduit bien que :</p>
<ul>
<li>une fonction booléenne est calculable</li>
<li>on a besoin que de structures de contrôle et de la fonction $\text{NAND}$</li>
<li>le nombre d'opérations est borné par le nombre d'opérations nécessaire pour calculer la forme normale disjonctive</li>
</ul>
</div>
</details>     
</div>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
</svg>
<div class="pl-8 mb-2 mr-8">
<p><strong>Proposition</strong></p>
</div><div class="pl-8 mr-8">
<p>Toute fonction booléenne vectorielle est calculable en $\mathcal{O}(1)$ par un pseudo-code n'utilisant que la fonction $\text{NAND}$.</p>
</div></div>

<div class="relative drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-indigo-500 bg-indigo-100">
<details class="group" open="">
<summary class="list-none py-0.5">
<svg class="group-open:hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M9 5l7 7-7 7"></path>
</svg>
<svg class="group-open:block hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7"></path>
</svg>
<div class="pl-8 font-bold inline-block">
<p>preuve</p>
</div>
<svg class="group-open:hidden inline-block pl-3 w-10 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M5 12h.01M12 12h.01M19 12h.01M6 12a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0z"></path>
</svg>
</summary>
<div class="mx-8 pb-2">
<blockquote>
<p>TBD ici composition avec projection = fct booléenne, donc calculable puis on refabrique un vecteur. Donner l'algorithme</p>
</blockquote>
<p>La preuve est immédiate puisqu'une fonction booléenne vectorielle est la concaténation d'un nombre constant ($m$) de fonctions booléennes calculables en $\mathcal{O}(1)$ et n'utilisant que la fonction $\text{NAND}$.</p>
</div>
</details>     
</div>
<p>La preuve de la proposition précédente est lourde de conséquences. Ce qui fait qu'une fonction $f: \{0, 1\}^\star \rightarrow \{0, 1\}^\star$ ne peut pas être un algorithme est uniquement lié à la taille variable de l'entrée. Un algorithme ne peut calculer que celles ayant des régularités que l'on peut exploiter via des structures de contrôles (exécution conditionnelle et boucles pour un pseudo-code).</p>
<p>D'un point de vue d'un pseudo-code, on écrira ces fonctions en spécifiant la taille des tableau d'entrée :</p>
<pre class="language-pseudocode" tabindex="0" data-language="pseudocode"><code class="language-pseudocode"><span class="token builtin">algorithme</span> <span class="token function">f</span><span class="token punctuation">(</span>x<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token builtin">bit</span><span class="token punctuation">:</span> n<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">→</span> <span class="token punctuation">[</span><span class="token builtin">bit</span><span class="token punctuation">:</span> m<span class="token punctuation">]</span></code></pre>
<p>Pour ne pas couper les cheveux en 4, on se permettra plusieurs abus de notations évident :</p>
<ul>
<li><code class="language-">f(x_1: bit, ..., x_n: bit) → [bit]</code> à la place de <code class="language-">f([bit: n]) → [bit]</code>,</li>
<li><code class="language-">f(x_1: [bit], ..., x_n: [bit]) → [bit]</code> à la place de <code class="language-">f([bit]) → [bit] # n entrées de taille t_1 + ... + t_n</code>,</li>
</ul>
<p>Cette notation nous permettra d'écrire facilement des fonctions :</p>
<ul>
<li>de plusieurs entrées de même taille: <code class="language-">f(x: [bit: n], y: [bit: n])</code></li>
<li>d'entrée et sortie liées :<code class="language-">f(x: [bit: n]) → [bit: n + 3]</code></li>
</ul>
<h2>Données booléennes</h2>
<p><a href="../bases-th%C3%A9oriques/d%C3%A9finition/#param%C3%A8tres-binaires" class="interne">On a vu</a> qu'un algorithme pouvait ne manipuler que des bits. On peut donc redéfinir la notion de pseudo-code ainsi :</p>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
</svg>
<div class="pl-8 mb-2 mr-8">
<p><strong>Proposition</strong></p>
</div><div class="pl-8 mr-8">
<p>On peut sans perte de généralité supposer qu'<a href="../pseudo-code/briques-de-base/" class="language-">un pseudo-code</a> ne peut manipuler que :</p>
<ul>
<li>des objets (uniquement) de type <code class="language-">bit</code></li>
<li>des tableaux de type <code class="language-">[bit]</code></li>
</ul>
</div></div>

<p>Pour un tableau de bit $x$, on appelle $x[0]$ le <strong><em>bit de poids faible</em></strong> de $x$ et $x[-1]$ le <strong><em>bit de poids fort</em></strong>. Attention, l'ordre de représentation des listes fait croître les indices de gauche à droite, alors que <a href="https://fr.wikipedia.org/wiki/Syst%C3%A8me_binaire">la représentation binaire</a> va <strong>de droite à gauche</strong>. Par exemple le tableau $x = [1, 1, 1, 0, 0, 1, 1, 0]$ sera représenté par le nombre binaire 01100111, correspondant aux indice allant de droite à gauche :</p>
<pre class="language-text" tabindex="0" data-language="text"><code class="language-text">indice : 76543210
   x   : 01100111</code></pre>
<p>Tout tableau de bit peut être interprété de nombreuses manière : entier, réel, caractère, etc :</p>
<div class="quote relative py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-red-500 bg-red-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-red-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"></path>
</svg>
<div class="pl-8 mb-2 mr-8">
<p><strong>À retenir</strong></p>
</div><div class="pl-8 mr-8">
<p>La signification d'une donnée est dépendante du contexte.</p>
</div></div>

<p>Pour éviter toute confusion entre les entiers on écrira :</p>
<ul>
<li>$[0, 1, 1]$ pour un tableau de bits</li>
<li>$011 = 11$ pour l'entier 11 en base 10</li>
<li>$0b011 = b11$ pour l'entier 3 écrit en <a href="https://fr.wikipedia.org/wiki/Syst%C3%A8me_binaire">base 2</a></li>
<li>$0o744$ pour l'entier 484 écrit en base 8 (<a href="https://fr.wikipedia.org/wiki/Syst%C3%A8me_octal">base octale</a>)</li>
<li>$0xBBAADD$ pour l'entier 12298973 écrit en base 16 (<a href="https://fr.wikipedia.org/wiki/Syst%C3%A8me_hexad%C3%A9cimal">base hexadécimal</a>)</li>
<li>$\mathbb{1}_n$ comme étant un tableau de $n$ bits valant tous 1</li>
<li>$\mathbb{0}_n$ comme étant un tableau de $n$ bits valant tous 0</li>
</ul>
<h3>Booléen</h3>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
</svg>
<div class="pl-8 mb-2 mr-8">
<p><strong>Définition</strong></p>
</div><div class="pl-8 mr-8">
<p>On note $b$ la bijection $b: \{0, 1\} \rightarrow \{\text{Vrai}, \text{Faux}\}$ telle que :</p>
<div>
$$
\begin{cases}
b(0) = \text{Faux}\\
b(1) = \text{Vrai}\\
\end{cases}
$$
</div>
</div></div>

<h3>Entiers</h3>
<p>Un tableau de bit pourra être interprété de deux façons complémentaires :</p>
<ul>
<li>comme un entier naturel, on dira que le tableau/nombre est <strong><em>non signé</em></strong></li>
<li>comme un entier relatif (positif ou négatif) et on dira que le tableau/nombre est <strong><em>signé</em></strong></li>
</ul>
<h4>Non signé</h4>
<p>On utilise la représentation binaire classique :</p>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
</svg>
<div class="pl-8 mb-2 mr-8">
<p><strong>Définition</strong></p>
</div><div class="pl-8 mr-8">
<p>On note $u$ la bijection $u: \{0, 1\}^\star \rightarrow \mathbb{N}$ telle que :</p>
<div>
$$
u([x_0, \dots, x_{n-1}]) = \sum_{i=0}^{n-1}x_i \cdot 2^i
$$
</div>
<p>On note $u^{-1}(x)$ l'inverse de $u$ et $u^{-1}_n(x)$ le tableau y de $\{0, 1\}^n$ tel que $u(y) = x \bmod 2^n$</p>
</div></div>

<p>Ainsi :</p>
<ul>
<li>$u([0,1,0, 1]) = 10$ (de notation binaire $0b1010$),</li>
<li>$u^{-1}(10) = [0,1,0, 1]$</li>
<li>$u_3^{-1}(10) = [0,1,0]$ (de notation binaire $0b010$)</li>
<li>$u_8^{-1}(10) = [0,1,0, 1, 0, 0, 0, 0]$ (de notation binaire $0b00001010$)</li>
</ul>
<div class="quote relative py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-orange-500 bg-orange-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-orange-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M8.228 9c.549-1.165 2.03-2 3.772-2 2.21 0 4 1.343 4 3 0 1.4-1.278 2.575-3.006 2.907-.542.104-.994.54-.994 1.093m0 3h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
<div class="pl-8 mr-8">
<p>En utilisant <a href="../projet-algorithmes-classiques/compteur-binaire/" class="interne">l'algorithme du successeur</a>, créez un algorithme de signature <code class="language-">INC(x: [bit: n]) → [bit: n]</code> tel que :</p>
<div>
$$
u(\text{INC}(x)) = (u(x) + 1) \mathbin{\small\%} 2^n
$$
</div>
</div></div>

<div class="relative drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-indigo-500 bg-indigo-100">
<details class="group">
<summary class="list-none py-0.5">
<svg class="group-open:hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M9 5l7 7-7 7"></path>
</svg>
<svg class="group-open:block hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7"></path>
</svg>
<div class="pl-8 font-bold inline-block">
<p>corrigé</p>
</div>
<svg class="group-open:hidden inline-block pl-3 w-10 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M5 12h.01M12 12h.01M19 12h.01M6 12a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0z"></path>
</svg>
</summary>
<div class="mx-8 pb-2">
<pre class="language-pseudocode" tabindex="0" data-language="pseudocode"><code class="language-pseudocode"><span class="token builtin">algorithme</span> <span class="token function">INC</span><span class="token punctuation">(</span>x<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token builtin">bit</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">→</span> <span class="token punctuation">[</span><span class="token builtin">bit</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
    y <span class="token operator">←</span> un tableau de <span class="token builtin">bit</span> de taille x<span class="token punctuation">.</span>longueur
    y<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">]</span> <span class="token operator">←</span> x<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">]</span>

   <span class="token number"> i </span><span class="token operator">←</span> <span class="token number">0</span>
    <span class="token keyword">tant que</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> y<span class="token punctuation">.</span>longueur<span class="token punctuation">)</span> <span class="token keyword">et</span> <span class="token punctuation">(</span>y<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        y<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">←</span> <span class="token number">0</span>
       <span class="token number"> i </span><span class="token operator">←</span><span class="token number"> i </span><span class="token operator">+</span> <span class="token number">1</span>

    <span class="token keyword">si</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> y<span class="token punctuation">.</span>longueur<span class="token punctuation">)</span><span class="token punctuation">:</span>
        y<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">←</span> <span class="token number">1</span>

    <span class="token keyword">rendre</span> y</code></pre>
</div>
</details>     
</div>
<h4>Opposé</h4>
<p>Pour gérer les nombres négatifs, on utilise <a href="https://fr.wikipedia.org/wiki/Compl%C3%A9ment_%C3%A0_deux">le complément à deux</a>, qui revient à travailler modulo $2^n$.</p>
<p>Pour un tableau de bit $x$ on notera :</p>
<div>
$$
-x \coloneqq \text{INC}(\overline{x})
$$
</div>
<p>On choisit cette notion d'opposé à cause de la relation suivante :</p>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
</svg>
<div class="pl-8 mb-2 mr-8">
<p><strong>Proposition</strong></p>
</div><div class="pl-8 mr-8">
<p>pour tout tableau de bit $x$ de taille $n$ on a :</p>
<div>
$$
u(-x) = 2^n -u(x)
$$
</div>
</div></div>

<div class="relative drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-indigo-500 bg-indigo-100">
<details class="group" open="">
<summary class="list-none py-0.5">
<svg class="group-open:hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M9 5l7 7-7 7"></path>
</svg>
<svg class="group-open:block hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7"></path>
</svg>
<div class="pl-8 font-bold inline-block">
<p>preuve</p>
</div>
<svg class="group-open:hidden inline-block pl-3 w-10 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M5 12h.01M12 12h.01M19 12h.01M6 12a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0z"></path>
</svg>
</summary>
<div class="mx-8 pb-2">
<p>On a $u(x) + u(\overline{x}) = u(\mathbb{1}_n) = 2^n-1$, donc $u(\overline{x}) + 1 = 2^n - u(x)$.</p>
<p>Or par définition de l'algorithme $\text{INC}$ on a également $(u(\overline{x}) + 1) = u(\text{INC}(\overline{x})) u(-x)$ ce qui conclut la preuve.</p>
</div>
</details>     
</div>
<p>La proposition précédente montre facilement que la définition est cohérente :</p>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
</svg>
<div class="pl-8 mb-2 mr-8">
<p><strong>Proposition</strong></p>
</div><div class="pl-8 mr-8">
<p>pour tout tableau de bit $x$ de taille $n$ on a :</p>
<div>
$$
-(-x) = x
$$
</div>
</div></div>

<div class="relative drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-indigo-500 bg-indigo-100">
<details class="group" open="">
<summary class="list-none py-0.5">
<svg class="group-open:hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M9 5l7 7-7 7"></path>
</svg>
<svg class="group-open:block hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7"></path>
</svg>
<div class="pl-8 font-bold inline-block">
<p>preuve</p>
</div>
<svg class="group-open:hidden inline-block pl-3 w-10 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M5 12h.01M12 12h.01M19 12h.01M6 12a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0z"></path>
</svg>
</summary>
<div class="mx-8 pb-2">
<p>On a $u(-(-x)) = 2^n -u(-x) = 2^n -(2^n -u(x)) = u(x)$. Comme $u$ est une bijection on a bien que $-(-x) = x$.</p>
</div>
</details>     
</div>
<p>On peut aussi lier l'opposé à $u_n^{-1}$ :</p>
<div class="quote relative py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-orange-500 bg-orange-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-orange-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M8.228 9c.549-1.165 2.03-2 3.772-2 2.21 0 4 1.343 4 3 0 1.4-1.278 2.575-3.006 2.907-.542.104-.994.54-.994 1.093m0 3h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
<div class="pl-8 mr-8">
<p>Montrez que pour tout $x \in [-2^{n-1}\mathrel{{.}\,{.}} 2^{n-1}-1]$, on a :</p>
<div>
$$
u^{-1}_n(2^n + x) =-u^{-1}_n(2^n -x)
$$
</div>
</div></div>

<div class="relative drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-indigo-500 bg-indigo-100">
<details class="group">
<summary class="list-none py-0.5">
<svg class="group-open:hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M9 5l7 7-7 7"></path>
</svg>
<svg class="group-open:block hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7"></path>
</svg>
<div class="pl-8 font-bold inline-block">
<p>corrigé</p>
</div>
<svg class="group-open:hidden inline-block pl-3 w-10 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M5 12h.01M12 12h.01M19 12h.01M6 12a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0z"></path>
</svg>
</summary>
<div class="mx-8 pb-2">
<p>Comme $u(-x) = -u(x) \bmod 2^n$, on a $u^{-1}(x) = -u^{-1}(2^n -x)$. De là :</p>
<ul>
<li>si $x\geq 0$ on a $u^{-1}_n(2^n + x) = u^{-1}(x) = -u^{-1}(2^n -x)$</li>
<li>si $x &lt; 0$ on a $u^{-1}_n(2^n + x) = -u^{-1}(-x) = -u_n^{-1}(2^n-x)$</li>
</ul>
</div>
</details>     
</div>
<p>Enfin, tout ceci se calcule très vite :</p>
<div class="quote relative py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-red-500 bg-red-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-red-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"></path>
</svg>
<div class="pl-8 mb-2 mr-8">
<p><strong>À retenir</strong></p>
</div><div class="pl-8 mr-8">
<p>Calculer l'opposé d'un tableau de bit se fait en temps linéaire uniquement avec une boucle <code class="language-">tant que</code> et la fonction booléenne sur 1 bit <code>NAND</code>.</p>
</div></div>

<h4>Signé</h4>
<p>On a tout en notre possession pour associer des entiers relatifs aux tableaux de bit :</p>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
</svg>
<div class="pl-8 mb-2 mr-8">
<p><strong>Définition</strong></p>
</div><div class="pl-8 mr-8">
<p>On note $i_n: \{0, 1\}^n \rightarrow  [-2^{n-1}\mathrel{{.}\,{.}} 2^{n-1}-1]$ la bijection telle que :</p>
<div>
$$
i_n(x) = 
\begin{cases}
u_{n-1}(x)\text{ si } x[-1] == 0\\
-u_{n-1}(-x) \text{ si } x[-1] == 1\\
\end{cases}
$$
</div>
</div></div>

<p>Il est clair que $i_n$ est une bijection puisque $u_{n-1}$ en est une de $\{0, 1\}^{n-1}$ dans $[0 \mathrel{{.}\,{.}} 2^{n-1}-1]$. Le bit de poids fort des tableaux de bits est appelé <strong><em>bit de signe</em></strong> car $i_n(x) &lt; 0$ s'il vaut 1. Elle est de plus compatible avec notre négation :</p>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
</svg>
<div class="pl-8 mb-2 mr-8">
<p><strong>Proposition</strong></p>
</div><div class="pl-8 mr-8">
<p>Pour tout tableau de bit $x$ de taille $n$ on a $i_n(-x) = -i_n(x)$.</p>
</div></div>

<div class="relative drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-indigo-500 bg-indigo-100">
<details class="group" open="">
<summary class="list-none py-0.5">
<svg class="group-open:hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M9 5l7 7-7 7"></path>
</svg>
<svg class="group-open:block hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7"></path>
</svg>
<div class="pl-8 font-bold inline-block">
<p>preuve</p>
</div>
<svg class="group-open:hidden inline-block pl-3 w-10 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M5 12h.01M12 12h.01M19 12h.01M6 12a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0z"></path>
</svg>
</summary>
<div class="mx-8 pb-2">
<ul>
<li>si $x[-1] == 0$, $i_n(-x) = -u_{n-1}(-(-x)) = -u_{n-1}(x) = -i_n(x)$</li>
<li>si $x[-1] == 1$, $i_n(-x) = u_{n-1}(-x) = -i_n(x)$</li>
</ul>
</div>
</details>     
</div>
<p>Il est crucial de retenir que cette notation dépend du nombre de bits de la représentation de l'entier. Ainsi :</p>
<ul>
<li>$i^{-1}_2(1) = [1, 0]$ (de représentation binaire $0b01$)</li>
<li>$i^{-1}_4(1) = [1, 0, 0, 0]$ (de représentation binaire $0b0001$)</li>
<li>$i^{-1}_2(-1) = [1, 1]$</li>
<li>$i^{-1}_4(-1) = [1, 1, 1, 1]$</li>
</ul>
<p>Remarquez deux choses :</p>
<ul>
<li>Un même tableau de bit dont le bit de poids fort vaut 1 peut être vu comme un entier positif ou négatif</li>
<li>il ne suffit pas de changer le bit de signe pour avoir l'opposé d'un nombre.</li>
</ul>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
</svg>
<div class="pl-8 mb-2 mr-8">
<p><strong>Définition</strong></p>
</div><div class="pl-8 mr-8">
<p>Un tableau de bit considéré comme :</p>
<ul>
<li>un entier positif est dit <strong><em>non signé</em></strong></li>
<li>un entier relatif est dit <strong><em>signé</em></strong></li>
</ul>
<p>Le bit de poids fort d'un tableau signé est appelé <strong><em>bit de signe</em></strong> (il ne vaut <code>1</code> `que si l'entier représenté est négatif).</p>
</div></div>

<h3>Réels</h3>
<p>Les approximation de nombres réels sont encodées sur 64 bits.</p>
<div class="quote relative py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-emerald-500 bg-emerald-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-emerald-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
  <path stroke-linecap="round" stroke-linejoin="round" d="M13.19 8.688a4.5 4.5 0 011.242 7.244l-4.5 4.5a4.5 4.5 0 01-6.364-6.364l1.757-1.757m13.35-.622l1.757-1.757a4.5 4.5 0 00-6.364-6.364l-4.5 4.5a4.5 4.5 0 001.242 7.244"></path>
</svg>
<div class="pl-8 mr-8">
<p><a href="https://fr.wikipedia.org/wiki/IEEE_754#Format_double_pr%C3%A9cision_(64_bits)">Format IEEE 744 double précision</a></p>
</div></div>

<p>Nous ne parlerons pas plus de cet encodage ici, l'algorithmie ne s'intéressant que très peu aux nombres réels, mais certains algorithmes de magie noir sur l'utilisation astucieuse de ce format existent :</p>
<div class="quote relative py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-emerald-500 bg-emerald-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-emerald-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
  <path stroke-linecap="round" stroke-linejoin="round" d="M13.19 8.688a4.5 4.5 0 011.242 7.244l-4.5 4.5a4.5 4.5 0 01-6.364-6.364l1.757-1.757m13.35-.622l1.757-1.757a4.5 4.5 0 00-6.364-6.364l-4.5 4.5a4.5 4.5 0 001.242 7.244"></path>
</svg>
<div class="pl-8 mr-8">
<p><a href="https://fr.wikipedia.org/wiki/Racine_carr%C3%A9e_inverse_rapide">https://fr.wikipedia.org/wiki/Racine_carrée_inverse_rapide</a> (voir aussi : <a href="https://www.youtube.com/watch?v=Fm0vygzVXeE">https://www.youtube.com/watch?v=Fm0vygzVXeE</a>)</p>
</div></div>

<blockquote>
<p>TBD montrer que r(x) &lt; r(y) si u(x) &lt; u(y) ce qui règle plein de problèmes.</p>
</blockquote>
<h3>Chaînes de caractères</h3>
<p>Format UNICODE sur 21 bits permet d'encoder jusqu'à $2^{21} = 2097152$ informations. Actuellement seuls 154998 sont assignés, UNICODE appelle ces informations <strong><em>glyphes</em></strong>, permettant d'encoder plus de 150 langues :</p>
<div class="quote relative py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-emerald-500 bg-emerald-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-emerald-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
  <path stroke-linecap="round" stroke-linejoin="round" d="M13.19 8.688a4.5 4.5 0 011.242 7.244l-4.5 4.5a4.5 4.5 0 01-6.364-6.364l1.757-1.757m13.35-.622l1.757-1.757a4.5 4.5 0 00-6.364-6.364l-4.5 4.5a4.5 4.5 0 001.242 7.244"></path>
</svg>
<div class="pl-8 mr-8">
<p><a href="https://fr.wikipedia.org/wiki/Unicode">Format UNICODE</a></p>
</div></div>

<p>Ne confondez pas la correspondance entre une glyphe (en gros un caractère) et un nombre qui est le format UNICODE et son implémentation informatique qui utilise la conversion <a href="https://fr.wikipedia.org/wiki/UTF-8">UTF-8</a> qui permet d'écrire ces nombres sur un format allant de 8 à 32 bits.</p>
<h2>Opérations</h2>
<p>Cette partie montre que toutes les opérations nécessaires pour faire un pseudo-code peuvent être faite avec des fonction booléennes vectorielles (donc uniquement des fonctions <code>NAND</code>) alliées à des structures de contrôles (tests et boucles <code>tant que</code>).</p>
<blockquote>
<p>TBD rappeler ce que doit savoir faire un pseudo-code</p>
</blockquote>
<h3>Décalage de bits</h3>
<p>Quelques opérations utiles lorsque l'on manipule des tableaux de bits comme des entiers non signés.</p>
<h4>Concaténation</h4>
<p>On utilise la concaténation lorsque l'on veut écrire des entiers plus gros. On utilise un opérateur particulier car ce n'est pas la concaténation de listes habituelle. En effet si on veut concaténer le nombre $x = 0b110$ avec le nombre $y = 0b001$ pour former le nombre $x || y = 0b11001$, on ne peut pas juste concaténer le tableau $X = [0, 1, 1]$ qui représente $x$ au tableau $Y = [1, 0, 0]$ qui représente $y$, il faut faire le contraire ($Y + X$). Explicitons le :</p>
<pre class="language-pseudocode" tabindex="0" data-language="pseudocode"><code class="language-pseudocode"><span class="token builtin">algorithme</span> <span class="token function">CONCAT</span><span class="token punctuation">(</span>x<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token builtin">bit</span><span class="token punctuation">]</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token builtin">bit</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token operator">→</span> <span class="token punctuation">[</span><span class="token builtin">bit</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
    z <span class="token operator">←</span> un tableau de <span class="token builtin">bit</span> de taille x<span class="token punctuation">.</span>longueur <span class="token operator">+</span> y<span class="token punctuation">.</span>longueur

    <span class="token keyword">pour chaque</span><span class="token number"> i </span>de <span class="token punctuation">[</span><span class="token number">0</span> <span class="token punctuation">.</span><span class="token punctuation">.</span> y<span class="token punctuation">.</span>longueur<span class="token punctuation">[</span><span class="token punctuation">:</span>
        z<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">←</span> y<span class="token punctuation">[</span>i<span class="token punctuation">]</span>

    <span class="token keyword">pour chaque</span><span class="token number"> i </span>de <span class="token punctuation">[</span><span class="token number">0</span> <span class="token punctuation">.</span><span class="token punctuation">.</span> x<span class="token punctuation">.</span>longueur<span class="token punctuation">[</span><span class="token punctuation">:</span>
        z<span class="token punctuation">[</span>i <span class="token operator">+</span> y<span class="token punctuation">.</span>longueur<span class="token punctuation">]</span> <span class="token operator">←</span> x<span class="token punctuation">[</span>i<span class="token punctuation">]</span>

    <span class="token keyword">rendre</span> z</code></pre>
<p>La <strong>concaténation</strong> des $n$ bits de $x$ aux $n'$ bits de $y$.</p>
<div>
$$
x || y \coloneqq \text{CONCAT}(x, y)
$$
</div>
<h4>Shift</h4>
<p>On décale les bits vers la gauche ou la droite selon la représentation binaire sans changer le nombre total de bit (les bit qui arrivent sont à 0) :</p>
<ul>
<li>$x &lt;&lt; k$ : <strong><em>shift</em></strong> de $k$ bit vers la gauche. Les $k$ bits de poids faibles sont des $0$ (identique à une multiplication par $2^k$)</li>
<li>$x &gt;&gt; k$ : <strong><em>shift</em></strong> de $k$ bit vers la droite. Les $k$ bits de poids forts sont des $0$ (identique à une division entière par $2^k$)</li>
</ul>
<p>Ainsi : $0b1101 &lt;&lt; 3 = 0b1000$ et $0b1101 &gt;&gt; 2 = 0b0011$</p>
<p>Formellement :</p>
<div>
$$
\begin{array}{lcl}
x << k &\coloneqq &\text{LSHIFT}(x, k)\\
x >> k &\coloneqq &\text{RSHIFT}(x, k)
\end{array}
$$
</div>
<p>Avec :</p>
<pre class="language-pseudocode" tabindex="0" data-language="pseudocode"><code class="language-pseudocode"><span class="token builtin">algorithme</span> <span class="token function">LSHIFT</span><span class="token punctuation">(</span>x<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token builtin">bit</span><span class="token punctuation">]</span><span class="token punctuation">,</span> k<span class="token punctuation">:</span> <span class="token builtin">entier</span><span class="token punctuation">)</span>  <span class="token operator">→</span> <span class="token punctuation">[</span><span class="token builtin">bit</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
    z <span class="token operator">←</span> un tableau de <span class="token builtin">bit</span> de taille x<span class="token punctuation">.</span>longueur

    z<span class="token punctuation">[</span><span class="token punctuation">:</span>k<span class="token punctuation">]</span> <span class="token operator">←</span> <span class="token number">0</span>
    <span class="token keyword">pour chaque</span><span class="token number"> i </span>de <span class="token punctuation">[</span>k <span class="token punctuation">.</span><span class="token punctuation">.</span> x<span class="token punctuation">.</span>longueur <span class="token operator">-</span> k<span class="token punctuation">[</span><span class="token punctuation">:</span>
        z<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">←</span> x<span class="token punctuation">[</span>i <span class="token operator">-</span> k<span class="token punctuation">]</span>

    <span class="token keyword">rendre</span> z

<span class="token builtin">algorithme</span> <span class="token function">RSHIFT</span><span class="token punctuation">(</span>x<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token builtin">bit</span><span class="token punctuation">]</span><span class="token punctuation">,</span> k<span class="token punctuation">:</span> <span class="token builtin">entier</span><span class="token punctuation">)</span>  <span class="token operator">→</span> <span class="token punctuation">[</span><span class="token builtin">bit</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
    z <span class="token operator">←</span> un tableau de <span class="token builtin">bit</span> de taille x<span class="token punctuation">.</span>longueur

    z<span class="token punctuation">[</span><span class="token operator">-</span>k<span class="token punctuation">:</span><span class="token punctuation">]</span> <span class="token operator">←</span> <span class="token number">0</span>
    <span class="token keyword">pour chaque</span><span class="token number"> i </span>de <span class="token punctuation">[</span><span class="token number">0</span> <span class="token punctuation">.</span><span class="token punctuation">.</span> k<span class="token punctuation">[</span><span class="token punctuation">:</span>
        z<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">←</span> x<span class="token punctuation">[</span>i <span class="token operator">+</span> k<span class="token punctuation">]</span>

    <span class="token keyword">rendre</span> z</code></pre>
<p>Notez que nous nous sommes autorisé l'abus de notation en utilisant des paramètres entiers. En toute logique l'algorithme <code class="language-">LSHIFT</code> devrait être :</p>
<pre class="language-pseudocode" tabindex="0" data-language="pseudocode"><code class="language-pseudocode"><span class="token builtin">algorithme</span> <span class="token function">LSHIFT</span><span class="token punctuation">(</span>x<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token builtin">bit</span><span class="token punctuation">]</span><span class="token punctuation">,</span> k<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token builtin">bit</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token operator">→</span> <span class="token punctuation">[</span><span class="token builtin">bit</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
    z <span class="token operator">←</span> un tableau de <span class="token builtin">bit</span> de taille x<span class="token punctuation">.</span>longueur

    z<span class="token punctuation">[</span><span class="token punctuation">:</span>u<span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">←</span> <span class="token number">0</span>
    <span class="token keyword">pour chaque</span><span class="token number"> i </span>de <span class="token punctuation">[</span>u<span class="token punctuation">(</span>k<span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span> x<span class="token punctuation">.</span>longueur <span class="token operator">-</span> k<span class="token punctuation">[</span><span class="token punctuation">:</span>
        z<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">←</span> x<span class="token punctuation">[</span>i <span class="token operator">-</span> u<span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">]</span>

    <span class="token keyword">rendre</span> z</code></pre>
<p>Cela alourdi cependant les notations sans gain de généralité.</p>
<h4>rotation</h4>
<ul>
<li>$x &lt;&lt;&lt; k$ : <strong><em>rotation</em></strong> de $k$ bit vers la gauche.</li>
<li>$x &gt;&gt;&gt; k$ : <strong><em>rotation</em></strong> de $k$ bit vers la droite.</li>
</ul>
<p>Ainsi : $0b1101 &lt;&lt;&lt; 3 = 0b1110$ et $0b1101 &gt;&gt;&gt; 2 = 0b0111$</p>
<p>Formellement :</p>
<div>
$$
\begin{array}{lcl}
x << k &\coloneqq &\text{LROT}(x, k)\\
x >> k &\coloneqq &\text{RROT}(x, k)
\end{array}
$$
</div>
<div class="quote relative py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-orange-500 bg-orange-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-orange-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M8.228 9c.549-1.165 2.03-2 3.772-2 2.21 0 4 1.343 4 3 0 1.4-1.278 2.575-3.006 2.907-.542.104-.994.54-.994 1.093m0 3h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
<div class="pl-8 mr-8">
<p>Donnez un algorithme linéaire pour calculer la rotation. Il devra être de signature : <code class="language-">LROT(x: [bit], k: entier)  → [bit]</code></p>
</div></div>

<div class="relative drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-indigo-500 bg-indigo-100">
<details class="group">
<summary class="list-none py-0.5">
<svg class="group-open:hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M9 5l7 7-7 7"></path>
</svg>
<svg class="group-open:block hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7"></path>
</svg>
<div class="pl-8 font-bold inline-block">
<p>corrigé</p>
</div>
<svg class="group-open:hidden inline-block pl-3 w-10 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M5 12h.01M12 12h.01M19 12h.01M6 12a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0z"></path>
</svg>
</summary>
<div class="mx-8 pb-2">
<blockquote>
<p>TBD simple.</p>
</blockquote>
<p>On aurait aussi pu utiliser <a href="../projet-algorithmes-classiques/chaine-caracteres/#permutation-circulaire" class="interne">l'exercice sur les permutations circulaires</a> si on avait voulu faire un algorithme in place</p>
</div>
</details>     
</div>
<h3>Logiques</h3>
<p>Les opérations logiques définies précédemment s'étendent naturellement aux données sous la forme de tableaux de bits.</p>
<p>Il suffit de montrer la fonction <code>NAND</code> :</p>
<pre class="language-pseudocode" tabindex="0" data-language="pseudocode"><code class="language-pseudocode"><span class="token builtin">algorithme</span> <span class="token function">NAND</span><span class="token punctuation">(</span>x<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token builtin">bit</span><span class="token punctuation">:</span> n<span class="token punctuation">]</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token builtin">bit</span><span class="token punctuation">:</span> n<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">→</span> <span class="token punctuation">[</span><span class="token builtin">bit</span><span class="token punctuation">:</span> n<span class="token punctuation">]</span>
    z <span class="token operator">←</span> tableau de <span class="token builtin">bit</span> de taille x<span class="token punctuation">.</span>longueur

    <span class="token keyword">pour chaque</span><span class="token number"> i </span>de <span class="token punctuation">[</span><span class="token number">0</span> <span class="token punctuation">.</span><span class="token punctuation">.</span> x<span class="token punctuation">.</span>longueur<span class="token punctuation">[</span><span class="token punctuation">:</span>
        z<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">←</span> NAND<span class="token punctuation">(</span>x<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> y<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token keyword">rendre</span> z</code></pre>
<p>Puis de mimer ce que l'on a fait avec les fonction sur 1 bit, par exemple <code class="language-">NOT(x: [bit]) → [bit] := NAND(x, x)</code>. Remarquez que cette fonction n'est <strong>pas</strong> une fonction booléenne vectorielle, mais bien un algorithme : ses entrées ne sont pas de taille fixe.</p>
<div class="quote relative py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-orange-500 bg-orange-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-orange-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M8.228 9c.549-1.165 2.03-2 3.772-2 2.21 0 4 1.343 4 3 0 1.4-1.278 2.575-3.006 2.907-.542.104-.994.54-.994 1.093m0 3h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
<div class="pl-8 mr-8">
<p>Écrivez un algorithme linéaire permettant de réaliser l'opération OR sur un tableau de bit de taille quelconque. Il sera de signature : <code class="language-">OR(x: [bit: n], y: [bit: n]) → [bit: n]</code></p>
</div></div>

<div class="relative drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-indigo-500 bg-indigo-100">
<details class="group">
<summary class="list-none py-0.5">
<svg class="group-open:hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M9 5l7 7-7 7"></path>
</svg>
<svg class="group-open:block hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7"></path>
</svg>
<div class="pl-8 font-bold inline-block">
<p>corrigé</p>
</div>
<svg class="group-open:hidden inline-block pl-3 w-10 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M5 12h.01M12 12h.01M19 12h.01M6 12a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0z"></path>
</svg>
</summary>
<div class="mx-8 pb-2">
<p>On peut utiliser <code>NAND</code> puisque $\overline{x} = \overline{x \land x}$ :</p>
<pre class="language-pseudocode" tabindex="0" data-language="pseudocode"><code class="language-pseudocode">OR<span class="token punctuation">(</span>x<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token builtin">bit</span><span class="token punctuation">]</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token builtin">bit</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">→</span> <span class="token punctuation">[</span><span class="token builtin">bit</span><span class="token punctuation">]</span> <span class="token operator">:=</span> NAND<span class="token punctuation">(</span>NOT<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> NOT<span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre>
</div>
</details>     
</div>
<p>En définissant de même les algorithmes :</p>
<ul>
<li><code class="language-">AND(x: [bit: n], y: [bit: n]) → [bit: n]</code></li>
<li><code class="language-">OR(x: [bit: n], y: [bit: n]) → [bit: n]</code></li>
<li><code class="language-">XOR(x: [bit: n], y: [bit: n]) → [bit: n]</code></li>
</ul>
<p>On peut définir les opérations linéaires <strong>pour des tableaux de même taille</strong> :</p>
<div>
$$
\begin{array}{lcl}
\overline{x} &\coloneqq& \text{NOT}(x, x)\\
x \land y &\coloneqq& \text{AND}(x, y)\\
x \lor y  &\coloneqq& \text{OR}(x, x)\\
x \oplus y  &\coloneqq& \text{XOR}(x, x)\\
\end{array}
$$
</div>
<p>Qui permettent de travailler sur des tableaux de bits. On va voir que ces fonctions suffisent à décrire tous les pseudo-codes.</p>
<h3>Tests</h3>
<pre class="language-pseudocode" tabindex="0" data-language="pseudocode"><code class="language-pseudocode"><span class="token builtin">algorithme</span> <span class="token function">ZERO</span><span class="token punctuation">(</span>x<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token builtin">bit</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">→</span> <span class="token builtin">bit</span>
    <span class="token keyword">pour chaque</span><span class="token number"> i </span>de <span class="token punctuation">[</span><span class="token number">0</span> <span class="token punctuation">.</span><span class="token punctuation">.</span> x<span class="token punctuation">.</span>longueur<span class="token punctuation">[</span><span class="token punctuation">:</span>
        <span class="token keyword">si</span> AND<span class="token punctuation">(</span>x<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment"># x[i] == 1</span>
            <span class="token keyword">rendre</span> <span class="token number">0</span>

    <span class="token keyword">rendre</span> <span class="token number">1</span>

<span class="token builtin">algorithme</span> <span class="token function">GRAND</span><span class="token punctuation">(</span>x<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token builtin">bit</span><span class="token punctuation">:</span> n<span class="token punctuation">]</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token builtin">bit</span><span class="token punctuation">:</span> n<span class="token punctuation">]</span><span class="token punctuation">)</span>
                <span class="token operator">→</span> <span class="token builtin">bit</span>
    <span class="token keyword">pour chaque</span><span class="token number"> i </span>de <span class="token punctuation">[</span><span class="token number">1</span> <span class="token punctuation">.</span><span class="token punctuation">.</span> x<span class="token punctuation">.</span>longueur<span class="token punctuation">]</span><span class="token punctuation">:</span>
        <span class="token keyword">si</span> XOR<span class="token punctuation">(</span>x<span class="token punctuation">[</span><span class="token operator">-</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> y<span class="token punctuation">[</span><span class="token operator">-</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment"># x[i] != y[i]</span>
            <span class="token keyword">rendre</span> x<span class="token punctuation">[</span><span class="token operator">-</span>i<span class="token punctuation">]</span>

    <span class="token keyword">rendre</span> <span class="token number">0</span>
</code></pre>
<div>
$$
\begin{array}{lcl}
x \neq 0 &\coloneqq& \text{ZERO}(x)\\
x == y &\coloneqq& \text{ZERO}(x - y)\\
x > y &\coloneqq& \text{GRAND}(x, y)\
x < y &\coloneqq& y < x\\
x \leq y &\coloneqq& (x == y) \lor (x < y)\\
x \geq y &\coloneqq& (y \leq x)\\
\end{array}
$$
</div>
<h3><span id="arithmétique"></span>Arithmétique</h3>
<p>Nous allons donner ici les complexité par rapport à la taille des entrées, c'est à dire des tableaux de bits correspondant à des entiers.</p>
<h4>Somme</h4>
<p>Sur deux entiers non signés</p>
<pre><code>  100101
+ 001011
--------
  110001
</code></pre>
<p>Attention à la retenue :</p>
<pre><code>  100101
+ 011011
--------
 1000000
</code></pre>
<p>L'algorithme est alors le suivant (on en a déjà vu une version lorsque l'<a href="../probl%C3%A8mes-NP/#algorithme-somme_binaire">on a étudié les problèmes NP</a>, ici on va le considéré modulo la taille des entrées) c'est à dire que l'addition de $0b100101$ et $0b011011$ donnera : $0b000000$. On utilise aussi les fonctions booléennes à 1 bit définies précédemment pour un résultat compact :</p>
<pre class="language-pseudocode" tabindex="0" data-language="pseudocode"><code class="language-pseudocode"><span class="token builtin">algorithme</span> <span class="token function">somme</span><span class="token punctuation">(</span>x<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token builtin">bit</span><span class="token punctuation">:</span> n<span class="token punctuation">]</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token builtin">bit</span><span class="token punctuation">:</span> n<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">→</span> <span class="token punctuation">[</span><span class="token builtin">bit</span><span class="token punctuation">:</span> n<span class="token punctuation">]</span>

    z <span class="token operator">←</span> tableau de <span class="token builtin">bit</span> de taille x<span class="token punctuation">.</span>longueur
    r <span class="token operator">←</span> <span class="token number">0</span>

    <span class="token keyword">pour chaque</span><span class="token number"> i </span>de <span class="token punctuation">[</span><span class="token number">0</span> <span class="token punctuation">.</span><span class="token punctuation">.</span> x<span class="token punctuation">.</span>longueur<span class="token punctuation">[</span><span class="token punctuation">:</span>
        z<span class="token punctuation">[</span>i<span class="token punctuation">]</span>  <span class="token operator">←</span> XOR<span class="token punctuation">(</span>XOR<span class="token punctuation">(</span>r<span class="token punctuation">,</span> x<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> y<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
        r <span class="token operator">←</span> OR<span class="token punctuation">(</span>AND<span class="token punctuation">(</span>r<span class="token punctuation">,</span> x<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
               AND<span class="token punctuation">(</span>OR<span class="token punctuation">(</span>r<span class="token punctuation">,</span> x<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                   y<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">rendre</span> z</code></pre>
<p>Sa complexité est bien linéaire puisque les fonction utilisées sont toutes de complexité $\mathcal{O}(1)$.</p>
<p>Terminons cette partie en montrant que l'on peut récrire cet algorithme uniquement avec des fonctions <code>NAND</code> sans changer sa complexité. Pour cela commençons par ne mettre qu'une seule instruction par ligne :</p>
<pre class="language-pseudocode" tabindex="0" data-language="pseudocode"><code class="language-pseudocode"><span class="token builtin">algorithme</span> somme'<span class="token punctuation">(</span>x<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token builtin">bit</span><span class="token punctuation">:</span> n<span class="token punctuation">]</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token builtin">bit</span><span class="token punctuation">:</span> n<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">→</span> <span class="token punctuation">[</span><span class="token builtin">bit</span><span class="token punctuation">:</span> n<span class="token punctuation">]</span>

    z <span class="token operator">←</span> tableau de <span class="token builtin">bit</span> de taille x<span class="token punctuation">.</span>longueur
    r <span class="token operator">←</span> <span class="token number">0</span>

    <span class="token keyword">pour chaque</span><span class="token number"> i </span>de <span class="token punctuation">[</span><span class="token number">0</span> <span class="token punctuation">.</span><span class="token punctuation">.</span> x<span class="token punctuation">.</span>longueur<span class="token punctuation">[</span><span class="token punctuation">:</span>
        a <span class="token operator">←</span> r
        b <span class="token operator">←</span> x<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
        c <span class="token operator">←</span> XOR<span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span>

        a <span class="token operator">←</span> c
        b <span class="token operator">←</span> x<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
        c <span class="token operator">←</span> XOR<span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span>

        z<span class="token punctuation">[</span>i<span class="token punctuation">]</span>  <span class="token operator">←</span> c

        a <span class="token operator">←</span> r
        b <span class="token operator">←</span> x<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
        c <span class="token operator">←</span> OR<span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span>

        a <span class="token operator">←</span> c
        b <span class="token operator">←</span> y<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
        c <span class="token operator">←</span> AND<span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span>

        a <span class="token operator">←</span> r
        b <span class="token operator">←</span> b<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
        d <span class="token operator">←</span> AND<span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span>

        a <span class="token operator">←</span> c
        b <span class="token operator">←</span> d
        c <span class="token operator">←</span> OR<span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span>

        r  <span class="token operator">←</span> c

    <span class="token keyword">rendre</span> z</code></pre>
<p>Puis à remplacer les fonctions logiques par leur pendant avec <code>NAND</code> pour définir notre algorithme <code class="language-">PLUS</code>:</p>
<pre class="language-pseudocode" tabindex="0" data-language="pseudocode"><code class="language-pseudocode"><span class="token builtin">algorithme</span> <span class="token function">PLUS</span><span class="token punctuation">(</span>x<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token builtin">bit</span><span class="token punctuation">:</span> n<span class="token punctuation">]</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token builtin">bit</span><span class="token punctuation">:</span> n<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">→</span> <span class="token punctuation">[</span><span class="token builtin">bit</span><span class="token punctuation">:</span> n<span class="token punctuation">]</span>

    z <span class="token operator">←</span> tableau de <span class="token builtin">bit</span> de taille x<span class="token punctuation">.</span>longueur
    r <span class="token operator">←</span> <span class="token number">0</span>

    <span class="token keyword">pour chaque</span><span class="token number"> i </span>de <span class="token punctuation">[</span><span class="token number">0</span> <span class="token punctuation">.</span><span class="token punctuation">.</span> x<span class="token punctuation">.</span>longueur<span class="token punctuation">[</span><span class="token punctuation">:</span>
        a <span class="token operator">←</span> r
        b <span class="token operator">←</span> x<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
        c <span class="token operator">←</span> NAND<span class="token punctuation">(</span>NAND<span class="token punctuation">(</span>a<span class="token punctuation">,</span> NAND<span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> NAND<span class="token punctuation">(</span>a<span class="token punctuation">,</span> NAND<span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

        a <span class="token operator">←</span> c
        b <span class="token operator">←</span> x<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
        c <span class="token operator">←</span> NAND<span class="token punctuation">(</span>NAND<span class="token punctuation">(</span>a<span class="token punctuation">,</span> NAND<span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> NAND<span class="token punctuation">(</span>a<span class="token punctuation">,</span> NAND<span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

        z<span class="token punctuation">[</span>i<span class="token punctuation">]</span>  <span class="token operator">←</span> c

        a <span class="token operator">←</span> r
        b <span class="token operator">←</span> x<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
        c <span class="token operator">←</span> NAND<span class="token punctuation">(</span>NAND<span class="token punctuation">(</span>a<span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">,</span> NAND<span class="token punctuation">(</span>b<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">)</span>

        a <span class="token operator">←</span> c
        b <span class="token operator">←</span> y<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
        c <span class="token operator">←</span> NAND<span class="token punctuation">(</span>NAND<span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">,</span> NAND<span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">)</span>

        a <span class="token operator">←</span> r
        b <span class="token operator">←</span> b<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
        d <span class="token operator">←</span> NAND<span class="token punctuation">(</span>NAND<span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">,</span> NAND<span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">)</span>

        a <span class="token operator">←</span> c
        b <span class="token operator">←</span> d
        c <span class="token operator">←</span> NAND<span class="token punctuation">(</span>NAND<span class="token punctuation">(</span>a<span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">,</span> NAND<span class="token punctuation">(</span>b<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">)</span>

        r  <span class="token operator">←</span> c

    <span class="token keyword">rendre</span> z</code></pre>
<div class="quote relative py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-red-500 bg-red-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-red-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"></path>
</svg>
<div class="pl-8 mb-2 mr-8">
<p><strong>À retenir</strong></p>
</div><div class="pl-8 mr-8">
<p>Calculer la somme de deux tableaux de bit se fait en temps linéaire uniquement avec une boucle <code class="language-">tant que</code> et la fonction booléenne sur 1 bit <code>NAND</code>.</p>
</div></div>

<p>On peut définir les opérations linéaires <strong>pour des tableaux de même taille</strong> :</p>
<div>
$$
x + y \coloneqq \text{PLUS}(x, y)\\
$$
</div>
<p>Cette addition fonctionne pour 2 (tableaux représentant des) entiers non signés.</p>
<h4>Soustraction</h4>
<p>L'utilisation du complément à deux permet
somme de deux entiers signés</p>
<div>
$$
x-y \coloneqq x + (-y)
$$
</div>
<p>Cette définition est cohérente puisque $(x + 2^n - y) \bmod 2^n = x -  y \bmod 2^n$. L'utilisation du complément à 2 est donc extrêmement astucieuse et permet d'éviter tout un tas de cas particulier que l'on se trimbale <a href="https://fr.wikipedia.org/wiki/Compl%C3%A9ment_%C3%A0_deux#Probl%C3%A8me_de_la_repr%C3%A9sentation_na%C3%AFve">si l'on utilise uniquement un bit de signe</a>.</p>
<div class="quote relative py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-red-500 bg-red-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-red-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"></path>
</svg>
<div class="pl-8 mb-2 mr-8">
<p><strong>À retenir</strong></p>
</div><div class="pl-8 mr-8">
<p>Calculer la soustraction de deux tableaux de bit se fait en temps linéaire uniquement avec une boucle <code class="language-">tant que</code> et la fonction booléenne sur 1 bit <code>NAND</code>.</p>
</div></div>

<h4>Multiplication</h4>
<p>On utilise la <a href="https://fr.wikipedia.org/wiki/Multiplication#Techniques_de_multiplication">multiplication posée</a>. Les nombres binaires simplifient grandement le calcul car il suffit de faire des additions.</p>
<pre><code>       100101
     * 001011
    ---------
       100101  = 100101 * 1
      100101   = 100101 * 1
     000000    = 100101 * 0
    100101     = 100101 * 1
   000000      = 100101 * 0
+ 000000       = 100101 * 0
------------
  00110010111
</code></pre>
<p>On trouve que $0b100101 \cdot 0b1011 = 0b110010111$ ($37 \cot 11 = 407$).</p>
<p>Tout comme pour l'addition, nous allons donner ici une version modulo $2^n$ (sans perte de généralité, il suffit d'ajouter des 0 au tableau de bit) :</p>
<pre><code>    100101
 *  001011
---------
    100101
    00101
    0000
    101
    00
+   0
--------
    10111
</code></pre>
<p>On obtient l'algorithme suivant :</p>
<pre class="language-pseudocode" tabindex="0" data-language="pseudocode"><code class="language-pseudocode"><span class="token builtin">algorithme</span> <span class="token function">FOIS</span><span class="token punctuation">(</span>x<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token builtin">bit</span><span class="token punctuation">:</span> n<span class="token punctuation">]</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token builtin">bit</span><span class="token punctuation">:</span> n<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">→</span> <span class="token punctuation">[</span><span class="token builtin">bit</span><span class="token punctuation">:</span> n<span class="token punctuation">]</span>

    z <span class="token operator">←</span> tableau de <span class="token builtin">bit</span> de taille x<span class="token punctuation">.</span>longueur
    z<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">]</span> <span class="token operator">←</span> <span class="token number">0</span>

    <span class="token keyword">pour chaque</span> k de <span class="token punctuation">[</span><span class="token number">0</span> <span class="token punctuation">.</span><span class="token punctuation">.</span> x<span class="token punctuation">.</span>longueur<span class="token punctuation">[</span><span class="token punctuation">:</span>
        r <span class="token operator">←</span> <span class="token number">0</span>
        <span class="token keyword">pour chaque</span><span class="token number"> i </span>de <span class="token punctuation">[</span>k <span class="token punctuation">.</span><span class="token punctuation">.</span> x<span class="token punctuation">.</span>longueur<span class="token punctuation">[</span><span class="token punctuation">:</span>
            a <span class="token operator">←</span> AND<span class="token punctuation">(</span>y<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">,</span> x<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
            z<span class="token punctuation">[</span>i<span class="token punctuation">]</span>  <span class="token operator">←</span> XOR<span class="token punctuation">(</span>XOR<span class="token punctuation">(</span>r<span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">,</span> z<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
            r <span class="token operator">←</span> OR<span class="token punctuation">(</span>AND<span class="token punctuation">(</span>r<span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token punctuation">,</span>
                   AND<span class="token punctuation">(</span>OR<span class="token punctuation">(</span>r<span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">,</span>
                          z<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">rendre</span> z</code></pre>
<p>La complexité de l'algorithme est en $\mathcal(O)(n^2)$ et on a :</p>
<div class="quote relative py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-red-500 bg-red-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-red-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"></path>
</svg>
<div class="pl-8 mb-2 mr-8">
<p><strong>À retenir</strong></p>
</div><div class="pl-8 mr-8">
<p>Calculer le produit de deux tableaux de bit se fait en temps quadratique uniquement avec deux boucles <code class="language-">pour chaque</code> et la fonction booléenne sur 1 bit <code>NAND</code>.</p>
</div></div>

<div class="quote relative  py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-cyan-500 bg-cyan-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-cyan-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z"></path>
</svg>
<div class="pl-8 mr-8">
<p>Les meilleurs algorithmes connus pour effectuer la multiplication sont en $\mathcal(O)(n\log(n))$ mais ne sont presque jamais implémenté car leurs valeurs ajoutées est asymptotique et est atteinte pour des nombres trop grand par rapport aux nombres utilisés.</p>
</div></div>

<h4>Division euclidienne</h4>
<p>On utilise la <a href="https://fr.wikipedia.org/wiki/Division_pos%C3%A9e">division posée</a>. Les nombres binaires simplifient grandement le calcul car il suffit de faire des soustractions.</p>
<p>La complexité de l'algorithme est en $\mathcal(O)(n^2)$.</p>
<pre><code>  100101 | 001011
  -------|-----
         | 000011
  1      | ^
  10     |  ^
  100    |   ^
  1001   |    ^
  10010  |
 - 1011  |     ^
 ------  |     |
    111  |     |
    1111 |     |
  - 1011 |      ^
  ------ |      |
    0100 |      |
</code></pre>
<p>On trouve que : $0b100101 / 0b1011 = 0b11$ et $0b100101 \bmod 0b1011 = 100$</p>
<p>$37 / 11 = 3$ et $37 \bmod 11 = 4$</p>
<p>Ci après une version non signée :</p>
<pre class="language-pseudocode" tabindex="0" data-language="pseudocode"><code class="language-pseudocode">
<span class="token builtin">algorithme</span> <span class="token function">FOIS</span><span class="token punctuation">(</span>x<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token builtin">bit</span><span class="token punctuation">:</span> n<span class="token punctuation">]</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token builtin">bit</span><span class="token punctuation">:</span> n<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">→</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token builtin">bit</span><span class="token punctuation">:</span> n<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token builtin">bit</span><span class="token punctuation">:</span> n<span class="token punctuation">]</span><span class="token punctuation">)</span>

    q <span class="token operator">←</span> tableau de <span class="token builtin">bit</span> de taille x<span class="token punctuation">.</span>longueur
    q<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">]</span> <span class="token operator">←</span> <span class="token number">0</span>

    r <span class="token operator">←</span> tableau de <span class="token builtin">bit</span> de taille x<span class="token punctuation">.</span>longueur
    r<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">]</span> <span class="token operator">←</span> <span class="token number">0</span>

    <span class="token keyword">pour chaque</span> k de <span class="token punctuation">[</span><span class="token number">1</span> <span class="token punctuation">.</span><span class="token punctuation">.</span> x<span class="token punctuation">.</span>longueur<span class="token punctuation">]</span><span class="token punctuation">:</span>
            q <span class="token operator">←</span> q <span class="token operator">&lt;&lt;</span> <span class="token number">1</span>
            q<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">←</span> x<span class="token punctuation">[</span><span class="token operator">-</span>k<span class="token punctuation">]</span>

            r <span class="token operator">←</span> r <span class="token operator">&lt;&lt;</span> <span class="token number">1</span>
            <span class="token keyword">si</span> u<span class="token punctuation">(</span>q<span class="token punctuation">)</span> <span class="token operator">≥</span> u<span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">:</span>
                q <span class="token operator">←</span> q <span class="token operator">-</span> y
                r<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">←</span> <span class="token number">1</span>
            <span class="token keyword">sinon</span><span class="token punctuation">:</span>
                r<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">←</span> <span class="token number">0</span>

    <span class="token keyword">rendre</span> <span class="token punctuation">(</span>q<span class="token punctuation">,</span> r<span class="token punctuation">)</span></code></pre>
<div class="quote relative py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-red-500 bg-red-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-red-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"></path>
</svg>
<div class="pl-8 mb-2 mr-8">
<p><strong>À retenir</strong></p>
</div><div class="pl-8 mr-8">
<p>Calculer la division euclidienne de deux tableaux de bit se fait en temps quadratique uniquement avec deux boucles <code class="language-">pour chaque</code> (il y a une soustraction et un test pour chaque itération de la boucle) et la fonction booléenne sur 1 bit <code>NAND</code>.</p>
</div></div>

<h4>pgcd</h4>
<p><a href="../projet-algorithmes-classiques/pgcd/#algorithme-pgcd-binaire" class="language-">On a déjà vu cet algorithme</a>, mais de façon récursive.</p>
<div class="quote relative py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-orange-500 bg-orange-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-orange-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M8.228 9c.549-1.165 2.03-2 3.772-2 2.21 0 4 1.343 4 3 0 1.4-1.278 2.575-3.006 2.907-.542.104-.994.54-.994 1.093m0 3h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
<div class="pl-8 mr-8">
<p>Écrivez l'algorithme du pgcd binaire de façon itérative. Il devra être de signature : <code class="language-">PGCD(x: [bit: n], y: [bit: n]) → [bit: n]</code>.</p>
</div></div>

<div class="relative drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-indigo-500 bg-indigo-100">
<details class="group">
<summary class="list-none py-0.5">
<svg class="group-open:hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M9 5l7 7-7 7"></path>
</svg>
<svg class="group-open:block hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7"></path>
</svg>
<div class="pl-8 font-bold inline-block">
<p>corrigé</p>
</div>
<svg class="group-open:hidden inline-block pl-3 w-10 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M5 12h.01M12 12h.01M19 12h.01M6 12a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0z"></path>
</svg>
</summary>
<div class="mx-8 pb-2">
<p>Remarquez que diviser par 2 est égal à un shift de 1 vers la droite.</p>
<pre class="language-pseudocode" tabindex="0" data-language="pseudocode"><code class="language-pseudocode">
<span class="token builtin">algorithme</span> <span class="token function">PGCD</span><span class="token punctuation">(</span>x<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token builtin">bit</span><span class="token punctuation">:</span> n<span class="token punctuation">]</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token builtin">bit</span><span class="token punctuation">:</span> n<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">→</span> <span class="token punctuation">[</span><span class="token builtin">bit</span><span class="token punctuation">:</span> n<span class="token punctuation">]</span>

    p tableau de <span class="token builtin">bit</span> de taille x<span class="token punctuation">.</span>longueur
    p<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">]</span> <span class="token operator">←</span> <span class="token number">0</span>
    p<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">←</span> <span class="token number">1</span>
    <span class="token keyword">tant que</span> y <span class="token operator">≠</span> <span class="token number">0</span><span class="token punctuation">:</span>
        <span class="token keyword">si</span> AND<span class="token punctuation">(</span>x<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> y<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>             <span class="token comment"># x et y sont pairs</span>
            x <span class="token operator">←</span> x <span class="token operator">>></span> <span class="token number">1</span>
            y <span class="token operator">←</span> y <span class="token operator">>></span> <span class="token number">1</span>
            p <span class="token operator">←</span> p <span class="token operator">&lt;&lt;</span> <span class="token number">1</span>
        <span class="token keyword">sinon si</span> AND<span class="token punctuation">(</span>NOT<span class="token punctuation">(</span>x<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> y<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment"># x impair et y pair</span>
            y <span class="token operator">←</span> y <span class="token operator">>></span> <span class="token number">1</span>
        <span class="token keyword">sinon si</span> AND<span class="token punctuation">(</span>x<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> NOT<span class="token punctuation">(</span>y<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment"># x pair et y impair</span>
            x <span class="token operator">←</span> x <span class="token operator">>></span> <span class="token number">1</span>
        <span class="token keyword">sinon</span><span class="token punctuation">:</span>                          <span class="token comment"># x et y sont impairs</span>
            <span class="token keyword">si</span> x <span class="token operator">&lt;</span> y<span class="token punctuation">:</span>
                x<span class="token punctuation">,</span> y <span class="token operator">←</span> y<span class="token punctuation">,</span> x
            x <span class="token operator">←</span> x <span class="token operator">-</span> y
    <span class="token keyword">rendre</span> x <span class="token operator">*</span> p</code></pre>
</div>
</details>     
</div>
<p>Cet algorithme est très efficace pour les nombres binaires puisque la division par deux est un shift de 1 bit vers la droite :</p>
<div class="quote relative py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-red-500 bg-red-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-red-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"></path>
</svg>
<div class="pl-8 mb-2 mr-8">
<p><strong>À retenir</strong></p>
</div><div class="pl-8 mr-8">
<p>Calculer le pgcd de deux tableaux de bit se fait en temps quadratique.</p>
</div></div>

<h2>Pseudo-code</h2>
<p>Ceci nous permettra <em>in fine</em> de redéfinir la notion de pseudo-code avec des objets et et des opérations bien plus simple sans perte de généralité.</p>
<h3>Variables interne binaires</h3>
<p>Si données sont toutes des tableaux de bits, nos algorithmes utilisent encore des entiers pour les variables internes des boucles <code class="language-">pour chaque</code>. C'est un abus de notation est on peut tout à fait s'en passer, considérer par exemple l'algorithme <code class="language-">NAND</code> suivant :</p>
<pre class="language-pseudocode" tabindex="0" data-language="pseudocode"><code class="language-pseudocode"><span class="token builtin">algorithme</span> <span class="token function">NAND</span><span class="token punctuation">(</span>x<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token builtin">bit</span><span class="token punctuation">:</span> n<span class="token punctuation">]</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token builtin">bit</span><span class="token punctuation">:</span> n<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">→</span> <span class="token punctuation">[</span><span class="token builtin">bit</span><span class="token punctuation">:</span> n<span class="token punctuation">]</span>
    z <span class="token operator">←</span> tableau de <span class="token builtin">bit</span> de taille x<span class="token punctuation">.</span>longueur

   <span class="token number"> i </span><span class="token operator">←</span> tableau de <span class="token builtin">bit</span> de taille log<span class="token punctuation">(</span>x<span class="token punctuation">.</span>longueur<span class="token punctuation">)</span>  <span class="token comment"># la même taille que pour stocker l'entier x.longueur</span>
    i<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">]</span> <span class="token operator">←</span> <span class="token number">0</span>
    <span class="token keyword">tant que</span><span class="token number"> i </span><span class="token operator">≠</span> x<span class="token punctuation">.</span>longueur<span class="token punctuation">:</span>
        z<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">←</span> NAND<span class="token punctuation">(</span>x<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> y<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
       <span class="token number"> i </span><span class="token operator">←</span><span class="token number"> i </span><span class="token operator">+</span> <span class="token number">1</span>
    <span class="token keyword">rendre</span> z</code></pre>
<p>La différence est que l'on utilise maintenant les opérations que l'on a défini pour les tableaux de bit ! Il n'y a plus d'entier, même dans les variables internes.</p>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
</svg>
<div class="pl-8 mb-2 mr-8">
<p><strong>Proposition</strong></p>
</div><div class="pl-8 mr-8">
<p>Un pseudo-code utilisant uniquement des variables de type bit ou [bit] a la même expressivité que le pseudo-code utilisant <a href="../pseudo-code/briques-de-base/#objets-basiquess" class="interne">les types basiques</a>.</p>
</div></div>

<h3>Opérations autorisées</h3>
<p>On voit que <a href="../pseudo-code/briques-de-base/#objets-basiquess" class="interne">toutes les opérations autorisées pour un pseudo-code</a> peuvent être créées uniquement avec des fonctions booléennes vectorielles et des instructions de contrôles (test et boucles). On peut même se restreindre à l'opération logique <code class="language-">NAND</code> :</p>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
</svg>
<div class="pl-8 mb-2 mr-8">
<p><strong>Proposition</strong></p>
</div><div class="pl-8 mr-8">
<p>Un pseudo-code utilisant uniquement :</p>
<ul>
<li>variables :
<ul>
<li>binaires ou des tableaux binaires</li>
<li>les seules affectations autorisées sont les bits <code class="language-">x[i] ← y[j]</code> avec $i$ étant un entier possiblement issu d'une évaluation $u(z)$</li>
</ul>
</li>
<li>opérations : les fonctions booléennes vectorielles</li>
<li>instruction de contrôle <code class="language-">si x: ...bloc...</code> où <code>x</code> est une variable binaire. Le bloc n'est exécuté que si <code class="language-">x = 1</code></li>
<li>répétition : <code class="language-">tant que x: ...bloc...</code> où <code>x</code> est une variable binaire. Le bloc n'est exécuté que tant que <code class="language-">x = 1</code>.</li>
</ul>
<p>A la même expressivité que <a href="../pseudo-code/" class="interne">le pseudo-code classique</a>.</p>
</div></div>

<blockquote>
<p>TBD l'opération logique <code class="language-">NAND</code> suffit.</p>
</blockquote>


</article>
    </main>

    <footer class="min-h-[50px] border-t-2 border-gray-200 mt-4">
      <div class="max-w-[1200px] mx-auto px-4 relative">
        <div class="min-h-[50px] flex justify-center items-center">
          <p>
            Cours d'informatique de François Brucker
          </p>
        </div>
        <div class="min-h-[50px] flex justify-center items-center absolute right-0 top-0">
          <button onclick="goTop()" id="myBtn" title="Go to top">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
              <path stroke-linecap="round" stroke-linejoin="round" d="M15 11.25l-3-3m0 0l-3 3m3-3v7.5M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
            </svg>
          </button>

          <button onclick="goBottom()" id="myBtn" title="Go to top">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
              <path stroke-linecap="round" stroke-linejoin="round" d="M9 12.75l3 3m0 0l3-3m-3 3v-7.5M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
            </svg>
          </button>
        </div>

      </div>
    </footer>

    <script>
      MathJax
        .startup
        .document
        .getMathItemsWithin(document.body);
    </script>

  </body>
</html>