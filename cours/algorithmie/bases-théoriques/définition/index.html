<!DOCTYPE html>
<html lang="fr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>D√©finitionsd&#39;un algorithme</title>

    

    <link href="https://prismjs.catppuccin.com/latte.css" rel="stylesheet">

    <link href="/cours_informatique/assets/node_modules/prismjs/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet">
    <script src="/cours_informatique/assets/node_modules/prismjs/plugins/line-numbers/prism-line-numbers.min.js"></script>
    
    <link href="/cours_informatique/assets/stylesheets/main.css" rel="stylesheet">

  </head>
  <body>
    <script>
      window.MathJax = {
        tex: {
          inlineMath: [
            [
              '$', '$'
            ],
            [
              '\\(', '\\)'
            ]
          ]
        },
        svg: {
          fontCache: 'global'
        }
      };

      function goTop() {
        window.scrollTo({top: 0});
      }
      function goBottom() {
        window.scrollTo({top: document.body.scrollHeight});
      }
    </script>
    <script type="text/javascript" id="MathJax-script" src="/cours_informatique/assets/node_modules/mathjax/es5/tex-svg-full.js"></script>

    <header class="border-b-2 border-gray-200 mb-4">
      <div class="max-w-[1200px] mx-auto px-4 relative">
        <div class="min-h-[50px] flex justify-between items-center">
          <a class="mx-2" href="/cours_informatique/">Home</a>
        </div>

        <div class="min-h-[50px] flex justify-center items-center absolute right-0 top-0">
          <a class="mx-2" href="/cours_informatique/about">About</a>
          <button onclick="goTop()" id="myBtn" title="Go to top">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
              <path stroke-linecap="round" stroke-linejoin="round" d="M15 11.25l-3-3m0 0l-3 3m3-3v7.5M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
            </svg>
          </button>

          <button onclick="goBottom()" id="myBtn" title="Go to top">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
              <path stroke-linecap="round" stroke-linejoin="round" d="M9 12.75l3 3m0 0l3-3m-3 3v-7.5M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
            </svg>
          </button>
        </div>

      </div>
    </header>

    <main class="max-w-[1200px] mx-auto px-4">
      
<article>

  <h1>D√©finitionsd&#39;un algorithme</h1>
  <div>
    

    
  </div>

  

    
<div class="quote relative  py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-purple-500 bg-purple-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-purple-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M5 19a2 2 0 01-2-2V7a2 2 0 012-2h4l2 2h4a2 2 0 012 2v1M5 19h14a2 2 0 002-2v-5a2 2 0 00-2-2H9a2 2 0 00-2 2v5a2 2 0 01-2 2z"></path>
</svg>
<div class="pl-8 mr-8">

<a class="interne" href="/cours_informatique/cours/">Cours</a><span class="px-1">/</span><a class="interne" href="/cours_informatique/cours/algorithmie/">Algorithmie</a><span class="px-1">/</span><a class="interne" href="/cours_informatique/cours/algorithmie/bases-th√©oriques/">Bases th√©oriques</a><span class="px-1">/</span><a class="interne" href="/cours_informatique/cours/algorithmie/bases-th√©oriques/d√©finition/">D√©finitionsd&#39;un algorithme</a>

</div></div>



    
  

  <p>On doit le mot algorithme √† <a href="https://fr.wikipedia.org/wiki/Ada_Lovelace">Ada Lovelace</a> (1815-1852) qui est le(a) premier(e) informaticien(ne) de l'histoire. Elle a donn√© ce nom en hommage √† un savant persan du 9√®me si√®cle (n√© vers 780 et mort en 850 √† Bagdad) nomm√© <a href="https://fr.wikipedia.org/wiki/Al-Khw%C3%A2rizm%C3%AE">Al-Khw√¢rizm√Æ</a> qui a publi√© le premier manuel d'alg√®bre connu √† ce jour.</p>
<h2><span id="algorithme"></span> Algorithme ?</h2>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
</svg>
<div class="pl-8 mb-2 mr-8">
<p>D√©finition du '<em>Petit Robert</em>'  d'un <strong>algorithme</strong> :</p>
</div><div class="pl-8 mr-8">
<p>Un <strong><em>algorithme</em></strong> est un ensemble des r√®gles op√©ratoires propres √† un <em>calcul</em>.</p>
</div></div>

<p>Qu'est-ce que √ßa veut dire ?</p>
<ul>
<li><strong>algorithme</strong> : ensemble des r√®gles op√©ratoires propres √† un <strong>calcul</strong></li>
<li><strong>calcul</strong> : encha√Ænement des instructions n√©cessaires √† l'accomplissement d'une <strong>t√¢che</strong></li>
<li><strong>t√¢che</strong> : ...</li>
</ul>
<p>Tel monsieur Jourdain, on a utilis√© un algorithme pour comprendre ce qu'est un algorithme ! Formalisons le :</p>
<pre class="language-text" tabindex="0" data-language="text"><code class="language-text">Nom : comprendre_une_d√©finition_du_petit_Robert
Entr√©es :
    m : un mot √† d√©finir
Programme :
    1. √©tant donn√© la d√©finition de m dans le dictionnaire du 'Petit Robert'
    2. afficher la d√©finition √† l'√©cran
    3. lire la d√©finition et l'
    4. pour chaque mot non compris dans la d√©finition :
       4.1. comprendre_une_d√©finition_du_petit_Robert(mot)</code></pre>
<p>C'est un algorithme tout √† fait valable. Ce n'est pas du python, mais c'est :</p>
<ul>
<li>compr√©hensible</li>
<li>chaque instruction (lire une d√©finition, comprendre un mot, ...) peut √™tre caract√©ris√©e par un petit texte en fran√ßais</li>
<li>notre algorithme s'arr√™te bien √† un moment (au pire une fois que l'on a pass√© en revue tous les mots du dictionnaire)</li>
</ul>
<p>R√®gles de construction de l'algorithme utilis√©es :</p>
<ul>
<li><strong>des</strong> param√®tres en entr√©e mais <strong>au plus une</strong> sortie (qui peut √™tre une structure compos√©e comme une liste par exemple).</li>
<li>le <strong>retour</strong> d'un algorithme est la derni√®re instruction qu'il fait, en rendant la sortie (ici, il ne rend rien)</li>
<li>une description de ce qu'il fait</li>
<li>l'ex√©cution d'un algorithme est signifi√© par son nom suivie de parenth√®ses contenant ses param√®tres</li>
<li>afficher √† l'√©cran n'est <strong>PAS</strong> un retour de fonction/m√©thode/algorithme : l'algorithme continue de fonctionner apr√®s l'affichage</li>
</ul>
<p>Donald Knuth (1938-) liste, comme pr√©requis d'un algorithme, <a href="https://fr.wikipedia.org/wiki/Algorithme#Quelques_d%C3%A9finitions_connexes">cinq propri√©t√©s</a> :</p>
<ul>
<li><strong>finitude</strong> : Un algorithme doit toujours se terminer apr√®s un nombre fini d‚Äô√©tapes.</li>
<li><strong>d√©finition pr√©cise</strong> : Chaque √©tape d'un algorithme doit √™tre d√©finie pr√©cis√©ment, les actions √† transposer doivent √™tre sp√©cifi√©es rigoureusement et sans ambigu√Øt√© pour chaque cas.</li>
<li><strong>entr√©es</strong> : [‚Ä¶] des quantit√©s qui lui sont donn√©es avant qu'un algorithme ne commence. Ces entr√©es sont prises dans un ensemble d'objets sp√©cifi√©.</li>
<li><strong>sortie</strong> : [‚Ä¶] des quantit√©s ayant une relation sp√©cifi√©e avec les entr√©es.</li>
<li><strong>rendement</strong> : [‚Ä¶] toutes les op√©rations que l'algorithme doit accomplir doivent √™tre suffisamment basiques pour pouvoir √™tre en principe r√©alis√©es dans une dur√©e finie par un homme utilisant un papier et un crayon.</li>
</ul>
<p>On peut en d√©duire la d√©finition suivante : Un <strong><em>algorithme</em></strong> est une succession d'instructions simples et clairement d√©finies. A partir d'entr√©es, il produit une sortie en un nombre fini d'instructions. Ou, de fa√ßon √©quivalente :</p>
<div id="r√®gles-g√©n√©rales"></div>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
</svg>
<div class="pl-8 mb-2 mr-8">
<p><strong>D√©finition</strong></p>
</div><div class="pl-8 mr-8">
<p>Un <strong><em>algorithme</em></strong> est d√©fini par les 4 propri√©t√©s suivantes :</p>
<ol>
<li>un algorithme est constitu√© d'un <strong>suite finie d'instructions</strong>, chacune d√©crite avec <strong>un nombre fini de symboles</strong></li>
<li>un humain doit pouvoir suivre chaque √©tape avec <strong>un papier et un crayon</strong></li>
<li>ex√©cuter une instruction <strong>ne doit pas n√©cessiter d'intelligence</strong> (√† part celle pour comprendre l'instruction)</li>
<li>l'algorithme produit un r√©sultat et s'arr√™te apr√®s <strong>un nombre fini d'√©tapes</strong> (une √©tape √©tant l'application d'une instruction) successives.</li>
</ol>
</div></div>

<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
</svg>
<div class="pl-8 mb-2 mr-8">
<p><strong>D√©finition</strong></p>
</div><div class="pl-8 mr-8">
<p>On appellera <strong><em>programme</em></strong> un texte qui ne respecte que les 3 premi√®res propri√©t√©s : un algorithme est un programme qui s'arr√™te.</p>
</div></div>

<p>Une recette de cuisine est donc un algorithme, un trajet google maps, etc.</p>
<div class="quote relative py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-emerald-500 bg-emerald-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-emerald-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
  <path stroke-linecap="round" stroke-linejoin="round" d="M13.19 8.688a4.5 4.5 0 011.242 7.244l-4.5 4.5a4.5 4.5 0 01-6.364-6.364l1.757-1.757m13.35-.622l1.757-1.757a4.5 4.5 0 00-6.364-6.364l-4.5 4.5a4.5 4.5 0 001.242 7.244"></path>
</svg>
<div class="pl-8 mr-8">
<p>N'h√©sitez pas √† regarder cette vid√©o, <a href="https://www.youtube.com/watch?v=d2a4MpY7I2w">petite biographie de Donald Knuth</a>, grand informaticien.</p>
</div></div>

<p>Prenons l'√©nonc√© suivant qui d√©crit une proc√©dure permettant de chercher un √©l√©ment particulier dans une suite finie de nombres :</p>
<pre class="language-text" tabindex="0" data-language="text"><code class="language-text">Demander √† l'utilisateur :
  - de donner un entier que l'on appellera x
  - de donner une suite d'entiers que l'on appellera t

Parcourir chaque √©l√©ment de t jusqu'√† trouver un √©l√©ment dont la valeur est √©gale √† la valeur de x.
Si on trouve un tel √©l√©ment, afficher "J'ai trouv√© ton entier dans la liste ! Je suis trop trop fort !" √† l'√©cran.</code></pre>
<p>Pour transformer cette description en programme/algorithme, il faut proc√©der √† plusieurs modifications :</p>
<ol>
<li>Un programme a un nom pour qu'on puisse le retrouver une fois d√©crit</li>
<li>L'utilisateur n'existe pas : un programme doit exister en tant que tel. Les entr√©es (demander des choses √† l'utilisateur) et les sorties (afficher des r√©sultats) sont abstraites :
<ul>
<li>on parle de param√®tres d'entr√©e du programme</li>
<li>on parle de sortie du programme (le programme rend quelque chose, comme une fonction)</li>
</ul>
</li>
</ol>
<p>En appliquant ces r√®gles, la description pr√©c√©dente devient :</p>
<pre class="language-text" tabindex="0" data-language="text"><code class="language-text">Nom : recherche
Entr√©es :
    t : un tableau d'entiers
    x : un entier
Programme :
    Parcourir chaque √©l√©ment de t jusqu'√† trouver un √©l√©ment dont la valeur est √©gale √† la valeur de x.
    Si on trouve un tel √©l√©ment, rendre "J'ai trouv√© ton entier dans la liste ! Je suis trop trop fort !".</code></pre>
<p>Il nous manque cependant encore une chose : si le programme s'arr√™te il doit rendre quelque chose, ce qui n'est pas le cas ici si on ne trouve pas <code class="language-">x</code> dans <code class="language-">t</code>. Modifions le :</p>
<pre class="language-text" tabindex="0" data-language="text"><code class="language-text">Nom : recherche
Entr√©es :
    t : un tableau d'entiers
    x : un entier
Programme :
    Parcourir chaque √©l√©ment de t jusqu'√† trouver un √©l√©ment dont la valeur est √©gale √† la valeur de x.
    Si on trouve un tel √©l√©ment, rendre "J'ai trouv√© ton entier dans la liste ! Je suis trop trop fort !".
    Sinon rendre "L'entier n'est pas dans la liste".</code></pre>
<p>Notre programme s'arr√™te tout le temps : c'est un algorithme.</p>
<p>On peut le rendre un peut plus professionnel en ne rendant pas une cha√Æne de caract√®re mais un bool√©en (<code>Vrai</code> s'il est dans la liste et <code>Faux</code> sinon) :</p>
<pre class="language-text" tabindex="0" data-language="text"><code class="language-text">Nom : recherche
Entr√©es :
    t : un tableau d'entiers
    x : un entier
Sortie :
    un bool√©en
Programme :
    Parcourir chaque √©l√©ment de t jusqu'√† trouver un √©l√©ment dont la valeur est √©gale √† la valeur de x.
    Si on trouve un tel √©l√©ment, rendre `Vrai`.
    Sinon rendre `Faux`.</code></pre>
<div class="quote relative py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-red-500 bg-red-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-red-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"></path>
</svg>
<div class="pl-8 mb-2 mr-8">
<p><strong>√Ä retenir</strong></p>
</div><div class="pl-8 mr-8">
<p>Un <strong>programme</strong> poss√®de :</p>
<ul>
<li>un nom</li>
<li>des param√®tres d'entr√©e (il peut y en avoir 0). Chaque param√®tre √† un nom qui pourra √™tre utilis√© dans la description du programme et un type qui d√©crit sa nature.</li>
<li>une sortie. Si le programme s'arr√™te il doit rendre quelque chose. La sortie doit toujours √™tre du m√™me type.</li>
<li>une description qui explicite ce qu'il fait.</li>
</ul>
<p>Si le programme s'arr√™te quelque soient ses entr√©es, c'est un <strong>algorithme</strong>.</p>
</div></div>

<div class="quote relative  py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-cyan-500 bg-cyan-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-cyan-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z"></path>
</svg>
<div class="pl-8 mr-8">
<p>Afficher un r√©sultat √† l'√©cran est diff√©rent de rendre un r√©sultat : le premier s'adresse √† un utilisateur et est <em>perdu</em>, le second peut √™tre √† nouveau utilis√© par au autre programme.</p>
</div></div>

<p>La d√©finition tr√®s g√©n√©rale d'un algorithme se d√©cline usuellement sous deux formes concr√®tes :</p>
<ol>
<li>le pseudo-code : l'√©criture (sans ordinateur) d'algorithmes en utilisant un nombre restreint d'instructions g√©n√©rales pr√©cis√©ment d√©finies. Un pseudo-code n'est pas directement fait pour √™tre ex√©cut√© par un ordinateur, m√™me si l'on peut utiliser la syntaxe d'un langage de programmation pour le d√©crire (le python, par exemple, est tr√®s utilis√© pour d√©crire des algorithmes). Le but ici est de montrer que l'on peut r√©soudre un probl√®me donn√© avec un algorithme.</li>
<li>le code : l'√©criture d'un programme pouvant s'ex√©cuter sur un ordinateur. Le but sera ici de faire en sorte de v√©rifier que le code correspond bien au pseudo-code et ‚Äî surtout ‚Äî de maintenir son fonctionnement au court du temps.</li>
</ol>
<p>Par exemple l'algorithme recherche s'√©crirait en pseudo-code de cette fa√ßon :</p>
<p><span id="algorithme-recherche"></span></p>
<pre class="language-pseudocode" tabindex="0" data-language="pseudocode"><code class="language-pseudocode"><span class="token builtin">algorithme</span> <span class="token function">recherche</span><span class="token punctuation">(</span>T<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token builtin">entier</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
                     x<span class="token punctuation">:</span> <span class="token builtin">entier</span>
                    <span class="token punctuation">)</span> <span class="token operator">‚Üí</span> <span class="token builtin">bool√©en</span><span class="token punctuation">:</span>

    <span class="token keyword">pour chaque</span> e de T<span class="token punctuation">:</span>
        <span class="token keyword">si</span> e <span class="token operator">==</span> x<span class="token punctuation">:</span>
            <span class="token keyword">rendre</span> <span class="token boolean">Vrai</span>
    <span class="token keyword">rendre</span> <span class="token boolean">Faux</span></code></pre>
<p>Et en code python (qui est tr√®s similaire au pseudo-code) :</p>
<pre class="language-python" tabindex="0" data-language="python"><code class="language-python"><span class="highlight-line"><span class="token keyword">def</span> <span class="token function">recherche</span><span class="token punctuation">(</span>T<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">:</span></span>
<span class="highlight-line">    <span class="token keyword">for</span> e <span class="token keyword">in</span> T<span class="token punctuation">:</span></span>
<span class="highlight-line">        <span class="token keyword">if</span> e <span class="token operator">==</span> x<span class="token punctuation">:</span></span>
<span class="highlight-line">            <span class="token keyword">return</span> <span class="token boolean">True</span></span>
<span class="highlight-line">    <span class="token keyword">return</span> <span class="token boolean">False</span></span></code></pre>
<p>Ces deux formes ont des buts diff√©rents, mais on ne peut exceller dans l'une sans conna√Ætre l'autre. Tout <em>th√©oricien</em> doit avoir de bonnes connaissances pratiques sur ce que peut calculer un ordinateur et ‚Äî t√¥t ou tard ‚Äî il devra programmer ses algorithmes. R√©ciproquement, tout <em>d√©veloppeur</em> doit avoir des connaissances fortes en algorithmie pour pouvoir √©crire du code performant.</p>
<p>Mais avant de n'utiliser plus que du pseudo-code, regardons ce que cela veut dire d'√©crire un algorithme de fa√ßon g√©n√©rale et sans autres contraintes que celle de la d√©finition.</p>
<h2>Objets manipulables par un programme</h2>
<p>Le terme <strong>fini</strong> de la d√©finition d'un programme/algorithme est crucial : pour qu'un humain comprenne, et surtout puisse agir, il faut que :</p>
<ul>
<li>chaque algorithme soit d√©cri par un texte <strong>fini</strong></li>
<li>chaque instruction doit s'ex√©cuter en un temps <strong>fini</strong></li>
<li>chaque donn√©e manipul√©e doit √™tre de taille <strong>finie</strong></li>
</ul>
<p>Donc la description du programme ainsi que les donn√©es doivent √™tre d√©crite avec un <em>&quot;langage&quot;</em> form√©  avec des <a href="https://fr.wikipedia.org/wiki/Mot_(math%C3%A9matiques)">mots d'un alphabet fini</a>.</p>
<p>Par exemple le programme suivant qui √©num√®re tous les entiers :</p>
<pre class="language-text" tabindex="0" data-language="text"><code class="language-text">Nom : √©num√®re
Programme :
    x = 0
    r√©p√©ter le bloc de deux instructions suivant :
        √©crire x en base 10 sur une feuille de papier
        x = x + 1</code></pre>
<p>M√™me si le programme ne s'arr√™te pas, chaque √©tape est bien finie :</p>
<ul>
<li><code>x</code> est toujours un entier que l'on peut d√©crire comme des mots de l'alphabet $\{0, 1, 2, 3, 4, 5, 6, 7, 8, 9\}$</li>
<li>√©crire un nombre sur une feuille de papier est toujours possible et prendra un temps proportionnel aux nombre de ses chiffres √† √©crire.</li>
<li>ajouter 1 √† <code>x</code> est possible en posant l'addition et cela prendra un temps proportionnel √† son nombre de chiffres et l'<a href="https://fr.wikipedia.org/wiki/Addition#Proc%C3%A9d%C3%A9_de_calcul">on peut d√©crire le principe de l'addition en fran√ßais</a>, donc avec un nombre fini de symboles (les lettres, les chiffres et quelques symboles de ponctuation)</li>
</ul>
<p>La cons√©quence fondamentale de ceci est que :</p>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
</svg>
<div class="pl-8 mb-2 mr-8">
<p><strong>Proposition</strong></p>
</div><div class="pl-8 mr-8">
<p>Un programme ne peut manipuler que des donn√©es de la forme d'une suite fini d'un ensemble fini.</p>
</div></div>

<div class="relative drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-indigo-500 bg-indigo-100">
<details class="group" open="">
<summary class="list-none py-0.5">
<svg class="group-open:hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M9 5l7 7-7 7"></path>
</svg>
<svg class="group-open:block hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7"></path>
</svg>
<div class="pl-8 font-bold inline-block">
<p>preuve</p>
</div>
<svg class="group-open:hidden inline-block pl-3 w-10 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M5 12h.01M12 12h.01M19 12h.01M6 12a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0z"></path>
</svg>
</summary>
<div class="mx-8 pb-2">
<p>Comme une donn√©e doit √™tre lue en temps finie, elle doit √™tre compos√©e d'une liste finie d'√©l√©ments. Si le nombre d'√©l√©ments possibles √©tait infini, il faudrait une description infinie de chaque instruction qui l'utiliserait.</p>
</div>
</details>     
</div>
<p>Une cons√©quence directe de la proposition pr√©c√©dente est :</p>
<div class="quote relative py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-red-500 bg-red-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-red-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"></path>
</svg>
<div class="pl-8 mb-2 mr-8">
<p><strong>√Ä retenir</strong></p>
</div><div class="pl-8 mr-8">
<p>un programme ne peut pas manipuler de nombres r√©els.</p>
</div></div>

<p>Un r√©el ne l'est pas : c'est une limite. C'est une abstraction que l'on peut consid√©rer comme ou une approximation (ne consid√©rer qu'un nombre fini de ses d√©cimales) ou un symbole. Prenons $\pi$ par exemple. Il existe des algorithmes qui <a href="https://fr.wikipedia.org/wiki/Approximation_de_%CF%80#Calcul_de_la_n-i%C3%A8me_d%C3%A9cimale_de_%CF%80">calculent les d√©cimales de pi</a>, mais on ne pourra jamais √©crire que le nombre $\pi$ est le r√©sultat d'un algorithme, puisque l'algorithme doit s'arr√™ter : on aura qu'un nombre fini de d√©cimales, pas le nombre $\pi$.</p>
<p>On ne pourra le consid√©rer que de deux mani√®res :</p>
<ul>
<li>soit comme un symbole et l'utiliser pour faire des op√©rations sur lui (comme $2 + \pi$, ou $\frac{3\pi}{3}$, ...) de fa√ßon formelle, c'est √† dire sans jamais conna√Ætre sa valeur</li>
<li>soit comme une valeur approch√©e de lui (3.1415 par exemple) et ainsi rendre des valeurs approch√©es des diff√©rentes op√©rations.</li>
</ul>
<p>Ce n'est pas bien grave en g√©n√©ral puisque les lois physiques sont presque tout le temps stables (de petits effets impliquent de petites causes) : consid√©rer les r√©els en <a href="https://fr.wikipedia.org/wiki/Notation_scientifique">notation scientifique</a> en se fixant une pr√©cision ne g√®ne pas les calculs physiques.</p>
<div class="quote relative  py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-cyan-500 bg-cyan-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-cyan-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z"></path>
</svg>
<div class="pl-8 mr-8">
<p>Faites tout de m√™me attention car parfois, c'est probl√©matique. Pour le calcul d'effets chaotiques comme la m√©t√©o o√π <a href="https://fr.wikipedia.org/wiki/Effet_papillon">de petits effets produisent de grandes causes</a>, certes, mais aussi lorsque l'on prend l'inverse de choses tr√®s petites qui du coup deviennent tr√®s grandes. Ce sont des probl√®mes dit de <a href="https://fr.wikipedia.org/wiki/Stabilit%C3%A9_num%C3%A9rique">stabilit√© num√©rique</a>.</p>
</div></div>

<p>Or :</p>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
</svg>
<div class="pl-8 mb-2 mr-8">
<p><strong>Proposition</strong></p>
</div><div class="pl-8 mr-8">
<p>Il existe une injection entre $(\mathcal{A})^\star$ et $(\{0, 1\})^\star$.</p>
</div></div>

<div class="quote relative  py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-cyan-500 bg-cyan-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-cyan-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z"></path>
</svg>
<div class="pl-8 mr-8">
<p>Pour un ensemble $\mathcal{A}$, on note $(\mathcal{A})^\star$ l'ensemble de toutes les suites finies d'√©l√©ments de $\mathcal{A}$.</p>
</div></div>

<div class="relative drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-indigo-500 bg-indigo-100">
<details class="group" open="">
<summary class="list-none py-0.5">
<svg class="group-open:hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M9 5l7 7-7 7"></path>
</svg>
<svg class="group-open:block hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7"></path>
</svg>
<div class="pl-8 font-bold inline-block">
<p>preuve</p>
</div>
<svg class="group-open:hidden inline-block pl-3 w-10 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M5 12h.01M12 12h.01M19 12h.01M6 12a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0z"></path>
</svg>
</summary>
<div class="mx-8 pb-2">
<p>On va le montrer avec les cha√Ænes de caract√®res pour se fixer les id√©es mais la g√©n√©ralisation √† tout ensemble $\mathcal{A}$ est triviale.</p>
<p>On consid√®re l'ensemble des caract√®res des diff√©rentes langues √©crites actuelles ou pass√©e. Cet ensemble est fini et existe ! C'est l'ensemble <a href="https://fr.wikipedia.org/wiki/Unicode">des caract√®res UNICODE</a> que l'on va noter $\mathcal{U}$. Il est constitu√© de 159801 caract√®res (appel√©es glyphes) dont chacun est associ√© un num√©ro. Par exemple le caract√®re 'A' est associ√© au num√©ro 65 et 'ëí£' au num√©ro 70820.</p>
<p>Une cha√Æne de caract√®re $(c_i)_{0\leq i &lt; n}$ est alors une suite de $6n$ chiffres. Par exemple : &quot;Coucou toi !&quot; correspond au nombre :</p>
<div>
$$
\underbracket{000067}_{\text{C}}\underbracket{000111}_{\text{o}}\underbracket{000117}_{\text{u}}\underbracket{000099}_{\text{c}}\underbracket{000111}_{\text{o}}\underbracket{000117}_{\text{u}}\underbracket{000032}_{\text{ }}\underbracket{000116}_{\text{t}}\underbracket{000111}_{\text{o}}\underbracket{000105}_{\text{i}}\underbracket{000032}_{\text{ }}\underbracket{000033}_{\text{!}}
$$
</div>
<p>Pour √©viter tout soucis avec des donn√©es commen√ßant par le caract√®re Unicode de nombre 0 (un m√™me nombre peut avoir autant de chiffre 0 qu'il veut au d√©but), on fait commencer toute donn√©es par le chiffre 1. La cha√Æne de caract√®res  &quot;Coucou toi !&quot; correspond ainsi au nombre :</p>
<div>
$$
1000067000111000117000099000111000117000032000116000111000105000032000033
$$
</div>
<p>Qui en notation binaire devient la suite finie :</p>
<div>
$$
\begin{array}{l}
100100001110011010001011111100110010100110001101001001110110\\
101110011110110011000001101011011000000011010110111111101110\\
110101111000001001010010110011110000101011001101011000010110\\
011100101110101111101010100111000001111101111101100000100001
\end{array}
$$
</div>
<p>On associe bien de fa√ßon unique √† toute cha√Æne de caract√®res $(c_i)_{0\leq i &lt; n}$ un √©l√©ment de l'ensemble $(\{0, 1\})^\star$.</p>
</div>
</details>     
</div>
<div class="quote relative  py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-cyan-500 bg-cyan-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-cyan-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z"></path>
</svg>
<div class="pl-8 mr-8">
<blockquote>
<p>TBD ici
Ils sont m√™me en bijection</p>
</blockquote>
<blockquote>
<p>TBD preuve du th√©or√®me (voir Wikipedia) avec <a href="https://fr.wikipedia.org/wiki/Th%C3%A9or%C3%A8me_de_Cantor-Bernstein#Lemme_pr%C3%A9liminaire">le lemme pr√©liminaire</a> (on va en avoir besoin ?)</p>
</blockquote>
<p>Notre transformation est une injection de l'ensemble des suites finies de caract√®res vers l'ensemble des suites finies de $\{0, 1\}$. Comme <code>0</code> et <code>1</code> sont √©galement des caract√®res Unicode (de num√©ros 48 et 49 respectivement), il existe √©galement une injection de
$(\{0, 1\})^\star$ vers $(\mathcal{U})^\star$.</p>
<p>On peut alors utiliser <a href="https://fr.wikipedia.org/wiki/Th%C3%A9or%C3%A8me_de_Cantor-Bernstein">le th√©or√®me de Cantor-Bernstein</a> pour conclure qu'il existe une bijection entre les 2 ensembles (s'il existe une injection de $A$ vers $B$ et une injection de $B$ vers $A$ alors il existe une bijection entre $A$ et $B$).</p>
</div></div>

<p>On en conclut le r√©sultat que tout le monde conna√Æt :</p>
<p><span id="param√®tres-binaires"></span></p>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
</svg>
<div class="pl-8 mb-2 mr-8">
<p><strong>Proposition</strong></p>
</div><div class="pl-8 mr-8">
<p>Tout ce que peut manipuler un programme est une suite finie de caract√®res <code>0</code> et <code>1</code>.</p>
</div></div>

<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
</svg>
<div class="pl-8 mb-2 mr-8">
<p><strong>D√©finition</strong></p>
</div><div class="pl-8 mr-8">
<p>Un caract√®re (<code>0</code> ou <code>1</code>) <a href="https://fr.wikipedia.org/wiki/Bit">est appel√© <strong><em>bit</em></strong></a>.</p>
</div></div>

<p>Cependant n'utiliser que des tableaux de bits (dont le type est <code>[bit]</code>) pour nos programmes les rendrait illisible. On d√©fini donc d'autres types qui repr√©sentent nos donn√©es dont les plus classiques sont :</p>
<ul>
<li>les entiers relatifs :
<ul>
<li>positifs en utilisant leur notation binaire et en les faisant commencer par un <code>0</code>, par exemple 3 sera encod√© par <code>011</code> (le <code>0</code> tout √† gauche signifiant que l'entier est positif)</li>
<li>n√©gatifs en utilisant <a href="https://fr.wikipedia.org/wiki/Compl%C3%A9ment_%C3%A0_deux">le compl√©ment √† deux</a> de la repr√©sentation binaire de son oppos√©. Ainsi -3 sera encod√© par <code>101</code> (un entier n√©gatif ainsi repr√©sent√© commencera toujours par un <code>1</code>)</li>
</ul>
</li>
<li>des approximations finies de r√©els : on peut utiliser la norme <a href="https://fr.wikipedia.org/wiki/IEEE_754">IEEE 754</a>. Par exemple 3.1415 en codage IEEE 754 sur 32 bits correspond √† l'entier binaire : <code>01000000010010010000111001010110</code> (j'ai utilis√© <a href="https://www.h-schmidt.net/FloatConverter/IEEE754.html">un convertisseur</a>)</li>
<li>des cha√Ænes de caract√®res : que l'on peut repr√©senter comme un entier. Par exemple la cha√Æne de caract√®res &quot;Yop !&quot; correspond en utf-8 au nombre hexad√©cimal 0x596F702021 (l√† aussi, j'ai utilis√© <a href="http://hapax.qc.ca/conversion.fr.html">un convertisseur</a>) qui en binaire vaut : <code>0000010110010110111101110000001000000010</code></li>
</ul>
<p>On peut aller plus loin en repr√©sentant les tableaux de suites finies de &quot;0&quot; et de &quot;1&quot; par une unique suite finie de &quot;0&quot; et de &quot;1&quot;. Pour cela on peut utiliser l'encodage suivant :</p>
<ul>
<li>le caract√®re <code>0</code> est encod√© par la suite <code>100</code></li>
<li>le caract√®re <code>1</code> est encod√© par la suite <code>101</code></li>
<li>le caract√®re de s√©paration est encod√© par la suite <code>000</code></li>
<li>le caract√®re de d√©but de liste est encod√© par la suite <code>010</code></li>
<li>le caract√®re de fin de liste est encod√© par la suite <code>001</code></li>
</ul>
<p>Ainsi le tableau <code>[00110, 110]</code> sera encod√© par la suite <code>010100100101101100000101101100001</code>. Notez que cet encodage permet d'encoder tout aussi ais√©ment les listes imbriqu√©es de suites finies de 0 et de 1, comme <code>[0, [1, [1]], 0]</code>, chaque caract√®re n√©cessaire (<code>0</code>, <code>1</code>, <code>,</code>, <code>[</code> et <code>]</code>) ayant son propre code sur 3 bits. Cette astuce vas nous permettre de compter tous les programmes possible !</p>
<h2>Nombre de programmes</h2>
<blockquote>
<p>TBD ici</p>
</blockquote>
<p>La d√©finition g√©n√©rale d'un programme stipule qu'il doit √™tre constitu√© d'un nombre <strong>fini</strong> d'instructions, chaque instruction d√©crite par un nombre <strong>fini</strong> de symboles. De plus, c'est implicite, mais un programme doit √™tre compris par un humain.</p>
<p>Un bit est l'information minimale que l'on peut v√©hiculer puisqu'il ne peut avoir que 2 valeurs diff√©rentes. Cette unit√© minimale d'information est tr√®s puissante puisque les suites finies de bits permettent non seulement de stocker tous les objets que peut manipuler un algorithme mais aussi les algorithmes eux-m√™me via le codage binaires des chaines Unicode par exemple. On en conclut que :</p>
<div class="quote relative py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-red-500 bg-red-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-red-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"></path>
</svg>
<div class="pl-8 mb-2 mr-8">
<p><strong>√Ä retenir</strong></p>
</div><div class="pl-8 mr-8">
<p>Un algorithme et tout ce qu'il peut manipuler est une suite finie de <code>0</code> et de <code>1</code>.</p>
</div></div>

<h3>Une infinit√© de programmes diff√©rents</h3>
<p>On va se concentrer sur les algorithmes puisque tout algorithme est un programme. De la d√©finition d'un algorithme on peut donc d√©j√† conclure que :</p>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
</svg>
<div class="pl-8 mb-2 mr-8">
<p><strong>Proposition</strong></p>
</div><div class="pl-8 mr-8">
<p>Il existe une infinit√© d'algorithmes diff√©rents.</p>
</div></div>

<div class="relative drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-indigo-500 bg-indigo-100">
<details class="group" open="">
<summary class="list-none py-0.5">
<svg class="group-open:hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M9 5l7 7-7 7"></path>
</svg>
<svg class="group-open:block hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7"></path>
</svg>
<div class="pl-8 font-bold inline-block">
<p>preuve</p>
</div>
<svg class="group-open:hidden inline-block pl-3 w-10 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M5 12h.01M12 12h.01M19 12h.01M6 12a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0z"></path>
</svg>
</summary>
<div class="mx-8 pb-2">
<p>Si on consid√®re l'instruction <code class="language-">Ne fait rien</code>, le texte ci-dessous est un algorithme d'une instruction :</p>
<pre class="language-text" tabindex="0" data-language="text"><code class="language-text">Ne fait rien</code></pre>
<p>En notant alors $R_k$ ($k &gt;0$) l'algorithme de $k$ instructions <code class="language-">Ne fait rien</code> √† la suite (l'algorithme pr√©c√©dent est $R_1$).</p>
<p>Les algorithmes $R_k$ sont tous diff√©rents puisque leurs suites d'instructions sont diff√©rentes : il existe donc une infinit√© d'algorithmes diff√©rents.</p>
</div>
</details>     
</div>
<p>De la preuve de la proposition pr√©c√©dente montre qu'il existe une infinit√© d‚Äôalgorithmes diff√©rents mais faisant la m√™me chose : tous les algorithmes $R_k$ pour $k$ entier font la m√™me chose, rien.</p>
<div class="quote relative  py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-cyan-500 bg-cyan-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-cyan-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z"></path>
</svg>
<div class="pl-8 mr-8">
<p>On y reviendra, mais savoir ce que fait un algorithme n'est pas un probl√®me simple du tout dans le cas g√©n√©ral.</p>
</div></div>

<p>Mais, on peut aussi d√©montrer :</p>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
</svg>
<div class="pl-8 mb-2 mr-8">
<p><strong>Proposition</strong></p>
</div><div class="pl-8 mr-8">
<p>Il existe une infinit√© d'algorithmes faisant des choses deux √† deux diff√©rentes.</p>
</div></div>

<div class="relative drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-indigo-500 bg-indigo-100">
<details class="group" open="">
<summary class="list-none py-0.5">
<svg class="group-open:hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M9 5l7 7-7 7"></path>
</svg>
<svg class="group-open:block hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7"></path>
</svg>
<div class="pl-8 font-bold inline-block">
<p>preuve</p>
</div>
<svg class="group-open:hidden inline-block pl-3 w-10 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M5 12h.01M12 12h.01M19 12h.01M6 12a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0z"></path>
</svg>
</summary>
<div class="mx-8 pb-2">
<p>On peut par exemple consid√©rer la familles $A_k$ d'algorithmes ($k &gt; 0$) d√©finis tels que $A_k$ soit constitu√© d'une seule instruction :</p>
<pre class="language-text" tabindex="0" data-language="text"><code class="language-text">Rend l'entier k</code></pre>
<p>Les $A_k$ sont bien des algorithmes puisque chaque entier $k$ se d√©crit avec un nombre fini de chiffres. De plus, les $A_k$ rendent tous des entiers diff√©rents.</p>
</div>
</details>     
</div>
<p>Il y a donc <strong>beaucoup</strong> d'algorithmes possibles... mais en r√©alit√© pas tant que √ßa.</p>
<h3>Mais seulement une infinit√© d√©nombrable</h3>
<p>D'apr√®s ce qui pr√©c√®de, un algorithme est un texte. On peut alors consid√©rer que les symboles formant la description de chaque instruction sont des caract√®res pris dans un alphabet. Pour ne pas √™tre chiche, on peut prendre l'alphabet <a href="https://fr.wikipedia.org/wiki/Unicode">Unicode</a> qui permet d'√©crire, entre autres, en Fran√ßais et contient un peut moins de 150000 caract√®res diff√©rents.</p>
<p>De l√† :</p>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
</svg>
<div class="pl-8 mb-2 mr-8">
<p><strong>Proposition</strong></p>
</div><div class="pl-8 mr-8">
<p>Un <strong><em>programme</em></strong> est une suite finie $c_1 \dots c_n$ o√π :</p>
<ul>
<li>$c_i \in \mathcal{U}$ pour tout $1 \leq i \leq n$</li>
<li>avec $\mathcal{U}$ l'ensemble des caract√®res <a href="https://fr.wikipedia.org/wiki/Unicode">Unicode</a>, $\vert \mathcal{U} \vert \leq 150000$.</li>
</ul>
<p>On note $\mathcal{A}$ cet ensemble.</p>
</div></div>

<div class="relative drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-indigo-500 bg-indigo-100">
<details class="group" open="">
<summary class="list-none py-0.5">
<svg class="group-open:hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M9 5l7 7-7 7"></path>
</svg>
<svg class="group-open:block hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7"></path>
</svg>
<div class="pl-8 font-bold inline-block">
<p>preuve</p>
</div>
<svg class="group-open:hidden inline-block pl-3 w-10 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M5 12h.01M12 12h.01M19 12h.01M6 12a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0z"></path>
</svg>
</summary>
<div class="mx-8 pb-2">
<p>Un algorithme est compos√©e d'une suite finie d'instruction. Comme chaque instruction peut √™tre nomm√©e par un texte et que chaque instruction est d√©crite un texte en Fran√ßais, tout algorithme est une suite de caract√®res Unicode.</p>
</div>
</details>     
</div>
<p>Bref, les programmes correspondent √† un sous-ensemble de l'ensemble des cha√Ænes de caract√®res √©crites en Unicode. On peut alors utiliser l'ordre entre caract√®res Unicode (chaque caract√®re est identifi√© par un entier) pour ordonner les algorithmes selon l'ordre du dictionnaire :</p>
<div id="encodage-algorithme"></div>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
</svg>
<div class="pl-8 mb-2 mr-8">
<p><strong>Proposition</strong></p>
</div><div class="pl-8 mr-8">
<p>On peut associer √† toute cha√Æne de caract√®re un entier strictement positif unique.</p>
</div></div>

<div class="relative drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-indigo-500 bg-indigo-100">
<details class="group" open="">
<summary class="list-none py-0.5">
<svg class="group-open:hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M9 5l7 7-7 7"></path>
</svg>
<svg class="group-open:block hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7"></path>
</svg>
<div class="pl-8 font-bold inline-block">
<p>preuve</p>
</div>
<svg class="group-open:hidden inline-block pl-3 w-10 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M5 12h.01M12 12h.01M19 12h.01M6 12a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0z"></path>
</svg>
</summary>
<div class="mx-8 pb-2">
<blockquote>
<p>TBDici reprendre la bijection et prendre le nombre associ√©.</p>
</blockquote>
</div>
</details>     
</div>
<p>On d√©duit imm√©diatement la proposition suivante :</p>
<p><span id="nb-d√©nombrable-algorithmes"></span></p>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
</svg>
<div class="pl-8 mb-2 mr-8">
<p><strong>Proposition</strong></p>
</div><div class="pl-8 mr-8">
<p>Il y a exactement autant d'algorithmes diff√©rents que de nombres entiers.</p>
</div></div>

<div class="relative drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-indigo-500 bg-indigo-100">
<details class="group" open="">
<summary class="list-none py-0.5">
<svg class="group-open:hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M9 5l7 7-7 7"></path>
</svg>
<svg class="group-open:block hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7"></path>
</svg>
<div class="pl-8 font-bold inline-block">
<p>preuve</p>
</div>
<svg class="group-open:hidden inline-block pl-3 w-10 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M5 12h.01M12 12h.01M19 12h.01M6 12a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0z"></path>
</svg>
</summary>
<div class="mx-8 pb-2">
<p>Comme √† chaque algorithme est associ√© un entier strictement positif unique, on peut les ranger par nombre croissant et consid√©rer la suite d'algorithmes $(A_k)_{k \geq 1}$ telle que :</p>
<ul>
<li>$A_1$ est l'algorithme de plus petit nombre associ√©</li>
<li>pour $k &gt; 1$, $A_k$ est l'algorithme est dont le nombre associ√© est le plus petit qui est plus grand que le nombre associ√© √† $A_{k-1}$</li>
</ul>
<p>On a alors :</p>
<ul>
<li>$A_k$ existe pour entier $k$ (puisqu'il y a une infinit√© d'algorithmes diff√©rents, donc de descriptions diff√©rentes)</li>
<li>pour tout algorithme $A$, il existe $k$ telle que $A=A_k$</li>
</ul>
<p>Ce qui implique que la fonction qui associe √† tout algorithme sa position dans la suite $(A_k)_{k \geq 1}$ est une bijection entre l'ensemble des algorithmes et l'ensemble des entiers strictement positifs.</p>
</div>
</details>     
</div>
<p>La preuve ci-dessus est classique. Lorsqu'il y a un nombre infini de choses d√©nombrable, il y en a autant que d'entiers. C'est pourquoi il y a autant d'entiers pair que d'entiers impair que de multiples de 42.</p>
<h3>Nombres r√©els sans algorithme</h3>
<p>Savoir qu'il n'y a pas plus d'algorithmes que de nombres entiers est une tr√®s information tr√®s importante car elle montre qu'un algorithme ne peut pas tout faire. En effet :</p>
<p><span id="diagonale-cantor"></span></p>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
</svg>
<div class="pl-8 mb-2 mr-8">
<p><strong>Th√©or√®me</strong></p>
</div><div class="pl-8 mr-8">
<p>Il existe strictement plus de nombres r√©els dans l'intervalle $[0, 1]$ que de nombres entiers strictement positifs.</p>
</div></div>

<div class="relative drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-indigo-500 bg-indigo-100">
<details class="group" open="">
<summary class="list-none py-0.5">
<svg class="group-open:hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M9 5l7 7-7 7"></path>
</svg>
<svg class="group-open:block hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7"></path>
</svg>
<div class="pl-8 font-bold inline-block">
<p>preuve</p>
</div>
<svg class="group-open:hidden inline-block pl-3 w-10 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M5 12h.01M12 12h.01M19 12h.01M6 12a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0z"></path>
</svg>
</summary>
<div class="mx-8 pb-2">
<p>On doit cette preuve magnifique au math√©maticien allemand <a href="https://fr.wikipedia.org/wiki/Georg_Cantor">Georg Cantor</a>. Elle est bas√©e sur l'argument s'appelant <a href="https://fr.wikipedia.org/wiki/Argument_de_la_diagonale_de_Cantor#La_non-d%C3%A9nombrabilit%C3%A9_des_r%C3%A9els">diagonale de Cantor</a>.</p>
<p>On commence en remarquant que l'on peut associer √† tout entier $i$ form√© des chiffres $c_1\dots c_k$ le r√©el de repr√©sentation d√©cimale $0.c_1\dots c_k$, ce qui d√©montre qu'il y a au moins autant de r√©els dans $[0, 1]$ que de nombres entiers.</p>
<p>On suppose ensuite qu'il existe une injection $f: [0, 1] \rightarrow \mathbb{N}$ entre les r√©els de l'intervalle $[0, 1]$ et les entiers. On peut alors classer tous les r√©els selon leurs valeurs selon $f$ :</p>
<ul>
<li>on appelle $r_1$ le 1er r√©el, c'est √† dire celui tel que $f(r_1) \leq f(x)$, quelque soit $x \in [0, 1]$</li>
<li>on appelle $r_2$ le second r√©el $r_2$ , c'est √† dire celui tel que $f(r_2) \leq f(x)$ pour tout $x \in [0, 1] \backslash \{ r_1 \}$</li>
<li>...</li>
<li>on appelle $r_i$ le $i$√®me r√©el : $f(r_i) \leq f(x)$ pour tout $x \in [0, 1] \backslash \{ r_1, \dots, r_{i-1} \}$</li>
<li>...</li>
</ul>
<p>Chaque r√©el pouvant s'√©crire sous sa repr√©sentation d√©cimale (par exemple $0.1034842$), on construit le nombre r√©el $r$ de $[0, 1]$ tel que sont $i$√®me chiffre apr√®s la virgule soit :</p>
<ul>
<li>$1$ si le $i$√®me chiffre apr√®s la virgule de $r_i$ est diff√©rent de $1$</li>
<li>$2$ si le $i$√®me chiffre apr√®s la virgule de $r_i$ est $1$</li>
</ul>
<p>Le nombre $r$ est bien dans $[0, 1]$ mais il ne peut pas √™tre $r_i$ quelque soit $i$ ! Il y a une contradiction (comme notre nombre ne finit ni par 9 ni par 0 il a <a href="https://fr.wikipedia.org/wiki/D%C3%A9veloppement_d%C3%A9cimal#Cas_des_nombres_r%C3%A9els">un unique d√©veloppement d√©cimal</a>, il appara√Æt forc√©ment dans notre liste). Notre hypoth√®se √©tait donc fausse, il ne peut exister d'injection entre les r√©els de l'intervalle $[0, 1]$ et les entiers.</p>
<p>Il y a donc strictement plus de r√©els dans $[0, 1]$ que d'entiers.</p>
</div>
</details>     
</div>
<p>Le fait qu'il y ait des infinis plus ou moins gros est un r√©sultat que l'on doit √† Cantor et qui est tr√®s profond. On note commun√©ment $\aleph_0$ le nombre d'entiers qui est strictement plus petit que le nombre de r√©els, not√© $\aleph_1$. Une question reste encore en suspend, mais on a pour l'instant toujours pas la r√©ponse, c'est : y a-t-il un infini entre $\aleph_0$ et $\aleph_1$ ? On ne sais pas, mais on pense que non. C'est l'<a href="https://fr.wikipedia.org/wiki/Hypoth%C3%A8se_du_continu">hypoth√®se du continu</a>.</p>
<div class="quote relative  py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-cyan-500 bg-cyan-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-cyan-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z"></path>
</svg>
<div class="pl-8 mr-8">
<p>Pour une introduction en douceur sur ces sujets, consulter <a href="https://www.arte.tv/fr/videos/097454-005-A/voyages-au-pays-des-maths/">cette √©mission d'Arte</a>, tr√®s bien faite.</p>
</div></div>

<p>On d√©duit du th√©or√®me pr√©c√©dent que :</p>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
</svg>
<div class="pl-8 mr-8">
<p>Il existe des r√©els pour lesquels il n'existe aucun algorithme $A(i)$ qui calcule la $i$√®me d√©cimale de $i$ quelque soit $i$</p>
</div></div>

<p>Trouver de tels nombres est compliqu√©, car pour y penser il faut le d√©crire et donc en proposer un algorithme... Mais... ils existent (nous en verrons un plus tard).</p>
<h2>Algorithmes et d√©monstration math√©matiques</h2>
<p>On n'en parlera pas trop dans ce cours (√† moins que vous me le demandiez tr√®s fort) mais, en gros, les math√©matiques sont une partie de l'informatique (certains diraient m√™me, et r√©ciproquement. Des math√©maticiens certainement...).</p>
<p>De fa√ßon plus pr√©cise on a la suite d'√©quivalences :</p>
<ol>
<li>faire une d√©monstration consiste ‚Äî √† partir d'une s√©rie finie d'axiomes ‚Äî √† effectuer une suite finie de d√©ductions pour parvenir √† un r√©sultat. (<a href="https://fr.wikipedia.org/wiki/Aristote#Enqu%C3%AAte,_d%C3%A9monstration_et_syllogisme">Aristote</a>, en -350 environ)</li>
<li>(1) est √©quivalent √† d√©montrer √† l'aide d'une suite finie de d√©ductions qu'une proposition logique est vraie (<a href="https://fr.wikipedia.org/wiki/Syst%C3%A8me_%C3%A0_la_Hilbert">Hilbert</a>, d√©but XXe si√®cle)</li>
<li>(en passant, <a href="https://fr.wikipedia.org/wiki/Th%C3%A9or%C3%A8mes_d%27incompl%C3%A9tude_de_G%C3%B6del">G√∂del</a>, en 1931, d√©montre qu'il existe des propositions logiques qui sont vraies mais qu'il est impossible de d√©montrer)</li>
<li><a href="https://fr.wikipedia.org/wiki/Correspondance_de_Curry-Howard">Curry puis Howard qui g√©n√©ralise</a>, en 1950 et 1980, montrent que (2) est √©quivalent √† √©crire en terme de <a href="https://fr.wikipedia.org/wiki/Lambda-calcul">$\lambda$-calcul</a></li>
<li><a href="https://fr.wikipedia.org/wiki/Alan_Turing">Turing</a> d√©montre en 1937, que (4) est √©quivalent √† √©crire une machine de Turing.</li>
<li>(en passant, Turing d√©montre qu'il existe des machines de Turing qui ne s'arr√™tent jamais et que savoir si une machine de Turing va s'arr√™ter est <a href="https://fr.wikipedia.org/wiki/Probl%C3%A8me_de_l%27arr%C3%AAt">ind√©cidable</a>, ce qui est √©quivalent √† (3))</li>
</ol>


</article>
    </main>

    <footer class="min-h-[50px] border-t-2 border-gray-200 mt-4">
      <div class="max-w-[1200px] mx-auto px-4 relative">
        <div class="min-h-[50px] flex justify-center items-center">
          <p>
            Cours d'informatique de Fran√ßois Brucker
          </p>
        </div>
        <div class="min-h-[50px] flex justify-center items-center absolute right-0 top-0">
          <button onclick="goTop()" id="myBtn" title="Go to top">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
              <path stroke-linecap="round" stroke-linejoin="round" d="M15 11.25l-3-3m0 0l-3 3m3-3v7.5M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
            </svg>
          </button>

          <button onclick="goBottom()" id="myBtn" title="Go to top">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
              <path stroke-linecap="round" stroke-linejoin="round" d="M9 12.75l3 3m0 0l3-3m-3 3v-7.5M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
            </svg>
          </button>
        </div>

      </div>
    </footer>

    <script>
      MathJax
        .startup
        .document
        .getMathItemsWithin(document.body);
    </script>

  </body>
</html>