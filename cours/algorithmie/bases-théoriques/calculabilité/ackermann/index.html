<!DOCTYPE html>
<html lang="fr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>Fonction d&#39;Ackermann</title>

    

    <link href="https://prismjs.catppuccin.com/latte.css" rel="stylesheet">

    <link href="/cours_informatique/assets/node_modules/prismjs/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet">
    <script src="/cours_informatique/assets/node_modules/prismjs/plugins/line-numbers/prism-line-numbers.min.js"></script>
    
    <link href="/cours_informatique/assets/stylesheets/main.css" rel="stylesheet">

  </head>
  <body>
    <script>
      window.MathJax = {
        tex: {
          inlineMath: [
            [
              '$', '$'
            ],
            [
              '\\(', '\\)'
            ]
          ]
        },
        svg: {
          fontCache: 'global'
        }
      };

      function goTop() {
        window.scrollTo({top: 0});
      }
      function goBottom() {
        window.scrollTo({top: document.body.scrollHeight});
      }
    </script>
    <script type="text/javascript" id="MathJax-script" src="/cours_informatique/assets/node_modules/mathjax/es5/tex-svg-full.js"></script>

    <header class="border-b-2 border-gray-200 mb-4">
      <div class="max-w-[1200px] mx-auto px-4 relative">
        <div class="min-h-[50px] flex justify-between items-center">
          <a class="mx-2" href="/cours_informatique/">Home</a>
        </div>

        <div class="min-h-[50px] flex justify-center items-center absolute right-0 top-0">
          <a class="mx-2" href="/cours_informatique/about">About</a>
          <button onclick="goTop()" id="myBtn" title="Go to top">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
              <path stroke-linecap="round" stroke-linejoin="round" d="M15 11.25l-3-3m0 0l-3 3m3-3v7.5M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
            </svg>
          </button>

          <button onclick="goBottom()" id="myBtn" title="Go to top">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
              <path stroke-linecap="round" stroke-linejoin="round" d="M9 12.75l3 3m0 0l3-3m-3 3v-7.5M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
            </svg>
          </button>
        </div>

      </div>
    </header>

    <main class="max-w-[1200px] mx-auto px-4">
      
<article>

  <h1>Fonction d&#39;Ackermann</h1>
  <div>
    

    
  </div>

  

    
<div class="quote relative  py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-purple-500 bg-purple-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-purple-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M5 19a2 2 0 01-2-2V7a2 2 0 012-2h4l2 2h4a2 2 0 012 2v1M5 19h14a2 2 0 002-2v-5a2 2 0 00-2-2H9a2 2 0 00-2 2v5a2 2 0 01-2 2z"></path>
</svg>
<div class="pl-8 mr-8">

<a class="interne" href="/cours_informatique/cours/">Cours</a><span class="px-1">/</span><a class="interne" href="/cours_informatique/cours/algorithmie/">Algorithmie</a><span class="px-1">/</span><a class="interne" href="/cours_informatique/cours/algorithmie/bases-théoriques/">Bases théoriques</a><span class="px-1">/</span><a class="interne" href="/cours_informatique/cours/algorithmie/bases-théoriques/calculabilité/">Calculabilité</a><span class="px-1">/</span><a class="interne" href="/cours_informatique/cours/algorithmie/bases-théoriques/calculabilité/ackermann/">Fonction d&#39;Ackermann</a>

</div></div>



    
  

  <p>La <a href="https://fr.wikipedia.org/wiki/Fonction_d%27Ackermann">fonction d'Ackermann</a>, outre le fait qu'elle est rigolote car elle croît très très rapidement (plus que factoriel, c'est dire), est importante théoriquement car c'est le premier exemple connu de fonction calculable mais non primitive récursive.</p>
<p>Elle se définit de la manière suivante, pour tous entiers $m$ et $n$ positifs :</p>
<div>
$$
\text{Ack}(m, n) = \left\{
    \begin{array}{ll}
        n + 1 & \mbox{si } m = 0 \\
        \text{Ack}(m - 1, 1) & \mbox{si } n = 0 \\
        \text{Ack}(m - 1, \text{Ack}(m, n - 1)) & \mbox{sinon.}
    \end{array}
\right.
$$
</div>
<p>Nous allons dans cette partie montrer que la définition précédente est bien calculable, puis donner une idée de ses valeurs.</p>
<h2>Existence</h2>
<p>Pour chaque appel récursif de la fonction d'Ackermann, soit $m$, soit $n$ est strictement plus petit dans la fonction appelée que dans la fonction appelante. On arrivera donc toujours à $m = 0$ qui stoppera la récursion ou $n = 0$ qui fera baisser la valeur de $m$. Il n'y aura donc toujours qu'un nombre finie de récursion pour tout couple $(m, n)$.</p>
<p>Montrons le formellement :</p>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
</svg>
<div class="pl-8 mb-2 mr-8">
<p><strong>Proposition</strong></p>
</div><div class="pl-8 mr-8">
<p>La fonction d'Ackermann est bien définie (nécessite un nombre fini de recursion pour être calculée) pour tous $m$ et $n$ entiers positifs.</p>
</div></div>

<div class="relative drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-indigo-500 bg-indigo-100">
<details class="group" open="">
<summary class="list-none py-0.5">
<svg class="group-open:hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M9 5l7 7-7 7"></path>
</svg>
<svg class="group-open:block hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7"></path>
</svg>
<div class="pl-8 font-bold inline-block">
<p>preuve</p>
</div>
<svg class="group-open:hidden inline-block pl-3 w-10 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M5 12h.01M12 12h.01M19 12h.01M6 12a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0z"></path>
</svg>
</summary>
<div class="mx-8 pb-2">
<p>On va montrer par récurrence sur $m$ que la fonction $A_m(n) = \text{Ack}(m, n)$ se calcule en un nombre fini de recursion pour tout $n$.</p>
<p><strong>Initialisation (1) :$ m = 0$</strong>. Puisque $A_0(n) = n+1$, la proposition est vérifiée.</p>
<p><strong>Soit un entier $m\geq 0$ et supposons que $A_{m'}(x)$ se calcule en un nombre fini de récursion pour tout $m'\leq m$ et tout $x\geq 0$.</strong>. Démontrons que $A_{m+1}(n)$ se calcule en un nombre fini de recursion pour pour tout $n\geq 0$. On va le faire également par récurrence, mais sur $n$.</p>
<p><strong>Initialisation (2) :$ n = 0$</strong>. On a $A_{m+1}(0) = A_{m}(1)$ qui se calcule en un nombre fini de récursion par l'hypothèse de récurrence sur $m$.</p>
<p><strong>Soit un entier $n\geq 0$ et supposons que $A_{m+1}(n')$ se calcule en un nombre fini de récursion pour tout $n'\leq n$</strong>. Comme on a $A_{m+1}(n+1) = A_{m}(A_{m+1}(n))$ et que :</p>
<ul>
<li>par hypothèse de récurrence sur $n$, $A_{m+1}(n)$ se calcule en un nombre fini de recursion,</li>
<li>par hypothèse de récurrence sur $m$, $A_{m}(x)$ se calcule en un nombre fini de recursion pour tout $x$.</li>
</ul>
<p>Le nombre total de récursions est fini, ce qui conclut la preuve par récurrence sur $n$ : <strong>fin de la récurrence (2)</strong>.</p>
<p>On a donc que $A_{m+1}(n')$ se calcule en un nombre fini de récursion pour tout $n'\leq n$, ce qui conclut la preuve par récurrence sur $m$ : <strong>fin de la récurrence (1)</strong> et donc de la preuve.</p>
</div>
</details>     
</div>
<p>La fonction étant définie on peut écrire l'algorithme suivant, qui va bien fonctionner :</p>
<pre class="language-text" tabindex="0" data-language="text"><code class="language-text">Nom : Ack
Entrées :
    m, n : entiers
Programme :
    Si m = 0:
        rendre l'entier n + 1
    Si n = 0:
        rendre Ack(m-1, 1)
    Sinon:
        calculer n' = Ack(m, n-1)
        rendre Ack(m-1, n')</code></pre>
<p>Le calcul de la fonction en utilisant l'algorithme précédent est possible, mais le nombre de récursions est très très important. Pour calculer $\text{Ack}(2, 3)$ par exemple, on a les récurrences suivantes :</p>
<ul>
<li>$\text{Ack}(2, 1) = \text{Ack}(1, \text{Ack}(2, 0))$
<ul>
<li>$\text{Ack}(2, 0) = \text{Ack}(1, 1)$
<ul>
<li>$\text{Ack}(1, 1) = \text{Ack}(0, \text{Ack}(1, 0))$
<ul>
<li>$\text{Ack}(1, 0) = \text{Ack}(0, 1) = 2$</li>
</ul>
</li>
<li>$\text{Ack}(1, 1) = \text{Ack}(0, 2) = 3$</li>
</ul>
</li>
<li>$\text{Ack}(2, 0) = \text{Ack}(1, 1) = 3$</li>
</ul>
</li>
<li>$\text{Ack}(2, 1) = \text{Ack}(1, 3)$
<ul>
<li>$\text{Ack}(1, 3) = \text{Ack}(0, \text{Ack}(1, 2))$
<ul>
<li>$\text{Ack}(1, 2) = \text{Ack}(0, \text{Ack}(1, 1))$
<ul>
<li>$\text{Ack}(1, 1) = \text{Ack}(0, \text{Ack}(1, 0))$
<ul>
<li>$\text{Ack}(1, 0) = \text{Ack}(0, 1)= 2$</li>
</ul>
</li>
<li>$\text{Ack}(1, 1) = \text{Ack}(0, 2) = 3$</li>
</ul>
</li>
<li>$\text{Ack}(1, 2) = \text{Ack}(0, 3) = 4$</li>
</ul>
</li>
<li>$\text{Ack}(1, 3) = \text{Ack}(0, 4) = 5$</li>
</ul>
</li>
<li>$\text{Ack}(2, 1) = \text{Ack}(1, 3) = 5$</li>
</ul>
<p>Au final on trouve $\text{Ack}(2, 1) = 5$. Toutes ces récursions pour ça. Attention cependant, ces nombres vont grossir très très vite.</p>
<h3>Valeurs</h3>
<p>Donnons une valeur à la fonction d'Ackermann. On doit cette évaluation à <a href="https://fr.wikipedia.org/wiki/Donald_Knuth">D. Knuth</a> qui pour cela a inventé une nouvelle opération mathématique, l'opération $x \uparrow y$ :</p>
<div class="quote relative py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-emerald-500 bg-emerald-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-emerald-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
  <path stroke-linecap="round" stroke-linejoin="round" d="M13.19 8.688a4.5 4.5 0 011.242 7.244l-4.5 4.5a4.5 4.5 0 01-6.364-6.364l1.757-1.757m13.35-.622l1.757-1.757a4.5 4.5 0 00-6.364-6.364l-4.5 4.5a4.5 4.5 0 001.242 7.244"></path>
</svg>
<div class="pl-8 mr-8">
<p><a href="https://fr.wikipedia.org/wiki/Notation_des_puissances_it%C3%A9r%C3%A9es_de_Knuth">Puissances itérées de Knuth</a></p>
</div></div>

<p>On définit cette opération comme suit :</p>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
</svg>
<div class="pl-8 mb-2 mr-8">
<p><strong>Définition</strong></p>
</div><div class="pl-8 mr-8">
<p>Soient $a$ et $b$ deux entiers strictement positif. On note :</p>
<div>
$$
\left\{
    \begin{array}{ll}
        a \uparrow^{(0)} b & = & \underbrace{a+ \cdots + a}_\textrm{b fois} & = & a \times b\\
        a \uparrow^{(1)} b & = & \underbrace{a \times \cdots \times a}_\textrm{b fois} & = & a^b\\
        a \uparrow^{(k)} b & = & \underbrace{a \uparrow^{(k-1)} \cdots \uparrow^{(k-1)} a}_\textrm{b fois}& = & a \uparrow^{(k-1)} (a \uparrow^{(k)} (b-1)) & \textrm{pour } k>1
    \end{array}
\right.
$$
</div>
<p>On notera aussi le cas limite $a \uparrow^{(k)} 0 = 1$ pour tout entier $k$.</p>
</div></div>

<p>C'est une notation extrêmement compacte pour écrire des monstres. Par exemple :</p>
<ul>
<li>$2 \uparrow^{(0)} 4 = 2+ 2+ 2+ 2= 8$ (ce qui est petit)</li>
<li>$2 \uparrow^{(1)} 4 = 2\times 2\times 2\times 2 = 2^4 = 16$ (ce qui va),</li>
<li>$2 \uparrow^{(2)} 4 = 2^{2^{2^2}} = 2^{16} = 65536$ (ce qui fait soudain beaucoup),</li>
<li>$2 \uparrow^{(3)} 4 = 2 \uparrow^{(2)} 2 \uparrow^{(2)} 2 \uparrow^{(2)} 2 = 2 \uparrow^{(2)} (2 \uparrow^{(2)} 2 \uparrow^{(2)} 2) = 2 \uparrow^{(2)} (2 \uparrow^{(2)} 4) = 2 \uparrow^{(2)} 65536 = 2 \uparrow^{(1)} (2 \uparrow^{(1)} 65535) =2^{2^{65535}}$ (ce qui fait beaucoup trop)</li>
</ul>
<p>Ces nombres sont énormes ! Rien que les écrire va prendre du temps. Si l'on suppose que l'on peut écrire le chiffre <code>1</code> ou <code>0</code> en .1s, l'écriture en base 2 des nombres ci-dessus (ce sont tous des puissances de 2) prendra :</p>
<ul>
<li>.3s pour $2 \uparrow^{(0)} 4$</li>
<li>.4s pour $2 \uparrow^{(1)} 4$</li>
<li>1.6s pour $2 \uparrow^{(2)} 4$</li>
<li>$2^{65500}$ millénaires pour $2 \uparrow^{(3)} 4$</li>
</ul>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
</svg>
<div class="pl-8 mb-2 mr-8">
<p><strong>À retenir</strong></p>
</div><div class="pl-8 mr-8">
<p>Ce n'est pas parce que l'on peut calculer quelque chose qu'on peut le faire en pratique, du moins si on est pas immortel.</p>
</div></div>

<div class="quote relative  py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-cyan-500 bg-cyan-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-cyan-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z"></path>
</svg>
<div class="pl-8 mr-8">
<p>Lorsque l'on vous donne ce genre de grandeurs, ayez à l'esprit qu'il n'y a que de l'ordre de $10^{80}$ particules dans l'univers, ce qui est bien plus petit que $2^{65500}$.</p>
<p>cf. <a href="https://fr.wikipedia.org/wiki/Ordres_de_grandeur_de_nombres#1039_%C3%A0_10100">https://fr.wikipedia.org/wiki/Ordres_de_grandeur_de_nombres#1039_à_10100</a></p>
</div></div>

<p>Les nombres $2 \uparrow^{(m)} n$ vont être liés à la fonction d'Ackermann. Commençons donc par nous familiariser avec :</p>
<div class="quote relative py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-orange-500 bg-orange-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-orange-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M8.228 9c.549-1.165 2.03-2 3.772-2 2.21 0 4 1.343 4 3 0 1.4-1.278 2.575-3.006 2.907-.542.104-.994.54-.994 1.093m0 3h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
<div class="pl-8 mr-8">
<p>Montrez que pour tout $m\geq 0$ on a :</p>
<ol>
<li>$2 \uparrow^{(m)} 1 = 2$</li>
<li>$2 \uparrow^{(m)} 2 = 4$</li>
<li>$2 \uparrow^{(m)} n &gt; m + n$ pour $n \geq 3$</li>
<li>$2 \uparrow^{(m)} (n+1) \leq 2 \uparrow^{(m + 1)} (n)$ pour $n \geq 3$</li>
</ol>
</div></div>

<div class="relative drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-indigo-500 bg-indigo-100">
<details class="group">
<summary class="list-none py-0.5">
<svg class="group-open:hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M9 5l7 7-7 7"></path>
</svg>
<svg class="group-open:block hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7"></path>
</svg>
<div class="pl-8 font-bold inline-block">
<p>corrigé</p>
</div>
<svg class="group-open:hidden inline-block pl-3 w-10 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M5 12h.01M12 12h.01M19 12h.01M6 12a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0z"></path>
</svg>
</summary>
<div class="mx-8 pb-2">
<blockquote>
<p>TBD 1. et 2. en appliquant la formule.</p>
<p>TBD 3. par récurrence sur m et par croissance de la fonction.</p>
<p>TBD 4. Par récurrence sur $n$. Pour $n=3$ on a : $2 \uparrow^{(k)} (3+1) = 2 \uparrow^{(k)} (2 \uparrow^{(k+1) 2}) = 2 \uparrow^{(k+1)} (3)$</p>
</blockquote>
</div>
</details>     
</div>
<p>On peut maintenant montrer la valeur (presque) explicite de la fonction d'Ackermann :</p>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
</svg>
<div class="pl-8 mb-2 mr-8">
<p><strong>Proposition</strong></p>
</div><div class="pl-8 mr-8">
<div>
$$
\left\{
    \begin{array}{ll}
        \text{Ack}(0, n) = n+1&\\
        \text{Ack}(1, n) = 2 + (n+3) - 3&\\
        \text{Ack}(m, n) = 2 \uparrow^{(m-2)} (n+3) - 3&\text{pour }m>1\\
    \end{array}
\right. %}
$$
</div>
</div></div>

<div class="relative drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-indigo-500 bg-indigo-100">
<details class="group" open="">
<summary class="list-none py-0.5">
<svg class="group-open:hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M9 5l7 7-7 7"></path>
</svg>
<svg class="group-open:block hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7"></path>
</svg>
<div class="pl-8 font-bold inline-block">
<p>preuve</p>
</div>
<svg class="group-open:hidden inline-block pl-3 w-10 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M5 12h.01M12 12h.01M19 12h.01M6 12a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0z"></path>
</svg>
</summary>
<div class="mx-8 pb-2">
<p>Commençons par traiter les 2 premiers cas :</p>
<ul>
<li>$\text{Ack}(0, n) = n+1$ est vrai par définition</li>
<li>Comme $\text{Ack}(1, n) = \text{Ack}(0, \text{Ack}(1, n-1)) = \text{Ack}(1, n-1) + 1$ et que $\text{Ack}(1, 0) = \text{Ack}(0, 1) = 2$, une récurrence triviale sur $n$ nous donne $\text{Ack}(1, n) = n+2 = 2 + (n+3) - 3$</li>
</ul>
<p>Pour le dernier cas, commençons par montrer par récurrence sur $n$ que $\text{Ack}(2, n) = 2 \uparrow^{(0)} (n+3) - 3$ :</p>
<ul>
<li>$\text{Ack}(2, 0) = \text{Ack}(1, 1) = 3 = 2 \uparrow^{(0)} (0+3) - 3$</li>
<li>on suppose la propriété vraie pour $n$. Pour $n+1$ on a $\text{Ack}(2, n+1) = \text{Ack}(1, \text{Ack}(2, n)) = \text{Ack}(2, n) + 2 = 2 \uparrow^{(0)} (n+3) - 1 = 2n + 5$ par hypothèse de récurrence. Comme $2 \uparrow^{(0)} (n+1+3) - 3 = 2n + 5$, ceci conclut la preuve par récurrence.</li>
</ul>
<p>On peut terminer la preuve en prouvant par récurrence sur $m &gt; 1$ que $\text{Ack}(m, n) = 2 \uparrow^{(m-2)} (n+3) - 3$. On vient de le montrer pour $m=2$, supposons la vraie pour $m$ et prouvons le $m+1$.</p>
<p>Ce que l'on va faire par sur $n$ :</p>
<ul>
<li>$\text{Ack}(m+1, 0) = \text{Ack}(m, 1) = 2 \uparrow^{(m-2)} (1+3) - 3$. Comme l'exercice nous a montré que $4 = 2 \uparrow^{(m-1)} (2)$ et comme $2 \uparrow^{(m-2)} (2 \uparrow^{(m-1)} (2)) = 2 \uparrow^{(m-1)} (0+3)$ on a bien $\text{Ack}(m+1, 0) =  2 \uparrow^{(m-1)} (0+3) - 3$</li>
<li>on suppose la propriété vraie pour $n$. Pour $n+1$ on a $\text{Ack}(m+1, n+1) = \text{Ack}(m, \text{Ack}(m+1, n)) = 2 \uparrow^{(m-2)} (2 \uparrow^{(m-1)} (n+3) - 3+3) - 3$. On conclut en appliquant la formule pour obtenir $\text{Ack}(m+1, n+1) = 2 \uparrow^{(m+1-2)} (n+1 + 3) - 3$</li>
</ul>
</div>
</details>     
</div>
<p>La fonction d'Ackermann produit donc des nombres proprement gigantesques et est strictement croissante en ses deux variables :</p>
<ul>
<li>$\text{Ack}(m, n) &lt; \text{Ack}(m, n + 1)$</li>
<li>$\text{Ack}(m, n) &lt; \text{Ack}(m + 1, n)$</li>
</ul>
<p>De plus la proposition précédente nous permet d'écrire :</p>
<ul>
<li>$\text{Ack}(2, n) &gt; 2n$</li>
<li>$\text{Ack}(m, n) &gt; m + n$</li>
<li>$\text{Ack}(m, n+1) \leq \text{Ack}(m+1, n)$</li>
</ul>
<p>L'exercice précédent montre que la fonction d'Ackermann croit très vite en $m$ puisque toute somme ou composition de fonction d'Ackermann va être borné à un moment par une autre fonction d'Ackermann.</p>
<h2>Nombre de récursion</h2>
<p>Intuitivement, le nombre de récursions nécessaire pour effectuer le calcul de la valeur de la fonction d'Ackermann est de l'ordre de sa valeur puisque les appels récursif se font en décrémentant les valeurs des paramètres de 1. Formalisons ceci :</p>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
</svg>
<div class="pl-8 mb-2 mr-8">
<p><strong>Proposition</strong></p>
</div><div class="pl-8 mr-8">
<p>Le nombre de récursion nécessaire pour calculer la fonction d'Ackermann en utilisant la définition est définie telle que :</p>
<div>
$$
\left\{
    \begin{array}{ll}
        \text{R}(0, n) = 0&\\
        \text{R}(m, 0) = 1 + \text{R}(m-1, 1)&\text{pour }m>0\\
        \text{R}(m, n) =  \text{R}(m, n - 1) + 1 + \text{R}(m - 1, \text{Ack}(m, n - 1)) &\text{pour }m, n>0\\
    \end{array}
\right. %}
$$
</div>
</div></div>

<div class="relative drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-indigo-500 bg-indigo-100">
<details class="group" open="">
<summary class="list-none py-0.5">
<svg class="group-open:hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M9 5l7 7-7 7"></path>
</svg>
<svg class="group-open:block hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7"></path>
</svg>
<div class="pl-8 font-bold inline-block">
<p>preuve</p>
</div>
<svg class="group-open:hidden inline-block pl-3 w-10 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M5 12h.01M12 12h.01M19 12h.01M6 12a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0z"></path>
</svg>
</summary>
<div class="mx-8 pb-2">
<p>Clair en utilisant la définition de la fonction :</p>
<ul>
<li>le cas $m=0$ est un cas terminal,</li>
<li>le cas $m&gt;0$ et $n=0$ fait une récursion puis calcule $\text{Ack}(m-1, 1)$,</li>
<li>le cas $m, n&gt;0$ doit commencer par calculer $\text{Ack}(m, n - 1)$ (il faut $\text{R}(m, n - 1)$ récursions) fait une recursion pour calculer $\text{Ack}(m - 1, \text{Ack}(m, n - 1))$ (il faut $\text{R}(m - 1, \text{Ack}(m, n - 1))$ récursions)</li>
</ul>
</div>
</details>     
</div>
<p>Ce nombre peut facilement être majoré :</p>
<div class="quote relative py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-orange-500 bg-orange-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-orange-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M8.228 9c.549-1.165 2.03-2 3.772-2 2.21 0 4 1.343 4 3 0 1.4-1.278 2.575-3.006 2.907-.542.104-.994.54-.994 1.093m0 3h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
<div class="pl-8 mr-8">
<p>Montrez que pour tout $m, n &gt; 0$, on a $R(m,n) \geq  R(m,n-1) + 1$ et en déduire que pour $m, n &gt; 1$:</p>
<div>
$$
R(m,n) \geq  \text{Ack}(m, n - 1)
$$
</div>
</div></div>

<div class="relative drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-indigo-500 bg-indigo-100">
<details class="group">
<summary class="list-none py-0.5">
<svg class="group-open:hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M9 5l7 7-7 7"></path>
</svg>
<svg class="group-open:block hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7"></path>
</svg>
<div class="pl-8 font-bold inline-block">
<p>Corrigé</p>
</div>
<svg class="group-open:hidden inline-block pl-3 w-10 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M5 12h.01M12 12h.01M19 12h.01M6 12a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0z"></path>
</svg>
</summary>
<div class="mx-8 pb-2">
<p>La première inégalité est évidente puisque pour $m, n &gt; 0$ on a $\text{R}(m, n) =  \text{R}(m, n - 1) + 1 + \text{R}(m - 1, \text{Ack}(m, n - 1))$ et que $\text{R}(m - 1, \text{Ack}(m, n - 1)) \geq 0$.</p>
<p>Pour en déduire la seconde, il suffit de remarquer que l'on a aussi, pour $m, n &gt; 0$, que $\text{R}(m, n) \geq \text{R}(m - 1, \text{Ack}(m, n - 1))$ et donc que pour $m, n &gt; 1$ on a :</p>
<div>
$$
$R(m,n) \geq  \text{R}(m-1, 0) + \text{Ack}(m, n - 1) \geq \text{Ack}(m, n - 1)
$$
</div>
</div>
</details>     
</div>
<p>Il faut donc (plus que) de l'ordre de de la valeur de la fonction d'Ackermann récursions pour  la calculer, ce qui est astronomique !</p>


</article>
    </main>

    <footer class="min-h-[50px] border-t-2 border-gray-200 mt-4">
      <div class="max-w-[1200px] mx-auto px-4 relative">
        <div class="min-h-[50px] flex justify-center items-center">
          <p>
            Cours d'informatique de François Brucker
          </p>
        </div>
        <div class="min-h-[50px] flex justify-center items-center absolute right-0 top-0">
          <button onclick="goTop()" id="myBtn" title="Go to top">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
              <path stroke-linecap="round" stroke-linejoin="round" d="M15 11.25l-3-3m0 0l-3 3m3-3v7.5M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
            </svg>
          </button>

          <button onclick="goBottom()" id="myBtn" title="Go to top">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
              <path stroke-linecap="round" stroke-linejoin="round" d="M9 12.75l3 3m0 0l3-3m-3 3v-7.5M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
            </svg>
          </button>
        </div>

      </div>
    </footer>

    <script>
      MathJax
        .startup
        .document
        .getMathItemsWithin(document.body);
    </script>

  </body>
</html>