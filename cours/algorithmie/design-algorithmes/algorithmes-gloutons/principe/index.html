<!DOCTYPE html>
<html lang="fr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>Algorithmes gloutons</title>

    

    <link href="https://prismjs.catppuccin.com/latte.css" rel="stylesheet">

    <link href="/cours_informatique/assets/node_modules/prismjs/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet">
    <script src="/cours_informatique/assets/node_modules/prismjs/plugins/line-numbers/prism-line-numbers.min.js"></script>
    
    <link href="/cours_informatique/assets/stylesheets/main.css" rel="stylesheet">

  </head>
  <body>
    <script>
      window.MathJax = {
        tex: {
          inlineMath: [
            [
              '$', '$'
            ],
            [
              '\\(', '\\)'
            ]
          ]
        },
        svg: {
          fontCache: 'global'
        }
      };

      function goTop() {
        window.scrollTo({top: 0});
      }
      function goBottom() {
        window.scrollTo({top: document.body.scrollHeight});
      }
    </script>
    <script type="text/javascript" id="MathJax-script" src="/cours_informatique/assets/node_modules/mathjax/es5/tex-svg-full.js"></script>

    <header class="border-b-2 border-gray-200 mb-4">
      <div class="max-w-[1200px] mx-auto px-4 relative">
        <div class="min-h-[50px] flex justify-between items-center">
          <a class="mx-2" href="/cours_informatique/">Home</a>
        </div>

        <div class="min-h-[50px] flex justify-center items-center absolute right-0 top-0">
          <a class="mx-2" href="/cours_informatique/about">About</a>
          <button onclick="goTop()" id="myBtn" title="Go to top">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
              <path stroke-linecap="round" stroke-linejoin="round" d="M15 11.25l-3-3m0 0l-3 3m3-3v7.5M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
            </svg>
          </button>

          <button onclick="goBottom()" id="myBtn" title="Go to top">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
              <path stroke-linecap="round" stroke-linejoin="round" d="M9 12.75l3 3m0 0l3-3m-3 3v-7.5M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
            </svg>
          </button>
        </div>

      </div>
    </header>

    <main class="max-w-[1200px] mx-auto px-4">
      
<article>

  <h1>Algorithmes gloutons</h1>
  <div>
    

    
  </div>

  

    
<div class="quote relative  py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-purple-500 bg-purple-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-purple-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M5 19a2 2 0 01-2-2V7a2 2 0 012-2h4l2 2h4a2 2 0 012 2v1M5 19h14a2 2 0 002-2v-5a2 2 0 00-2-2H9a2 2 0 00-2 2v5a2 2 0 01-2 2z"></path>
</svg>
<div class="pl-8 mr-8">

<a class="interne" href="/cours_informatique/cours/">Cours</a><span class="px-1">/</span><a class="interne" href="/cours_informatique/cours/algorithmie/">Algorithmie</a><span class="px-1">/</span><a class="interne" href="/cours_informatique/cours/algorithmie/design-algorithmes/">Design d&#39;algorithmes</a><span class="px-1">/</span><a class="interne" href="/cours_informatique/cours/algorithmie/design-algorithmes/algorithmes-gloutons/">Algorithmes gloutons</a><span class="px-1">/</span><a class="interne" href="/cours_informatique/cours/algorithmie/design-algorithmes/algorithmes-gloutons/principe/">Algorithmes gloutons</a>

</div></div>



    
  

  <blockquote>
<p>TBD : écrire les algorithmes en pseudo-code</p>
</blockquote>
<p>L'objectif est de montrer l'intérêt des algorithmes gloutons, la façon de les construire et de prouver qu'ils fonctionnent. On s'attachera dans ce cours à prouver qu'ils rendent une solution optimale à un problème donné.</p>
<h2>Algorithmes gloutons</h2>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
</svg>
<div class="pl-8 mr-8">
<p>Un <a href="https://fr.wikipedia.org/wiki/Algorithme_glouton">algorithme glouton</a> choisit à chaque étape la meilleure possibilité localement et ne se remet jamais en question.</p>
</div></div>

<p>Certains problèmes permettent d'être résolus en construisant petit à petit une solution, sans jamais remettre en cause ses choix. On peut alors souvent trouver très rapidement la meilleure solution possible. On peut également utiliser cette solution construite petit à petit pour trouver une solution approchée à un problème plus général. Cette classe d'algorithmes qui construit itérativement d'une solution est appelée <em>algorithmes gloutons</em>.</p>
<p>Le schéma général d'un algorithme glouton est alors le suivant :</p>
<div id="schéma-algo"></div>
<pre class="language-pseudocode" tabindex="0" data-language="pseudocode"><code class="language-pseudocode"><span class="token builtin">algorithme</span> glouton_archétypal<span class="token punctuation">(</span>E<span class="token punctuation">:</span> <span class="token punctuation">[</span>fragments de solutions<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">→</span> <span class="token punctuation">[</span>fragments de solutions<span class="token punctuation">]</span><span class="token punctuation">:</span>  <span class="token comment"># une solution est constituée d'un ensemble de fragments</span>
    <span class="token string">"Bien ordonner"</span> E en <span class="token punctuation">(</span>x_0<span class="token punctuation">,</span> x_1<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span> x_n<span class="token punctuation">)</span>
    S <span class="token operator">←</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>

    <span class="token keyword">pour chaque</span><span class="token number"> i </span>de <span class="token number">1</span> à n<span class="token punctuation">:</span>
        <span class="token keyword">si</span> S <span class="token operator">+</span> <span class="token punctuation">[</span>x_i<span class="token punctuation">]</span> est une <span class="token string">"solution possible"</span> <span class="token punctuation">:</span>
            S <span class="token operator">←</span> S <span class="token operator">+</span> <span class="token punctuation">[</span>x_i<span class="token punctuation">]</span>

    <span class="token keyword">rendre</span> S</code></pre>
<p>Il va y avoir tout un tas de variantes de ce schéma pour trouver une solution au problème concret à résoudre, mais on voit déjà que ce type d'algorithme va nécessiter :</p>
<ul>
<li>que les solutions recherchées soient constituées d'un ensemble <em>maximal</em> de fragments de solutions</li>
<li>de pouvoir <em>bien ordonner</em> les fragments pour les étudier un à un</li>
</ul>
<p>Le fait de bien ordonner les fragments permet de les considérer du meilleur au moins bon et ainsi de construire itérativement une solution maximale sans jamais remettre en question les choix précédents (c'est glouton, <em>greedy</em> en anglais).</p>
<p>Les algorithmes gloutons sont très utilisés car une fois que l'on a une façon d'ordonner les fragments et de caractériser ce qu'est une solution :</p>
<ul>
<li>ils donnent toujours un résultat</li>
<li>ils sont de complexités faibles</li>
</ul>
<p>Attention cependant :</p>
<ul>
<li>ils ne donne pas forcément le meilleur résultat : il faut le prouver au cas pas cas</li>
<li>il n'y pas forcément de solution unique</li>
</ul>
<p>En conclusion :</p>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
</svg>
<div class="pl-8 mb-2 mr-8">
<p><strong>À retenir</strong></p>
</div><div class="pl-8 mr-8">
<ol>
<li>Ce type d'algorithme est très utilisé pour :
<ol>
<li>résoudre des problèmes ou la solution optimale peut être construite itérativement</li>
<li>résoudre approximativement des problèmes où la rapidité de du calcul de la solution prime sur l'optimalité (souvent des problèmes NP-complets à optimiser).</li>
</ol>
</li>
<li>D'un point de vue théorique, ces algorithmes sont extrêmement importants. Il sont, par exemple, en bijection avec <a href="https://fr.wikipedia.org/wiki/Matro%C3%AFde">la structure de matroïde</a></li>
</ol>
</div></div>

<p>Pour beaucoup de problèmes d'optimisation réels, un algorithme glouton est optimal pour une version simplifiée de celui-ci. Comme l'algorithme va vite, on peut recommencer plusieurs fois pour trouver une meilleure solution. Les algorithmes gloutons sont alors des <a href="https://fr.wikipedia.org/wiki/Heuristique">heuristiques</a> utiles pour trouver une solution satisfaisante, mais pas forcément optimale, à un problème difficile à résoudre.</p>
<h3>Comment concevoir un algorithme glouton</h3>
<ol>
<li>écrire le problème comme un problème d'optimisation</li>
<li>découper le problème en une succession d'étapes successives</li>
<li>on construit la solution incrémentalement à chaque étape en optimisant un critère local</li>
</ol>
<h3>Optimalité et glouton</h3>
<p>Les problèmes d'optimalité demandent de trouver, parmi un ensemble de solutions possibles, une solution minimisant (ou maximisant) un critère. Par exemple :</p>
<ul>
<li>pour un ensemble de coûts de constructions possibles d'une voiture, trouver celle qui minimise le coût tout en maximisant la qualité totale des pièces</li>
<li>parmi tous les parcours passant par un ensemble de villes donné, choisir celui qui minimise le nombre de kilomètres parcourus</li>
<li>maximiser le nombre de films projetés dans un multiplexe de cinéma</li>
<li>...</li>
</ul>
<p>La difficulté de ces problèmes vient du fait que l'on ne peut a priori pas trouver la meilleure solution sans les examiner toutes. Et s'il y a beaucoup de solutions, ça peut prendre vraiment beaucoup de temps.</p>
<p>Certains problèmes cependant permettent d'être résolus en construisant petit à petit une solution, sans jamais remettre en cause ses choix et peuvent ainsi être résolu grace à un algorithme glouton. Ce sont ces problèmes que l'on va étudier maintenant.</p>
<h3>Condition nécessaire et suffisante d'optimalité</h3>
<p>On peut parfois prouver directement qu'un algorithme glouton est optimal et c'est parfois la preuve la plus simple. Mais si l'approche directe n'est pas évidente il existe toujours une preuve par récurrence où on essaie de montrer que chaque étape du glouton peut mener à une solution optimale :</p>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
</svg>
<div class="pl-8 mb-2 mr-8">
<p><strong>Schéma de preuve de l'optimalité d'un algorithme glouton</strong></p>
</div><div class="pl-8 mr-8">
<p>En reprenant le <a href="#sch%C3%A9ma-algo">schéma générique de l'algorithme glouton</a>, on prouve qu'il existe une solution optimale qui a fait à chaque étape du glouton les mêmes choix que lui :</p>
<ul>
<li>si <code class="language-">S + [x_i]</code> était une solution possible alors <code class="language-">x_i</code> est aussi dans la solution optimale considérée</li>
<li>si <code class="language-">S + [x_i]</code> n'était pas une solution possible alors <code class="language-">x_i</code> n'est pas dans la solution optimale considérée</li>
</ul>
<p>Ce qui prouvera l'optimalité de notre algorithme glouton.</p>
</div></div>

<p>Le schéma de preuve précédent, direct, est souvent utilisé par l'absurde :</p>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
</svg>
<div class="pl-8 mb-2 mr-8">
<p>schéma de preuve d'optimalité par l'absurde</p>
</div><div class="pl-8 mr-8">
<ol>
<li>on suppose que la solution donnée par l'algorithme glouton n'est pas optimale</li>
<li>pour toute solution optimale il existe donc une étape $i$ où le glouton a :
<ul>
<li>soit choisi <code class="language-">x_i</code> alors qu'il n'est pas dans la solution optimale considérée</li>
<li>soit refusé <code class="language-">x_i</code> alors qu'il est dans la solution optimale considérée.</li>
</ul>
</li>
<li>On choisi alors la solution optimale qui coïncide <strong>le plus longtemps possible</strong> avec l'algorithme glouton et on considère l'étape $i$ où leur choix a divergé :
<ul>
<li>jusqu'à l'étape $i-1$ les choix ont été identiques entre cette solution optimale et le glouton</li>
<li>pour toute autre solution optimale, la première divergence s'est passé à l'étape $i$ ou avant</li>
</ul>
</li>
<li>On prouve que l'on peut construire une autre solution optimale qui coïncide avec le glouton jusqu'à l'étape $i$ ce qui invalide l'hypothèse de non optimalité du glouton.</li>
</ol>
</div></div>

<p>Fixons nous les idées en modélisant des algorithmes gloutons optimaux pour résoudre trois problèmes d'optimisation. On utilisera trois exemples, de plus en plus complexes :</p>
<ol>
<li><a href="#exemple-le-rendu-de-pi%C3%A8ces" class="interne">le rendu de pièce</a></li>
<li><a href="#exemple-allocation-de-salles-de-cin%C3%A9ma" class="interne">l'allocation de ressources</a></li>
<li><a href="#exemple-ordonnancement" class="interne">ordonnancement</a></li>
</ol>
<h2><span id="exemple-le-rendu-de-pièces"></span>Exemple 1 : le rendu de pièces</h2>
<p>Proposons un algorithme glouton permettant de rendre la monnaie $R$ d'un achat en un nombre minimum de pièces valant $v=5$, $v=2$ et $v=1$ pokédollars.</p>
<h3>Design de l'algorithme</h3>
<ol>
<li><strong>écrire le problème comme un problème d'optimisation</strong> : Il faut rendre un nombre minimum de pièces</li>
<li><strong>découper le problème en une succession d'étapes</strong> : si l'on doit rendre en pièces d'une valeur de $v$, il faut rendre le maximum de pièces possibles, qui correspond à la division entière de $R$ par $v$. On va donc considérer à chaque étape qu'une seule valeur $v$ de pièce, puisqu'il est facile de trouver l'optimum dans ce cas là. Notre algorithme va donc itérativement rendre le nombre maximum de pièces pour une valeur de pièce donnée</li>
<li><strong>choisir un ordre de parcours</strong> : comme il faut rendre le minimum de pièces données, on va examiner les pièces par valeur décroissantes</li>
</ol>
<h3>Algorithme : rendu de pièce</h3>
<ul>
<li><strong>Problème</strong> : &quot;comment rendre R sous en un nombre minimum de pièces&quot;</li>
<li><strong>algorithme glouton</strong> :
<ol>
<li>choisir la plus grande valeur $v$ de pièce plus petite que $R$</li>
<li>donner $p$ pièces où $p$ est la division entière de $R$ par $v$ (<code class="language-">p = R // v</code>)</li>
<li>$R = R - p \cdot v$</li>
<li>revenir en 1. si $R &gt; 0$</li>
</ol>
</li>
<li><strong>complexité</strong> : tri des valeur de pièce + une opération par pièce (division puis soustraction). Comme il suffit de trier une fois pour toute, la complexité peut être de l'ordre du nombre de pièces</li>
</ul>
<div class="quote relative py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-orange-500 bg-orange-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-orange-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M8.228 9c.549-1.165 2.03-2 3.772-2 2.21 0 4 1.343 4 3 0 1.4-1.278 2.575-3.006 2.907-.542.104-.994.54-.994 1.093m0 3h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
<div class="pl-8 mr-8">
<p>Codez l'algorithme en python.</p>
</div></div>

<div class="relative drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-indigo-500 bg-indigo-100">
<details class="group">
<summary class="list-none py-0.5">
<svg class="group-open:hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M9 5l7 7-7 7"></path>
</svg>
<svg class="group-open:block hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7"></path>
</svg>
<div class="pl-8 font-bold inline-block">
<p><strong>Solution</strong></p>
</div>
<svg class="group-open:hidden inline-block pl-3 w-10 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M5 12h.01M12 12h.01M19 12h.01M6 12a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0z"></path>
</svg>
</summary>
<div class="mx-8 pb-2">
<pre class="language-python" tabindex="0" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">rendu</span><span class="token punctuation">(</span>R<span class="token punctuation">,</span> pieces<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    pieces <span class="token operator">=</span> <span class="token builtin">list</span><span class="token punctuation">(</span>pieces<span class="token punctuation">)</span>
    pieces<span class="token punctuation">.</span>sort<span class="token punctuation">(</span><span class="token punctuation">)</span>
    pieces<span class="token punctuation">.</span>reverse<span class="token punctuation">(</span><span class="token punctuation">)</span>

    rendu <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    <span class="token keyword">for</span> v <span class="token keyword">in</span> pieces<span class="token punctuation">:</span>
        p <span class="token operator">=</span> R <span class="token operator">//</span> v
        R <span class="token operator">-=</span> p <span class="token operator">*</span> v

        rendu<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">(</span>v<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">)</span>

    <span class="token keyword">return</span> rendu</code></pre>
</div>
</details>     
</div>
<h3>Preuve d'optimalité pour un système de pièce valant 1, 2 et 5</h3>
<p>On a pas besoin ici de preuve par récurrence. On va analyser les propriétés d'une solution optimale et montrer que la solution de l'algorithme glouton les satisfait.</p>
<p>Considérons une solution optimale. Elle ne <strong>peut pas</strong> contenir :</p>
<ul>
<li><strong>plus de 2 pièces de 2</strong>, sinon on pourrait rendre moins de pièces en échangeant 3 pièces de 2 par 1 pièce de 5 et une pièce de 1 ce qui diminuerait strictement le nombre de pièces rendues.</li>
<li><strong>plus de 1 pièce de 1</strong>, sinon on échangerait 2 pièces de 1 par une pièce de 2, ce qui diminuerait strictement le nombre de pièces rendues.</li>
</ul>
<p>Enfin, cette solution optimale ne <strong>peut pas avoir exactement 2 pièces de 2 et une pièce de 1</strong>, sinon on les échangeraient pour une pièce de 5...</p>
<p>On en déduit donc que la somme d'argent rendu en pièce de 2 et de 1 pour une solution optimale ne peut dépasser 4, ce qui est exactement la division entière de $R$ par 5 et est le premier choix de l'algorithme glouton.</p>
<p>Après le premier choix (les pièces de 5), il ne reste à rendre qu'une somme inférieure ou égale à 4. Il n'y a plus qu'à montrer que pour les 5 cas possibles (lorsqu'il y a 0, 1, 2, 3 ou 4 à rendre) le glouton est optimal, ce qui est évident.</p>
<h3>Système de pièces quelconque ?</h3>
<p>On peut démontrer que le système de pièce européen fonctionne avec les pièces et billets de : 1, 2, 5, 10, 20, 50, 100 et 200. Mais attention, cela ne marche pas pour tous les systèmes de pièces :</p>
<ul>
<li>exemple 1, 3, 4. Pour rendre 6 il donne 4 + 1 + 1 alors que c'est 3 + 3 le mieux.</li>
<li>1, 6, 11, 19 ne fonctionne pas non plus pour 22 par exemple, alors que le système de pièce forme une suite super-croissante ($v_i &gt; v_1 + \dots + v_{i-1}$ pour tout $i &gt;1$). De quoi tordre le coup à une légende urbaine persistante qui stipule en effet que les suites super-croissante permettent un rendu de pièces optimal avec l'algorithme glouton.</li>
</ul>
<p>Remarques :</p>
<ul>
<li>ce n'est pas la seule solution possible pour avoir un système optimal puisque les américains ont des pièces de 25c (les quarter)</li>
<li>cela peut poser des soucis : les machines à café vous indiquent qu'elles ne peuvent plus vous rendre la monnaie car il n'y a plus de pièces d'une valeur particulière, alors qu'en réalité elle disposent de la somme à rendre en utilisant une autre combinaison.</li>
</ul>
<div class="quote relative  py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-cyan-500 bg-cyan-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-cyan-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z"></path>
</svg>
<div class="pl-8 mr-8">
<p>On peut résoudre le cas général avec <a href="http://tnsi.free.fr/documents/14.rendu_monnaie.pdf">un algorithme utilisant la programmation dynamique</a>.</p>
</div></div>

<h2><span id="exemple-allocation-de-salles-de-cinéma"></span>Exemple 2 : allocation de salles de cinéma</h2>
<p>Un gérant de cinéma a en sa possession $m$ films caractérisés chacun par des couples ($d_i$, $f_i$) où $d_i$ est l'heure de début du film et $f_i$ l'heure de fin. Ces couples sont fixés et il ne peut pas les modifier. Il se pose 2 problèmes :</p>
<ul>
<li>Quel est le nombre maximum de films qu'une personne peux voir en une journée ?</li>
<li>Quel est le nombre minimum de salles à construire pour qu'une personne puisse voir un film quelconque qu'elle aura choisi.</li>
</ul>
<h3>Voir un maximum de films</h3>
<ol>
<li><strong>le problème d'optimisation</strong> : on cherche à rendre une liste maximale de films à voir en une journée.</li>
<li><strong>découpage en étapes</strong> : Comme il faut trouver un sous-ensemble maximal de films, chaque étape consistera en l'examen d'un film et voir si on peut le rajouter à l'ensemble déjà constitué.</li>
<li><strong>ordre d'examen des films</strong> : date de fin croissante.</li>
</ol>
<p>Pour l'ordre d'examen, il n'y a pas vraiment d'autre choix que la date de fin croissante. En effet, si l'on classe les séances de cinéma par :</p>
<ul>
<li>durée croissante : l'ensemble de films $[(1, 3), (3, 5), (5, 7), (2.5, 3.5), (4.5, 5.5)]$ produit un contre exemple,</li>
<li>date de début croissante : l'ensemble de films $[(1, 10), (2, 3), (3, 4)]$ produit un contre exemple,</li>
</ul>
<h4>Algorithme : maximum de films</h4>
<ul>
<li><strong>entrée</strong> : liste de films, chaque liste étant une liste <code class="language-">[depart, fin, nom]</code></li>
<li><strong>sortie</strong> : liste ordonnée de films possible</li>
</ul>
<pre class="language-python" tabindex="0" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">nombre_films_maximal</span><span class="token punctuation">(</span>films<span class="token punctuation">)</span><span class="token punctuation">:</span>

    films<span class="token punctuation">.</span>sort<span class="token punctuation">(</span>key<span class="token operator">=</span><span class="token keyword">lambda</span> x<span class="token punctuation">:</span> x<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>

    films_a_voir <span class="token operator">=</span> <span class="token punctuation">[</span>films<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
    <span class="token keyword">for</span> film <span class="token keyword">in</span> films<span class="token punctuation">:</span>
        fin_dernier_film <span class="token operator">=</span> films_a_voir<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>
        début_nouveau_film <span class="token operator">=</span> film<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
        <span class="token keyword">if</span> fin_dernier_film <span class="token operator">&lt;=</span> début_nouveau_film<span class="token punctuation">:</span>
            films_a_voir<span class="token punctuation">.</span>append<span class="token punctuation">(</span>film<span class="token punctuation">)</span>

    <span class="token keyword">return</span> films_a_voir</code></pre>
<p>La sortie de l'algorithme glouton correspond à un ordre de visionnage de films maximisant le nombre de films vus.</p>
<div class="quote relative  py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-cyan-500 bg-cyan-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-cyan-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z"></path>
</svg>
<div class="pl-8 mr-8">
<p>On a utilisé quelques astuces de programmation python :</p>
<ul>
<li><code class="language-">l[-1]</code> rend le dernier élément d'une liste.
boucle <code class="language-">for</code>.</li>
<li>on a un peu fait de magie noire sur les tris en utilisant le paramètre <a href="https://docs.python.org/fr/3/howto/sorting.html#key-functions">key</a> qui permet de passer une fonction en paramètre. Cette fonction est appelé pour chaque élément. C'est pratique pour ne trier que selon 1 élément d'une liste (ici le 2ème élément).</li>
<li>on utilise aussi l'écriture lambda qui permet de créer des fonction d'une ligne anonyme. Notre fonction lambda est équivalente à la fonction <code class="language-">fonction_lambda_anonyme</code> suivante :</li>
</ul>
<pre class="language-python" tabindex="0" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">fonction_lambda_anonyme</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">return</span> x<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span></code></pre>
</div></div>

<h4>Preuve de l'algorithme : maximum de films</h4>
<p>On prouve notre algorithme en utilisant la technique de preuve par l'absurde : on suppose que l'algorithme glouton ne donne pas une solution optimale et on considère la solution optimale à $m^\star$ films dont l'ordre de visionnage des films coïncide le plus longtemps possible avec la solution donnée par celui-ci.</p>
<p>Soit $i$ l'indice de l'étape de la première différence. Bornons cet indice :</p>
<ul>
<li>on ne peut pas avoir $i &gt; m$ car par construction de l'algorithme glouton, tout film qui n'est pas choisit par lui entre en conflit avec au moins un film choisi.</li>
<li>on peut en revanche avoir $i=1$ si les deux listes ne commencent pas par le même film</li>
</ul>
<p>On a donc $1 \leq i \leq m$ et deux cas sont possibles :</p>
<ol>
<li>soit le film $f_i$ a été refusé par l'algorithme glouton alors qu'il est dans la solution optimale</li>
<li>soit le film $f_i$ a été accepté par l'algorithme glouton alors qu'il n'est pas dans la solution optimale</li>
</ol>
<p>Le premier cas est impossible car s'il a été refusé par l'algorithme glouton, c'est qu'il empiète avec un film déjà accepté et comme les solutions optimale et gloutonne coïncident jusqu'à $i$ ces films sont aussi dans la solution optimale.</p>
<p>Dans le deuxième cas, si $(f^\prime_{j})_{1 \leq j \leq m'}$ est sa liste optimale de films à voir on a :</p>
<ul>
<li>$f'_j = f_j$ pour $j&lt; i$</li>
<li>$f'_i \neq f_i$</li>
</ul>
<p>Par construction de l'algorithme glouton, la date de fin de $f'_i$ est plus grande que la date de fin de $f_i$. On peut alors échanger $f_i$ et $f'_i$ pour créer une nouvelle solution optimale $(f'')$ telle que :</p>
<ul>
<li>$f''_j = f_j$ pour $j\leq  i$</li>
<li>$f''_j = f'_j$ pour $j &gt;  i$</li>
</ul>
<p>Ceci est impossible par hypothèse (on prend la solution optimale coïncidant le plus longtemps possible avec la solution de l'algorithme glouton) : notre hypothèse était fausse, l'algorithme glouton est optimal.</p>
<h3>Nombre minimum de salles pour placer tous les films en stock</h3>
<p>On essaie ici de trouver le nombre minimum de salles à construire pour pouvoir projeter tous les films</p>
<h4>Algorithme : nombre de salle minimum</h4>
<p>On va ici classer les films par date de début croissante. On commence par 0 salles de cinéma.</p>
<p>En analysant dans cet ordre les films, on cherche s'il existe une salle à laquelle on peut rajouter le film (la date de fin du dernier film de la salle est plus tôt que le début du nouveau film). Si oui on rajoute le film à cette salle, si non on crée une nouvelle salle et l'on ajoute notre film à cette nouvelle salle.</p>
<div class="quote relative py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-orange-500 bg-orange-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-orange-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M8.228 9c.549-1.165 2.03-2 3.772-2 2.21 0 4 1.343 4 3 0 1.4-1.278 2.575-3.006 2.907-.542.104-.994.54-.994 1.093m0 3h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
<div class="pl-8 mr-8">
<p>Codez l'algorithme en python.</p>
</div></div>

<div class="relative drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-indigo-500 bg-indigo-100">
<details class="group">
<summary class="list-none py-0.5">
<svg class="group-open:hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M9 5l7 7-7 7"></path>
</svg>
<svg class="group-open:block hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7"></path>
</svg>
<div class="pl-8 font-bold inline-block">
<p><strong>Solution</strong></p>
</div>
<svg class="group-open:hidden inline-block pl-3 w-10 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M5 12h.01M12 12h.01M19 12h.01M6 12a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0z"></path>
</svg>
</summary>
<div class="mx-8 pb-2">
<pre class="language-python" tabindex="0" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">nombre_salles</span><span class="token punctuation">(</span>films<span class="token punctuation">)</span><span class="token punctuation">:</span>
    films<span class="token punctuation">.</span>sort<span class="token punctuation">(</span>key<span class="token operator">=</span><span class="token keyword">lambda</span> x<span class="token punctuation">:</span> x<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>

    salles <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span>films<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
    <span class="token keyword">for</span> film <span class="token keyword">in</span> films<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
        nouvelle_salle <span class="token operator">=</span> <span class="token boolean">True</span>
        <span class="token keyword">for</span> salle <span class="token keyword">in</span> salles<span class="token punctuation">:</span>
            dernier_film <span class="token operator">=</span> salle<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>
            <span class="token keyword">if</span> film<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">>=</span> dernier_film<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
                salle<span class="token punctuation">.</span>append<span class="token punctuation">(</span>film<span class="token punctuation">)</span>
                nouvelle_salle <span class="token operator">=</span> <span class="token boolean">False</span>
                <span class="token keyword">break</span>
        <span class="token keyword">if</span> nouvelle_salle<span class="token punctuation">:</span>
            salles<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">[</span>film<span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre>
</div>
</details>     
</div>
<h4>Preuve de l'algorithme : minimum de salles</h4>
<p>La preuve est ici aisée car si on rajoute une salle pour loger un nouveau film $f$, ça veut dire que pour toutes les $k$ salles actuelles il y a un film qui n'est pas fini pendant le début du nouveau film : il existe au moins $k$ films dont le début est avant $f$ et la fin après $f$ : il faut donc au moins $k+1$ salles pour jouer tous ces films en parallèle.</p>
<h2><span id="exemple-ordonnancement"></span>Exemple 3 : ordonnancement</h2>
<p>Les problèmes d'ordonnancement sont multiples. Certains sont durs, d'autres faciles. Mais un algorithme glouton permet de trouver souvent une solution acceptable pour beaucoup d'entres eux et même parfois optimale pour certains problèmes.</p>
<p>Le problème suivant est résoluble par un algorithme glouton : on considère $m$ produits de durée 1 à fabriquer. Si le produit $i$ est réalisée avant la date $d_i$ on peut le vendre pour un prix $p_i$, sinon il est invendable (exemple : de faux billets de match de foot ou de concerts par exemple). Proposez un algorithme permettant de maximiser les profits en considérant que l'on n'a qu'un seul ouvrier.</p>
<p>Il faut donc trouver un sous-ensemble de produits à créer parmi la liste de toutes les possibilités (exemple : la liste de toutes les dates de match de foot ou de concerts) <strong>et</strong> l'ordre dans lequel les produire. Il faut a priori optimiser deux paramètres alors que les algorithmes gloutons classiques ne sont fait que pour en optimiser un seul.</p>
<p>Commençons par montrer que cet ordre est facile à trouver.</p>
<h3>Ordre de production</h3>
<p>Un ensemble de produits est dit <em>compatible</em> s'il existe un ordonnancement de leur production permettant de tous les vendre (chaque produit est fabriqué avant sa date de péremption).</p>
<p>On a la proposition suivante :</p>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
</svg>
<div class="pl-8 mr-8">
<p>Un ensemble de produits est compatible si et seulement si la production par date $d_i$ croissante permet de tous les vendre.</p>
</div></div>

<p>Preuve :</p>
<ul>
<li>si la production par date croissante permet de tout vendre il est compatible</li>
<li>s'il existe un autre ordonnancement avec la tâche $j$ placé avant la tâche $i$ alors que $d_j &gt; d_i$, on peut échanger la tâche $i$ et la tâche $j$ et l'ordonnancement reste compatible</li>
</ul>
<p>Grace à cette propriété, on est ramené à un problème glouton classique : on a plus qu'un seul paramètre à optimiser : le profit.</p>
<h3>Algorithme : ensemble compatible maximum</h3>
<p>Montrons que l'algorithme glouton suivant est optimal :</p>
<ol>
<li>on trie les produits par prix décroissant</li>
<li>$S = []$</li>
<li>pour chaque produit $x$ examiné par ordre de prix décroissant : on ajoute $x$ à $S$ s'il reste compatible</li>
<li>rendre $S$ (qui est une liste de profit maximal)</li>
</ol>
<div class="quote relative py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-orange-500 bg-orange-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-orange-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M8.228 9c.549-1.165 2.03-2 3.772-2 2.21 0 4 1.343 4 3 0 1.4-1.278 2.575-3.006 2.907-.542.104-.994.54-.994 1.093m0 3h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
<div class="pl-8 mr-8">
<p>Codez l'algorithme en python.</p>
</div></div>

<div class="relative drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-indigo-500 bg-indigo-100">
<details class="group">
<summary class="list-none py-0.5">
<svg class="group-open:hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M9 5l7 7-7 7"></path>
</svg>
<svg class="group-open:block hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7"></path>
</svg>
<div class="pl-8 font-bold inline-block">
<p><strong>Solution</strong></p>
</div>
<svg class="group-open:hidden inline-block pl-3 w-10 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M5 12h.01M12 12h.01M19 12h.01M6 12a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0z"></path>
</svg>
</summary>
<div class="mx-8 pb-2">
<pre class="language-python" tabindex="0" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">produits_est_compatible</span><span class="token punctuation">(</span>liste_produit<span class="token punctuation">)</span><span class="token punctuation">:</span>
    liste_produit<span class="token punctuation">.</span>sort<span class="token punctuation">(</span>key<span class="token operator">=</span><span class="token keyword">lambda</span> x<span class="token punctuation">:</span> x<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>

    <span class="token keyword">for</span> date<span class="token punctuation">,</span> produit <span class="token keyword">in</span> <span class="token builtin">enumerate</span><span class="token punctuation">(</span>liste_produit<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> date <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">></span> produit<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token boolean">False</span>
    <span class="token keyword">return</span> <span class="token boolean">True</span>

<span class="token keyword">def</span> <span class="token function">produits_maximum_profit</span><span class="token punctuation">(</span>liste_produit<span class="token punctuation">)</span><span class="token punctuation">:</span>
    liste_produit<span class="token punctuation">.</span>sort<span class="token punctuation">(</span>key<span class="token operator">=</span><span class="token keyword">lambda</span> x <span class="token punctuation">:</span> x<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
    liste_produit<span class="token punctuation">.</span>reverse<span class="token punctuation">(</span><span class="token punctuation">)</span>

    ensemble_max <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    <span class="token keyword">for</span> produit <span class="token keyword">in</span> liste_produit<span class="token punctuation">:</span>
        <span class="token keyword">if</span> produits_est_compatible<span class="token punctuation">(</span>ensemble_max <span class="token operator">+</span> <span class="token punctuation">[</span>produit<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            ensemble_max<span class="token punctuation">.</span>append<span class="token punctuation">(</span>produit<span class="token punctuation">)</span>

    <span class="token keyword">return</span> ensemble_max</code></pre>
</div>
</details>     
</div>
<h3>Preuve : ensemble compatible maximum</h3>
<h4><span id="init-optimisation"></span>Initialisation</h4>
<p>Si une solution ne contient pas l'élément de prix maximum on l'échange avec le 1er élément produit et la solution reste compatible tout en ayant un profit plus grand</p>
<h4><span id="récurrence-optimisation"></span> Récurrence</h4>
<p>Si une solution optimale et la solution gloutonne coïncident au bout de $i$ étapes (les éléments pris le sont pour les deux solutions et les éléments écartés le sont aussi pour les deux solutions), à l'étape $i+1$ on a deux cas :</p>
<ul>
<li>on écarte ce produit car la solution n'est plus compatible pour la solution gloutonne. Comme La solution optimale contenait jusqu'à présent tous les éléments de la solution gloutonne, le produit de l'étape $i+1$ n'est pas on plus compatible avec la solution optimale.</li>
<li>on ajoute le produit à la solution gloutonne. Si la solution optimale ne contient pas ce produit on peut échanger n'importe quel autre élément que les $i-1$ premiers éléments de la solution avec celui-ci pour augmenter le profit.</li>
</ul>


</article>
    </main>

    <footer class="min-h-[50px] border-t-2 border-gray-200 mt-4">
      <div class="max-w-[1200px] mx-auto px-4 relative">
        <div class="min-h-[50px] flex justify-center items-center">
          <p>
            Cours d'informatique de François Brucker
          </p>
        </div>
        <div class="min-h-[50px] flex justify-center items-center absolute right-0 top-0">
          <button onclick="goTop()" id="myBtn" title="Go to top">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
              <path stroke-linecap="round" stroke-linejoin="round" d="M15 11.25l-3-3m0 0l-3 3m3-3v7.5M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
            </svg>
          </button>

          <button onclick="goBottom()" id="myBtn" title="Go to top">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
              <path stroke-linecap="round" stroke-linejoin="round" d="M9 12.75l3 3m0 0l3-3m-3 3v-7.5M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
            </svg>
          </button>
        </div>

      </div>
    </footer>

    <script>
      MathJax
        .startup
        .document
        .getMathItemsWithin(document.body);
    </script>

  </body>
</html>