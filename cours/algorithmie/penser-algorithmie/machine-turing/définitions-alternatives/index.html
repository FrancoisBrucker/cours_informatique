<!DOCTYPE html>
<html lang="fr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>Définitions alternatives</title>

    <link href="/cours_informatique/assets/node_modules/prismjs/themes/prism-solarizedlight.min.css" rel="stylesheet">
    <link href="/cours_informatique/assets/node_modules/prismjs/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet">

    <link href="/cours_informatique/assets/stylesheets/main.css" rel="stylesheet">

  </head>
  <body>
    <script>
      window.MathJax = {
        tex: {
          inlineMath: [
            [
              '$', '$'
            ],
            [
              '\\(', '\\)'
            ]
          ]
        },
        svg: {
          fontCache: 'global'
        }
      };

      function goTop() {
        window.scrollTo({top: 0});
      }
      function goBottom() {
        window.scrollTo({top: document.body.scrollHeight});
      }
    </script>
    <script type="text/javascript" id="MathJax-script" src="/cours_informatique/assets/node_modules/mathjax/es5/tex-svg-full.js"></script>

    <header class="border-b-2 border-gray-200 mb-4">
      <div class="max-w-[1200px] mx-auto px-4 relative">
        <div class="min-h-[50px] flex justify-between items-center">
          <a class="mx-2" href="/cours_informatique/">Home</a>
        </div>

        <div class="min-h-[50px] flex justify-center items-center absolute right-0 top-0">
          <a class="mx-2" href="/cours_informatique/about">About</a>
          <button onclick="goTop()" id="myBtn" title="Go to top">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
              <path stroke-linecap="round" stroke-linejoin="round" d="M15 11.25l-3-3m0 0l-3 3m3-3v7.5M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
            </svg>
          </button>

          <button onclick="goBottom()" id="myBtn" title="Go to top">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
              <path stroke-linecap="round" stroke-linejoin="round" d="M9 12.75l3 3m0 0l3-3m-3 3v-7.5M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
            </svg>
          </button>
        </div>

      </div>
    </header>

    <main class="max-w-[1200px] mx-auto px-4">
      
<article>

  <h1>Définitions alternatives</h1>
  <div>
    

    
  </div>

  

    
<div class="quote relative  py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-purple-500 bg-purple-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-purple-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M5 19a2 2 0 01-2-2V7a2 2 0 012-2h4l2 2h4a2 2 0 012 2v1M5 19h14a2 2 0 002-2v-5a2 2 0 00-2-2H9a2 2 0 00-2 2v5a2 2 0 01-2 2z"></path>
</svg>
<div class="pl-8 mr-8">

<a class="interne" href="/cours_informatique/cours/">Cours</a><span class="px-1">/</span><a class="interne" href="/cours_informatique/cours/algorithmie/">Algorithmie</a><span class="px-1">/</span><a class="interne" href="/cours_informatique/cours/algorithmie/penser-algorithmie/">Penser l&#39;algorithmie</a><span class="px-1">/</span><a class="interne" href="/cours_informatique/cours/algorithmie/penser-algorithmie/machine-turing/">Machine de Turing</a><span class="px-1">/</span><a class="interne" href="/cours_informatique/cours/algorithmie/penser-algorithmie/machine-turing/définitions-alternatives/">Définitions alternatives</a>

</div>
</div>


    
  

  <p>On a vue que le modèle de la machine de Turing permet de créer des programmes ayant les mêmes structures de contrôle que le <a href="../../../ex%C3%A9cuter-code/pseudo-assembleur/" class="interne">pseudo-assembleur</a>. C'est au niveau de la gestion de la mémoire que le modèle de la machine de Turing semble moins complet :</p>
<ul>
<li>on ne peut lire/écrire qu'au niveau du curseur qui ne peut se déplacer que d'une case par instruction</li>
<li>il n'y a pas de registre</li>
</ul>
<p>Nous allons montrer que ce n'est qu'une apparence et qu'en réalité, on peut gérer la mémoire exactement comme on le ferait en pseudo-code.</p>
<p>Nous allons pour cela donner 4 définitions alternatives mais équivalentes d'une machine de Turing.</p>
<h2>Machine de Turing à accès aléatoire en mémoire</h2>
<p>Commençons par un cas simple, le fait de ne pas avoir à se déplacer que de 1 case à la fois :</p>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
</svg>
<div class="pl-8  mb-2 mr-8">
<p><strong>définition</strong></p>
</div><div class="pl-8 mr-8">
<p>Une <strong><em>machine de Turing à accès aléatoire en mémoire</em></strong> est composée :</p>
<ul>
<li>d'un <strong><em>ruban</em></strong> (supposé infini) constitué de cases contiguës pouvant chacune contenir soit le caractère <code>0</code> soit le caractère <code>1</code></li>
<li>d'un <strong><em>curseur</em></strong> qui est positionné sur une case du ruban (on suppose que le ruban est infini à gauche et à droite du curseur)</li>
<li>d'un ensemble fini $Q$ d'<strong><em>états possibles</em></strong>, contenant les états <code class="language-">START</code> et <code class="language-">STOP</code></li>
<li>d'un <strong><em>état courant</em></strong> $q \in Q$</li>
<li>d'une <strong><em>fonction de transition</em></strong> $\delta(q, r) = (\delta_e(q, r), \delta_c(q, r), \delta_d(q, r))$ dépendant de l'état $q$ de la machine et du caractère $r$ contenu dans la case du ruban pointée par le curseur. Cette fonction définie sur $Q \times \{0, 1\}$ permet de modifier :
<ul>
<li>l'état de la machine : $\delta_e : Q \times \{0, 1\} \mapsto Q$</li>
<li>le caractère de la case du ruban pointée par le curseur : $\delta_c : Q \times \{0, 1\} \mapsto \{0, 1\}$</li>
<li>la position du curseur : $\delta_d : Q \times \{0, 1\} \mapsto \mathbb{Z}$</li>
</ul>
</li>
</ul>
</div>
</div>
<p>À l'exécution d'une machine de Turing à accès aléatoire en mémoire, le curseur peut se déplacer d'autant de case vers la droite (si positif) ou la gauche (si négatif) qu'il le souhaite.</p>
<h3>Simulation d'une machine à accès aléatoire en mémoire par une machine simple</h3>
<p>Comme le nombre de cases où se déplace le curseur est dans la fonction de transition, c'est une constante associée à chaque état. On peut alors pour chaque état ajouter une chaîne d'état se déplaçant que d'une case et modifier la machine à accès aléatoire en mémoire pour qu'elle ne se déplace plus que d'une case à droite ou une case à gauche.</p>
<p>Ainsi, supposons que $\delta(q, r) = (\delta_e(q, r), \delta_c(q, r), \delta_d(q, r))$, on va distinguer 3 cas :</p>
<ol>
<li>$\delta_d(q, r) = 0$ : dans ce cas là on modifie la transition et on ajoute 1 états :
<ol>
<li>$\delta(q, r) = (q-0, \delta_c(q, r), +1)$</li>
<li>$\delta(q-0, s) = (\delta_e(q, r), s, -1)$ ($s$ valant 0 ou 1)</li>
</ol>
</li>
<li>$\delta_d(q, r) &gt; 1$ : dans ce cas là on modifie la transition et on ajoute $\delta_d(q, r) - 1$ états :
<ol>
<li>$\delta(q, r) = (q-0, \delta_c(q, r), +1)$</li>
<li>...</li>
<li>$\delta(q-i, s) = (q-(i+1), s, +1)$ ($s$ valant 0 ou 1)</li>
<li>...</li>
<li>$\delta(q-(\delta_d(q, r)-1), s) = (\delta_e(q, r), s, +1)$ ($s$ valant 0 ou 1)</li>
</ol>
</li>
<li>$\delta_d(q, r) &lt; -1$ : identique au cas précédent, mais dans l'autre sens.</li>
</ol>
<p>En appliquant ce procédé à tous les état de la machine, on a maintenant une machine équivalente à la machine précédente mais qui se déplace toujours d'une case vers la droite ou une case vers la gauche : c'est une machine classique.</p>
<h3><span id="accès-aléatoire-equivalence"></span>Equivalence avec la machine de Turing classique</h3>
<p>La construction précédente permet d'écrire :</p>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
</svg>
<div class="pl-8  mb-2 mr-8">
<p><strong>Proposition</strong></p>
</div><div class="pl-8 mr-8">
<p>Toute machine de Turing à  accès aléatoire en mémoire peut être simulée par une machine de Turing simple.</p>
<p>Les deux notions sont donc équivalentes.</p>
</div>
</div>
<h2><span id="plusieurs-curseurs"></span>Machine à plusieurs curseurs</h2>
<p>Une machine de Turing à $k$ curseurs peut être définie comme suit.</p>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
</svg>
<div class="pl-8  mb-2 mr-8">
<p><strong>définition</strong></p>
</div><div class="pl-8 mr-8">
<p>Une <strong><em>machine de Turing à $k$ curseurs</em></strong> est composée :</p>
<ul>
<li>de un <strong><em>ruban</em></strong> (supposé infini) constitué de cases contiguës pouvant chacune contenir soit le caractère <code>0</code> soit le caractère <code>1</code></li>
<li>de $k$ <strong><em>curseurs</em></strong>, positionnés sur une case de son ruban (on suppose que le ruban est infini à gauche et à droite du curseur)</li>
<li>d'un ensemble fini $Q$ d'<strong><em>états possibles</em></strong>, contenant les états <code>START</code> et <code>STOP</code></li>
<li>d'un <strong><em>état courant</em></strong> $q \in Q$</li>
<li>d'une <strong><em>fonction de transition</em></strong> $\delta(q, c_1, \dots, c_k) = (\delta_e(q, c_1, \dots, c_k), \delta_{c_1}(q, c_1, \dots, c_k), \dots, \delta_{c_k}(q, c_1, \dots, c_k), \delta_{d_1}(q, c_1, \dots, c_k), \dots, \delta_{d_k}(q, c_1, \dots, c_k))$ dépendant de l'état $q$ de la machine et des caractères $r_i$ contenus dans chaque case des rubans pointée par son curseur associé. Cette fonction définie sur $Q \times \{0, 1\}^k$ permet de modifier :
<ul>
<li>l'état de la machine : $\delta_e : Q \times \{0, 1\}^k \mapsto Q$</li>
<li>les caractères des cases pointées par chaque curseur $1\leq i \leq k$ : $\delta_{c_i} : Q \times \{0, 1\}^k \mapsto \{0, 1\}$</li>
<li>les positions des $1\leq i \leq k$ curseurs : $\delta_{d_i} : Q \times \{0, 1\}^k \mapsto \{\leftarrow, \rightarrow\}$</li>
</ul>
</li>
</ul>
</div>
</div>
<p>Cette machine permet de prendre en compte plusieurs cases du ruban pour les transition. La gestion des curseurs est faite ainsi :</p>
<ul>
<li>A l'initialisation, les $k$ curseurs sont considérés être sur la même case</li>
<li>A l'exécution, on effectue l'écriture dans l'ordre des curseurs pour rendre déterministe le comportement d'une étape où deux curseurs sont sur la même case.</li>
</ul>
<p>On va montrer que cette extension n'en est pas vraiment une car on peut toujours transformer une machine à plusieurs curseurs en une machine de Turing normale équivalente.</p>
<p>Nous allons pour cela montrer que l'on peut simuler une machine à 2 curseurs par une machine à un curseur.</p>
<h3>Simulation d'une machine à $k$ curseurs par une machine simple</h3>
<p>Le principe de cette conversion est d'associer à chaque case du ruban de la machine à deux curseurs, une $(k+2)-case composé de $k+2$ cases de la machine à 1 curseur.</p>
<p>Chaque paquet est décomposé ainsi :</p>
<ul>
<li>case d'indice 0 : une borne. Un marqueur valant 1 pour une case strictement plus à gauche de tous les curseurs (sera utile pour la suite)</li>
<li>case d'indice 1 : un marqueur valant 1 si le curseur 1 est est dans la case, 0 sinon</li>
<li>case d'indice 2 : un marqueur valant 1 si le curseur 2 est est dans la case, 0 sinon</li>
<li>...</li>
<li>case d'indice $k$ : un marqueur valant 1 si le curseur $k$ est est dans la case, 0 sinon</li>
<li>case d'indice $k+1$ : valeur de la case associée</li>
</ul>
<p>Par exemple si l'on a la machine à 2 curseurs suivante :</p>
<pre><code>numéro case :  12345
ruban       :  00101
curseurs    :   ^ ^
                1 2
</code></pre>
<p>Machine à 1 curseur simulant la machine :</p>
<pre><code>case machine à 2 curseurs : 1   2   3   4   5
ruban                     : 10000100000100100001
indice paquet de 4 cases  : 01230123012301230123

</code></pre>
<p>On initialise la machine comme suit :</p>
<pre><code>ruban                     : 10000110000000000000
curseur                   : ^
indice paquet de 4 cases  : 01230123012301230123
</code></pre>
<p>L'idée force est de multiplier les états de la machine pour stocker l'état de tous les curseur et le nouvel état vers lequel aller. Ceci est possible car il n'y a que 2 possibilités de valeur pour chaque case (0 ou 1) et un nombre fini d'états. Pour chaque état $q$, on va ajouter $3^k\cdot (\vert Q\vert + 1)$ états : $(q, c_1, \dots, c_k, q')$ où chaque $c_k \in {x, 0, 1}$ et $q' \in Q \cup {z}$ (on suppose sans perte de généralité que $z \notin Q$). On rajoute donc beaucoup d'états mais toujours un nombre fini.</p>
<p>On suppose que l'on est dans le cas où la machine à 1 ruban simulant la machine à deux rubans est telle que :</p>
<ul>
<li>son état est $q$</li>
<li>une seule case contient le marqueur du curseur $i$ à 1 ($1\leq i \leq k$)</li>
<li>une seule case contient le marqueur de la borne à 1 et est strictement à gauche des marqueurs des curseurs 1 et 2</li>
<li>le curseur est placé sur la case contenant le marqueur de borne</li>
</ul>
<p>Les différentes étapes ci-après permettent de simuler l'avancement de la machine à $k$ rubans d'un état. Là où une machine $k$ rubans traite l'état $q$ en une étape, nous ferons les 5 étapes suivantes :</p>
<ol>
<li><strong>préparer le nouvel état</strong> :
<ol>
<li>passer de l'état $q$ à l'état $(q, x, \dots, x, z)$</li>
</ol>
</li>
<li><strong>trouver l'état actuel</strong>. On exécute la procédure suivante avec les paramètres $(i, q, x, \dots, x, z)$ pour $i$ allant de 1 à k:
<ol>
<li>se déplacer de $i$ cases vers la droite</li>
<li>si <code>1</code> sur le ruban aller en 5</li>
<li>se déplacer de $k+2$ cases vers la droite</li>
<li>aller en 1</li>
<li>se déplacer de $k-i$ cases vers la droite</li>
<li>passer de l'état $(i, q, c_1, \dots, c_k, z)$ à l'état $(i, q, c'_1, \dots, c'_k, z)$ où :
<ul>
<li>$c'_j = c_j$ pour tout $j \neq i$</li>
<li>$c'_i$ vaut la valeur du ruban (<code>1</code> ou <code>0</code>)</li>
</ul>
</li>
<li>se déplacer de $k+1$ cases vers la gauche</li>
<li>se déplacer de $k+2$ cases vers la gauche</li>
<li>si <code>0</code> sur le ruban aller en 7.</li>
</ol>
</li>
<li>passer de l'état $(q, c_1, \dots, c_k, z)$ à l'état $(q, c_1, \dots, c_k, \delta_e(q, c_1, \dots, c_k))$</li>
<li><strong>Écriture des nouvelles valeurs sur le ruban</strong>. On exécute la procédure suivante avec les paramètres $(i, q, c_1, \dots, c_k, q')$ pour $i$ allant de 1 à k:
<ol>
<li>se déplacer de $i$ cases vers la droite</li>
<li>si <code>1</code> sur le ruban aller en 5</li>
<li>se déplacer de $k+2$ cases vers la droite</li>
<li>aller en 1</li>
<li>se déplacer de $k-i$ cases vers la droite</li>
<li>placer $\delta_{c_i}(q, c_1, \dots, c_k)$ sur le ruban</li>
<li>se déplacer de $k+1$ cases vers la gauche</li>
<li>se déplacer de $k+2$ cases vers la gauche</li>
<li>si <code>0</code> sur le ruban aller en 7.</li>
</ol>
</li>
<li><strong>Déplacement des curseurs</strong>. On exécute la procédure suivante avec les paramètres $(i, q, c_1, \dots, c_k, q')$ pour $i$ allant de 1 à k:
<ol>
<li>se déplacer de $i$ cases vers la droite</li>
<li>si <code>1</code> sur le ruban aller en 5</li>
<li>se déplacer de $k+2$ cases vers la droite</li>
<li>aller en 1</li>
<li>écrire <code>0</code> sur le ruban</li>
<li>si $\delta_{d_i}(q, c_1, \dots, c_k) = \rightarrow$ se déplacer de $k+2$ cases vers la droite, sinon $k+2$ cases vers la gauche</li>
<li>écrire <code>1</code> sur le ruban</li>
<li>se déplacer de $i$ cases vers la gauche</li>
<li>si <code>0</code> sur le ruban aller en 14.</li>
<li>écrire <code>0</code> sur le ruban</li>
<li>se déplacer de $k+2$ cases vers la gauche</li>
<li>écrire <code>1</code> sur le ruban</li>
<li>aller en 15</li>
<li>se déplacer de $k+2$ cases vers la gauche</li>
<li>si <code>0</code> sur le ruban aller en 14.</li>
</ol>
</li>
<li><strong>fin de transition</strong> :
<ol>
<li>passer de l'état $(q, c_1, \dots, c_k, \delta_e(q, c_1, \dots, c_k))$ à l'état $\delta_e(q, c_1, \dots, c_k)$</li>
</ol>
</li>
</ol>
<p>Après ces 6 méta-étapes, la machine est de nouveau dans un état stable et peut recommencer son cycle.</p>
<p>Les étapes précédentes peuvent être écrite en utilisant le formalisme des <a href="../composition" class="interne">compositions de machine</a>. Ceci fonctionne car $k$ est une constante et le nombre d'états fini. On peut donc utiliser les procédures qui génèrent autant d'états que nécessaire.</p>
<h3>Exemple</h3>
<p>Supposons que l'on ait la machine à deux ruban suivante :</p>
<pre><code>numéro case :  12345
ruban       :  010101
curseurs    :    ^ ^
                 2 1
</code></pre>
<p>Et qu'il soit simulé par la machine à 1 ruban :</p>
<pre><code>indice paquet de 4 cases  : 012301230123012301230123
ruban                     : 000010010010000101000001
curseur                   :     ^
</code></pre>
<p>On veut passer de à l'état $\delta(q, 0, 0) = (q', 1, 0, \rightarrow, \leftarrow)$. On montre chaque fin d'étape</p>
<pre><code>indice 4-cases          : 012301230123012301230123
étape - état
1     - (q, x, x, z)    : 000010010010000101000001
                        :     ^
2.1   - (1, q, x, x, z) : 000010010010000101000001
                        :      ^
...

</code></pre>
<blockquote>
<p>TBD finir l'exemples<br>
faire l'exemple avec 2 curseurs. Parler des différentes parties. En particulier le décalage de la borne</p>
</blockquote>
<p>Cela fait tout un tas de transitions, mais on arrive bien à simuler les $2$ curseurs par un seul !</p>
<h3><span id="curseurs-equivalence"></span>Equivalence avec la machine de Turing classique</h3>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
</svg>
<div class="pl-8  mb-2 mr-8">
<p><strong>Proposition</strong></p>
</div><div class="pl-8 mr-8">
<p>Toute machine de Turing à $k$ curseurs peut être simulée par une machine de Turing simple.</p>
<p>Les deux notions sont donc équivalentes.</p>
</div>
</div>
<h2><span id="plusieurs-rubans"></span>Machine à plusieurs rubans</h2>
<p>Une machine de Turing à $k$ rubans peut être définie comme suit.</p>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
</svg>
<div class="pl-8  mb-2 mr-8">
<p><strong>définition</strong></p>
</div><div class="pl-8 mr-8">
<p>Une <strong><em>machine de Turing à $k$ rubans</em></strong> est composée :</p>
<ul>
<li>de $k$ <strong><em>rubans</em></strong> (supposés infinis) constitués de cases contiguës pouvant chacune contenir soit le caractère <code>0</code> soit le caractère <code>1</code></li>
<li>de $k$ <strong><em>curseurs</em></strong>, un par ruban, positionnés sur une case de son ruban (on suppose que le ruban est infini à gauche et à droite du curseur)</li>
<li>d'un ensemble fini $Q$ d'<strong><em>états possibles</em></strong>, contenant les états <code>START</code> et <code>STOP</code></li>
<li>d'un <strong><em>état courant</em></strong> $q \in Q$</li>
<li>d'une <strong><em>fonction de transition</em></strong> $\delta(q, r_1, \dots, r_k) = (\delta_e(q, r_1, \dots, r_k), \delta_{c_1}(q, r_1, \dots, r_k), \dots, \delta_{c_k}(q, r_1, \dots, r_k), \delta_{d_1}(q, r_1, \dots, r_k), \dots, \delta_{d_k}(q, r_1, \dots, r_k))$ dépendant de l'état $q$ de la machine et des caractères $r_i$ contenus dans chaque case des rubans pointée par son curseur associé. Cette fonction définie sur $Q \times \{0, 1\}^k$ permet de modifier :
<ul>
<li>l'état de la machine : $\delta_e : Q \times \{0, 1\}^k \mapsto Q$</li>
<li>les caractères des cases de chaque ruban $1\leq i \leq k$ pointées par les curseurs : $\delta_{c_i} : Q \times \{0, 1\}^k \mapsto \{0, 1\}$</li>
<li>les positions des $1\leq i \leq k$ curseurs : $\delta_{d_i} : Q \times \{0, 1\}^k \mapsto \{\leftarrow, \rightarrow\}$</li>
</ul>
</li>
</ul>
</div>
</div>
<p>L'<strong><em>exécution</em></strong> est alors identique à la machine simple. Tout se passe comme si on avait $k$ machines différentes, mais un seul état et une fonction de transition dépendant de tous les rubans.</p>
<p>De même, l'entrée et la sortie se généralise aisément en considérant l'ensemble des $k$ rubans.</p>
<p>Cette généralisation semble permettre plein de choses nouvelles ! Mais il n'en est rien : on peut toujours transformer une machine à plusieurs rubans en une machine de Turing normale équivalente.</p>
<p>Pour prouver ceci, nous allons montrer que l'on peut simuler une machine à 2 rubans par une machine à 1 ruban. Ceci va prendre plusieurs étapes.</p>
<h3>Simulation d'une machine à 2 rubans par une machine classique</h3>
<p>Représentons une machine à 2 rubans par le schéma suivant :</p>
<pre><code>curseur 1 :              v
ruban 1   : ...000111001001001...
ruban 2   : ...000111001001001...
curseur 2 :       ^
</code></pre>
<p>A priori les deux rubans sont décorrélées, mais comme à l'initialisation les deux rubans sont remplis de 0, les deux rubans peuvent être considérés comme superposés :</p>
<pre><code>curseur 1 :           v
ruban 1   : ...000000000000000...
ruban 2   : ...000000000000000...
curseur 2 :           ^
</code></pre>
<ol>
<li>déplace de deux</li>
<li>superpose les 2 rubans en affectant les cases paire au ruban 1 et les cases impaires au ruban 2</li>
</ol>
<p>Une machine à deux rubans est donc équivalente à une machine à un ruban et 2 curseurs. Chaque curseur :</p>
<pre><code>curseur 1     :           v
ruban         : ...000000000000000...
curseur 2     :            ^
ruban initial :    212121212121212
</code></pre>
<p>On modifie également la fonction de transition pour qu'elle se déplace de 2 cases à chaque déplacement de curseur.</p>
<h3><span id="rubans-equivalence"></span>Equivalence avec la machine de Turing classique</h3>
<p>La procédure précédente peut se généraliser à $k$ rubans et on peut alors simuler une machine à $k$ rubans par une machine à $k$ curseur elle-même simulation par une machine classique :</p>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
</svg>
<div class="pl-8  mb-2 mr-8">
<p><strong>Proposition</strong></p>
</div><div class="pl-8 mr-8">
<p>Toute machine de Turing à $k$ rubans peut être simulée par une machine de Turing simple.</p>
<p>Les deux notions sont donc équivalentes.</p>
</div>
</div>
<h2>Machines à plusieurs curseurs et rubans</h2>
<p>On peut bien sur combiner les deux approches et construire une machine de Turing à $k$ rubans et $k'$ curseurs répartis sur les rubans. Mais, comme vous devez vous en douter :</p>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
</svg>
<div class="pl-8  mb-2 mr-8">
<p><strong>Proposition</strong></p>
</div><div class="pl-8 mr-8">
<p>Toute machine de Turing à $k$ rubans et $k'$ curseurs peut être simulée par une machine de Turing simple.</p>
<p>Les deux notions sont donc équivalentes.</p>
</div>
</div>
<div class="relative drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-indigo-500 bg-indigo-100">
<details class="group" open="">
<summary class="list-none py-0.5">
<svg class="group-open:hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M9 5l7 7-7 7"></path>
</svg>
<svg class="group-open:block hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7"></path>
</svg>
<div class="pl-8 font-bold inline-block">
<p>preuve</p>
</div>
<svg class="group-open:hidden inline-block pl-3 w-10 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M5 12h.01M12 12h.01M19 12h.01M6 12a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0z"></path>
</svg>
</summary>
<div class="mx-8 pb-2">
<p>En utilisant les technique de preuve précédentes on arrive facilement à montrer que :</p>
<ul>
<li>toute machine de Turing à $k$ rubans et $k'$ curseurs peut être simulée par une machine de Turing $1$ rubans et $k'$ curseurs.</li>
<li>toute machine de Turing à $k$ rubans et $k'$ curseurs peut être simulée par une machine de Turing $k$ rubans et $1$ curseur.</li>
</ul>
</div>
</details>     
</div>
<h2>Alphabets</h2>
<p>Ne travailler qu'avec des <code>0</code> et des <code>1</code> peut sembler réducteur :</p>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
</svg>
<div class="pl-8  mb-2 mr-8">
<p><strong>définition</strong></p>
</div><div class="pl-8 mr-8">
<p>Une <strong><em>machine de Turing sur un alphabet $\mathcal{A}$</em></strong> est composée :</p>
<ul>
<li>d'un ensemble fini $\mathcal{A}$ nommé <strong><em>alphabet</em></strong></li>
<li>un <strong><em>caractère blanc</em></strong>, élément de $\mathcal{A}$</li>
<li>d'un <strong><em>ruban</em></strong> (supposé infini) constitué de cases contiguës pouvant chacune contenir des caractères de $\mathcal{A}$</li>
<li>d'un <strong><em>curseur</em></strong> qui est positionné sur une case du ruban (on suppose que le ruban est infini à gauche et à droite du curseur)</li>
<li>d'un ensemble fini $Q$ d'<strong><em>états possibles</em></strong>, contenant les états <code class="language-">START</code> et <code class="language-">STOP</code></li>
<li>d'un <strong><em>état courant</em></strong> $q \in Q$</li>
<li>d'une <strong><em>fonction de transition</em></strong> $\delta(q, r) = (\delta_e(q, r), \delta_c(q, r), \delta_d(q, r))$ dépendant de l'état $q$ de la machine et du caractère $r$ contenu dans la case du ruban pointée par le curseur. Cette fonction définie sur $Q \times \mathcal{A}$ permet de modifier :
<ul>
<li>l'état de la machine : $\delta_e : Q \times \mathcal{A} \mapsto Q$</li>
<li>le caractère de la case du ruban pointée par le curseur : $\delta_c : Q \times \mathcal{A} \mapsto \mathcal{A}$</li>
<li>la position du curseur : $\delta_d : Q \times \mathcal{A} \mapsto \{\leftarrow, \rightarrow\}$</li>
</ul>
</li>
</ul>
</div>
</div>
<p>L'<strong><em>exécution</em></strong> est alors identique à la machine simple, sauf pour l'initialisation où le ruban est rempli de caractères blanc plutôt que de <code>0</code>.</p>
<h3><span id="alphabet-equivalence"></span>Equivalence avec la machine de Turing classique</h3>
<p>On simule une machine de Turing sur un alphabet $\mathcal{A}$ par une machine de Turing à $|\mathcal{A}|-1$ rubans.</p>
<p>L'idée est d'associer chaque caractère de $\mathcal{A}$ par un $(\mathcal{A}-1)$-uplet valant :</p>
<ul>
<li>$(0, \dots, 0)$ pour le caractère blanc</li>
<li>$(0, \dots, 0, 1, 0, \dots, 0)$ pour un caractère donné</li>
</ul>
<p>Par exemple si $|\mathcal{A}| = {a, b, c}$ avec b valant blanc, on a :</p>
<ul>
<li>$(0, 0)$ associé à $b$</li>
<li>$(1, 0)$ associé à $a$</li>
<li>$(0, 1)$ associé à $c$</li>
</ul>
<p>La fonction de transition de la machine est alors répartie sur les rubans. Par exemple si $\delta(q, a)$ fait aller la machine originale à droite, écrit $c$ la machine et change l'état en $q'$, la machine à 2 rubans va avoir comme transition :</p>
<ul>
<li>$\delta_1(q, 1, 0) =  (q', 0, \rightarrow)$</li>
<li>$\delta_2(q, 1, 0) = (q', 1, \rightarrow)$</li>
</ul>
<p>De façon formelle. Soit une machine de Turing sur un alphabet $\mathcal{A}$ de fonction de transition $\delta$ et une bijection $\phi: \mathcal{A} \mapsto \{0, dots, \mathcal{A}-1\}$ qui associe 0 au caractère blanc.</p>
<p>On construit la fonction de transition de la machine à $\mathcal{A}-1$ ruban telle que si $\delta(q, a) = (q', a', f)$ alors pour le $\mathcal{A}-1$-uplet $(0,\dots , 0, 1, 0, \dots, 0)$ tel que le 1 est à la position $\phi(a)$, on a :</p>
<ul>
<li>$\delta_i(q, 0,\dots , 0, 1, 0, \dots, 0) =  (q', 0, f)$ si $i\neq \phi(a')$</li>
<li>$\delta_i(q, 0,\dots , 0, 1, 0, \dots, 0) =  (q', 1, f)$ si $i = \phi(a')$</li>
</ul>
<p>On a donc simulé une machine de Turing d'alphabet $\mathcal{A}$ par une machine de TUring à $k$ rubans et comme une machine de Turing à $k$ rubans peut être simulée par une machine de Turing, on en conclut :</p>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
</svg>
<div class="pl-8  mb-2 mr-8">
<p><strong>Proposition</strong></p>
</div><div class="pl-8 mr-8">
<p>Toute machine de Turing d'alphabet $\mathcal{A}$ peut être simulée par une machine de Turing simple.</p>
<p>Les deux notions sont donc équivalentes.</p>
</div>
</div>
<h2><span id="MT-01#"></span>Machine de Turing <code>01#</code></h2>
<p>La définition d'une machine de Turing la plus couramment utilisée en algorithmie théorique est la machine de Turing d'alphabet $\{0, 1, \sharp\}$ avec <code>#</code> comme caractère blanc et la possibilité de ne pas avancer le ruban :</p>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
</svg>
<div class="pl-8  mb-2 mr-8">
<p><strong>définition</strong></p>
</div><div class="pl-8 mr-8">
<p>Nous nommerons : <strong><em>Machine de Turing <code>01#</code></em></strong> une machine $M$ de Turing d'alphabet $\{0, 1, \sharp\}$ avec <code>#</code> comme caractère blanc avec les caractéristiques suivantes :</p>
<ul>
<li>$\delta_d(q, r)$ (ou les $\delta_{d_i}(q, r_1, \dots, r_p)$ si la machine possède plusieurs rubans ou curseurs) prend ses valeurs dans $\{ \leftarrow, \emptyset, \rightarrow \}$. Si la valeur est $\emptyset$ le curseur ne bouge pas.</li>
<li>la <strong>sortie</strong> Machine de Turing <code>01#</code> sera la portion de ruban entourant le curseur du premier caractère blanc à la gauche de celui-ci exclu au premier caractère blanc à la droite de celui-ci exclu.</li>
<li>l'<strong>entrée</strong> sera :
<ul>
<li>$M(E)$ avec $E$ uniquement composée de <code>0</code> ou de <code>1</code></li>
<li>$M([E])$ avec $[E] = E_1\sharp...\sharp E_i\sharp ...\sharp E_n$ avec les E_i uniquement composée de <code>0</code> ou de <code>1</code></li>
</ul>
</li>
</ul>
<p>Une machine <strong><em>Machine de Turing <code>01#</code> à $k$ rubans</em></strong> aura comme entrée $M(E_1, \dots, E_k)$, $M([E_1], \dots, [E_k])$ ou une combinaison de ceux-ci.</p>
</div>
</div>
<p>La fait d'accepter de ne pas se déplacer permet des transitions de type $\delta_i(q, r_1, \dots, r_p) = (q, r_i, \emptyset)$ pour tout $i \neq I$ et $\delta_I(q, r_1, \dots, r_p) = (q, r'_I, \leftarrow)$. On peut bouger les rubans indépendamment les uns des autres !</p>
<p>Mais, comme toujours, ce n'est qu'une facilité d'écriture, on ne peut faire plus qu'avec une machine de Tuning <em>simple</em> :</p>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
</svg>
<div class="pl-8  mb-2 mr-8">
<p><strong>Proposition</strong></p>
</div><div class="pl-8 mr-8">
<p>On peut simuler une machine de Turing <code>01#</code> à plusieurs rubans et plusieurs curseurs par une machine de Turing.</p>
</div>
</div>
<div class="relative drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-indigo-500 bg-indigo-100">
<details class="group" open="">
<summary class="list-none py-0.5">
<svg class="group-open:hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M9 5l7 7-7 7"></path>
</svg>
<svg class="group-open:block hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7"></path>
</svg>
<div class="pl-8 font-bold inline-block">
<p>preuve</p>
</div>
<svg class="group-open:hidden inline-block pl-3 w-10 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M5 12h.01M12 12h.01M19 12h.01M6 12a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0z"></path>
</svg>
</summary>
<div class="mx-8 pb-2">
<p>Il nous faut juste montrer que l'ajout de transitions où le curseur d'un ruban ne bouge pas peut être simulé par une machine de Turing.</p>
<p>Pour cela on ne va écrire que sur les cases paires du ruban et ajouter des état tampons permettant de simuler le sur place. Ci après un exemple avec 2 rubans et on suppose que le second ruban ne bouge pas alors que le premier va à droite (les autres cas sont identiques):</p>
<pre><code>curseur du ruban 1 :     v
parité de la case  : 01010101010
curseur du ruban 2 :     ^
</code></pre>
<p>Premier état tampon, on se déplace sur une case impaire. Celui qui doit bouger avance et celui qui doit rester sur place recule :</p>
<pre><code>curseur du ruban 1 :      v
parité de la case  : 01010101010
curseur du ruban 2 :    ^
</code></pre>
<p>Second état tampon, l;es deux se déplace dans la même direction :</p>
<pre><code>curseur du ruban 1 :       v
parité de la case  : 01010101010
curseur du ruban 2 :     ^
</code></pre>
</div>
</details>     
</div>


</article>
    </main>

    <footer class="min-h-[50px] border-t-2 border-gray-200 mt-4">
      <div class="max-w-[1200px] mx-auto px-4 relative">
        <div class="min-h-[50px] flex justify-center items-center">
          <p>
            Cours d'informatique à l'école centrale Marseille
          </p>
        </div>
        <div class="min-h-[50px] flex justify-center items-center absolute right-0 top-0">
          <button onclick="goTop()" id="myBtn" title="Go to top">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
              <path stroke-linecap="round" stroke-linejoin="round" d="M15 11.25l-3-3m0 0l-3 3m3-3v7.5M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
            </svg>
          </button>

          <button onclick="goBottom()" id="myBtn" title="Go to top">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
              <path stroke-linecap="round" stroke-linejoin="round" d="M9 12.75l3 3m0 0l3-3m-3 3v-7.5M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
            </svg>
          </button>
        </div>

      </div>
    </footer>

    <script>
      MathJax
        .startup
        .document
        .getMathItemsWithin(document.body);
    </script>

  </body>
</html>