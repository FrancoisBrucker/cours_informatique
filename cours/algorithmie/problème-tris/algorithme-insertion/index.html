<!DOCTYPE html>
<html lang="fr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>Algorithme du tri par insertion</title>

    

    <link href="https://prismjs.catppuccin.com/latte.css" rel="stylesheet">

    <link href="/cours_informatique/assets/node_modules/prismjs/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet">
    <script src="/cours_informatique/assets/node_modules/prismjs/plugins/line-numbers/prism-line-numbers.min.js"></script>
    
    <link href="/cours_informatique/assets/stylesheets/main.css" rel="stylesheet">

  </head>
  <body>
    <script>
      window.MathJax = {
        tex: {
          inlineMath: [
            [
              '$', '$'
            ],
            [
              '\\(', '\\)'
            ]
          ]
        },
        svg: {
          fontCache: 'global'
        }
      };

      function goTop() {
        window.scrollTo({top: 0});
      }
      function goBottom() {
        window.scrollTo({top: document.body.scrollHeight});
      }
    </script>
    <script type="text/javascript" id="MathJax-script" src="/cours_informatique/assets/node_modules/mathjax/es5/tex-svg-full.js"></script>

    <header class="border-b-2 border-gray-200 mb-4">
      <div class="max-w-[1200px] mx-auto px-4 relative">
        <div class="min-h-[50px] flex justify-between items-center">
          <a class="mx-2" href="/cours_informatique/">Home</a>
        </div>

        <div class="min-h-[50px] flex justify-center items-center absolute right-0 top-0">
          <a class="mx-2" href="/cours_informatique/about">About</a>
          <button onclick="goTop()" id="myBtn" title="Go to top">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
              <path stroke-linecap="round" stroke-linejoin="round" d="M15 11.25l-3-3m0 0l-3 3m3-3v7.5M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
            </svg>
          </button>

          <button onclick="goBottom()" id="myBtn" title="Go to top">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
              <path stroke-linecap="round" stroke-linejoin="round" d="M9 12.75l3 3m0 0l3-3m-3 3v-7.5M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
            </svg>
          </button>
        </div>

      </div>
    </header>

    <main class="max-w-[1200px] mx-auto px-4">
      
<article>

  <h1>Algorithme du tri par insertion</h1>
  <div>
    

    
  </div>

  

    
<div class="quote relative  py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-purple-500 bg-purple-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-purple-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M5 19a2 2 0 01-2-2V7a2 2 0 012-2h4l2 2h4a2 2 0 012 2v1M5 19h14a2 2 0 002-2v-5a2 2 0 00-2-2H9a2 2 0 00-2 2v5a2 2 0 01-2 2z"></path>
</svg>
<div class="pl-8 mr-8">

<a class="interne" href="/cours_informatique/cours/">Cours</a><span class="px-1">/</span><a class="interne" href="/cours_informatique/cours/algorithmie/">Algorithmie</a><span class="px-1">/</span><a class="interne" href="/cours_informatique/cours/algorithmie/problème-tris/">Problème du tri</a><span class="px-1">/</span><a class="interne" href="/cours_informatique/cours/algorithmie/problème-tris/algorithme-insertion/">Algorithme du tri par insertion</a>

</div></div>



    
  

  <p>Le tri par insertion est un exemple d'algorithmes dont les complexité minimum et maximum sont très différentes. Il est alors nécessaire de calculer la complexité en moyenne pour avoir une idée de la complexité attendu pour un tableau aléatoire (<em>ie</em> inconnu).</p>
<p>Cet algorithme est une extension de <a href="../reconnaissance/#algorithme-est-trie" class="interne">l'algorithme <code class="language-">est_trie</code></a>. Plutôt que de rendre <code class="language-">False</code> il répare. L'algorithme <code class="language-">est_trie</code> répond <code class="language-">False</code> au plus petit <code class="language-">i</code> tel que <code class="language-">T[i] &lt; T[i-1]</code>. On est alors dans le cas où :</p>
<ul>
<li><code class="language-">T[:i]</code> est trié</li>
<li>et <code class="language-">T[i] &lt; T[i-1]</code></li>
</ul>
<p>Pour que l'on puisse continuer, il faut s'arranger pour que <code class="language-">T[:i+1]</code> soit trié. Pour cela, on peut utiliser le fait que <code class="language-">T[:i+1]</code> est trié si et seulement si :</p>
<ul>
<li><code class="language-">T[1] &gt;= T[0]</code></li>
<li><code class="language-">T[2] &gt;= T[1]</code></li>
<li>...</li>
<li><code class="language-">T[i] &gt;= T[i-1]</code></li>
</ul>
<p>Dans notre cas, toutes les conditions sont vérifiées sauf la dernière. Si l'on échange <code class="language-">T[i]</code> et <code class="language-">T[i-1]</code> toutes les conditions seront vérifiées sauf peut-être l'avant-dernière. Si elle n'est pas vérifiée on peut échanger <code class="language-">T[i-1]</code> et <code class="language-">T[i-1]</code> et alors toutes les conditions seront vérifiées sauf peut-être l'avant-avant-dernière, que l'on peut à nouveau échanger, et ainsi de suite jusqu'à ce que toutes les conditions soient vérifiées.</p>
<p>Cette analyse (ce n'est pas encore une preuve formelle) nous permet de dégager le principe suivant :</p>
<p>On vérifie itérativement que <code class="language-">T[i] &gt;= T[i-1]</code> et si ce n'est pas le cas on fait <em>remonter</em> <code class="language-">T[i]</code> par échanges successifs à la première place où il sera plus grand que le précédent.</p>
<p>Ce qui se traduit en pseudo-code :</p>
<p><span id="algorithme-tri-insertion"></span></p>
<pre class="language-pseudocode" tabindex="0" data-language="pseudocode"><code class="language-pseudocode"><span class="token builtin">algorithme</span> <span class="token function">insertion</span><span class="token punctuation">(</span>T<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token builtin">entier</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token operator">→</span> ∅<span class="token punctuation">:</span>
    <span class="token keyword">pour chaque</span><span class="token number"> i </span>de <span class="token punctuation">[</span><span class="token number">1</span> <span class="token punctuation">.</span><span class="token punctuation">.</span> T<span class="token punctuation">.</span>longueur<span class="token punctuation">[</span><span class="token punctuation">:</span>  <span class="token comment"># boucle principale</span>
       <span class="token number"> j </span><span class="token operator">←</span><span class="token number"> i
</span>        <span class="token keyword">tant que</span> <span class="token punctuation">(</span>j <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">et</span> <span class="token punctuation">(</span>T<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> T<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment"># boucle intérieure</span>
            T<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> T<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">←</span> T<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> T<span class="token punctuation">[</span>j<span class="token punctuation">]</span>
           <span class="token number"> j </span><span class="token operator">←</span><span class="token number"> j </span><span class="token operator">-</span> <span class="token number">1</span></code></pre>
<p>L'algorithme <code class="language-">insertion</code>, comme l'algorithme <code class="language-">sélection</code>, <strong>modifie</strong> le tableau passé en paramètre.</p>
<p>Pour garantir que <code class="language-">T[j - 1]</code> soit toujours valide (il faut que $j-1 \geq 0$), on place en tête de la condition <code class="language-">(courant &lt; T[j - 1])</code> de la ligne 5 <a href="https://en.wikipedia.org/wiki/Sentinel_value">la sentinelle</a> <code class="language-">(j &gt; 0)</code>. Les deux conditions étant liées par un <code class="language-">and</code>, python (et tout autre langage de programmation) n'évaluera la seconde condition <strong>que si la première est vérifiée</strong> (un <code class="language-">and</code> ne peut être vrai que si les deux conditions sont vraies. Si la première condition est fausse, il est impossible que le <code class="language-">and</code> soit vrai il est donc inutile de vérifier la seconde condition).</p>
<div class="quote relative py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-red-700 bg-red-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-red-700" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"></path>
</svg>
<div class="pl-8 mb-2 mr-8">
<p><strong>À retenir</strong></p>
</div><div class="pl-8 mr-8">
<p>La technique <a href="https://en.wikipedia.org/wiki/Sentinel_value">des sentinelles</a> est très pratique, cela vaut le coup de la connaître.</p>
</div></div>

<h2><span id="fonctionnement-insertion"></span> Fonctionnement</h2>
<p>Tout comme pour l'algorithme de tri par sélection :</p>
<div class="quote relative  py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-yellow-500 bg-yellow-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-yellow-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z"></path>
  <path stroke-linecap="round" stroke-linejoin="round" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path>
</svg>
<div class="pl-8 mr-8">
<p>Vérifiez que l'algorithme fonctionne pour :</p>
<ul>
<li>un petit tableau trié : <code class="language-">[1, 2, 3]</code></li>
<li>un petit tableau non trié où le plus petit est en dernière place : <code class="language-">[3, 2, 1]</code></li>
</ul>
</div></div>

<h2><span id="preuve-insertion"></span> Preuve</h2>
<p>Le principe de programmation du tri par insertion est correct puisque <code class="language-">est_trie</code> est prouvé. Mais il faut vérifier qu'il est bien mis en œuvre dans l'algorithme.</p>
<p>On a ici deux boucles imbriquée (boucle principale et intérieure), il nous faut donc a priori deux invariants de boucles, le second (du <code class="language-">tant que</code>) nous servant à prouver le premier (du <code class="language-">pour chaque</code>)</p>
<p>Comme l'algorithme du tri par insertion mime l'algorithme de reconnaissance, le premier invariant, celui de la boucle principale <code class="language-">pour chaque</code> va être le même :</p>
<blockquote>
<p><strong>Invariant de boucle :</strong> À la fin d'un itération de la boucle principale <code class="language-">pour chaque</code>, les $i + 1$ premiers éléments du tableau sont triés.</p>
</blockquote>
<p>Pour prouver cet invariant, il nous faut comprendre ce que fait la boucle <code class="language-">tant que</code> de la boucle intérieure, c'est à dire lui trouver un invariant. Chaque itération de cette boucle va échanger les éléments placées en $j-1$ et $j$ et décrémenter $j$ jusqu'à ce que soit $j=0$ soit $T[j-1] \leq T[j]$. On a donc clairement l'invariant :</p>
<blockquote>
<p><strong>Invariant de boucle :</strong> À la fin de chaque itération de la boucle <code class="language-">tant que</code> $T[j] \leq T[j+1]$ si $j &lt;i$</p>
</blockquote>
<p>On peut donc démontrer l'invariant de la boucle principale <code class="language-">pour chaque</code>.</p>
<p>On a $i = 1$ pour la première itération donc à l'issue de la boucle tant que :</p>
<ul>
<li>soit $j=i=1$ et $T[0] \leq T[1]$ (car la boucle s'est arrêtée)</li>
<li>soit $j=0$ et $T[0] \leq T[1]$ (invariant de boucle)</li>
</ul>
<p>Dans les 2 cas, les 2 premiers éléments de $T$ sont triées. L'initialisation de l'invariant est Ok.</p>
<p>On suppose l'invariant vrai à la fin de la $i-1$ ème boucle et on regarde à la fin de la $i$ boucle.</p>
<p>La $i$ ème itération de la boucle <code class="language-">pour chaque</code> (ligne 2), a fonctionné ainsi :</p>
<ul>
<li>ligne 3 : on a : <code class="language-">T[:i+1] = T[:i] + [T[j]]</code> ($j = i$)</li>
<li>à la sortie de la boucle <code class="language-">tant que</code>, en notant <code class="language-">T</code> le tableau avant la boucle <code class="language-">tant que</code> et <code class="language-">T'</code> le tableau en fin de <code class="language-">tant que</code>, on a :
<ol>
<li><code class="language-">T'[:i+1] = T[:j] + [T[j]] + T[j:i]</code></li>
<li><code class="language-">T[:j]</code> trié (invariant de la boucle <code class="language-">pour chaque</code>) et <code class="language-">T[j] &gt;= T[j-1]</code> (car on est sorti de la boucle <code class="language-">tant que</code>)</li>
<li><code class="language-">T[j:i]</code> trié (invariant de la boucle <code class="language-">pour chaque</code>) et <code class="language-">T[j] &lt; T[j+1]</code> (invariant de la boucle <code class="language-">tant que</code>)</li>
</ol>
</li>
</ul>
<p>Les constatations précédentes nous montrent que $T'[:i+1]$ est trié, ce qui termine la preuve de l'invariant de la boucle <code class="language-">pour chaque</code>.</p>
<p>On conclut la preuve de l'algorithme insertion en constatant que l'invariant de la boucle <code class="language-">pour chaque</code> est vrai en sortie de boucle où $i=n-1$ : les $n$ premier éléments de $T$ sont triés.</p>
<h2><span id="complexités-insertion"></span> Complexités</h2>
<p>Ligne à ligne :</p>
<ol>
<li>appel de fonction : $\mathcal{O}(1)$</li>
<li>$n-1$ itérations, avec $n$ la taille du tableau</li>
<li>affectation d'une variable et récupération d'un élément d'un tableau : $\mathcal{O}(1)$</li>
<li>affectation d'une variable : $\mathcal{O}(1)$</li>
<li>$K_i$ itérations ($K_i$ inconnu pour chque $i$) et deux tests en $\mathcal{O}(1)$ pour chaque itération</li>
<li>affectation d'une variable et récupération d'un élément d'un tableau : $\mathcal{O}(1)$</li>
<li>une soustraction et une affectation : $\mathcal{O}(1)$</li>
<li>affectation d'une variable et récupération d'un élément d'un tableau : $\mathcal{O}(1)$</li>
</ol>
<p>En synthétisant tout ça on arrive à une complexité valant :</p>
<div>
$$
C(n) = \sum_{i=1}^{n-1}(\mathcal{O}(1) + K_i \cdot \mathcal{O}(1)) = \mathcal{O}(1) + \sum_{i=1}^{n-1}\mathcal{O}(K_i)
$$
</div>
<p>Comme $K_i$ n'est pas constant pour chaque itération de la boucle principale <code class="language-">pour chaque</code> il faut regarder les valeurs extrêmes que peut prendre $K$ :</p>
<ul>
<li>si le tableau est déjà trié : on ne rentre jamais dans la boucle secondaire <code class="language-">tant que</code> : $K = 0$ pour chaque itération.</li>
<li>si le tableau est trié à l'envers : pour la $i$-ème itération de la boucle principale <code class="language-">pour chaque</code>, on aura $K=i$. C'est de plus le maximum théorique possible ($j=i$ initialement et j décroît de 1 à chaque itération de la boucle secondaire <code class="language-">tant que</code>).</li>
</ul>
<p>On a donc 2 cas extrêmes pour le calcul :</p>
<ol>
<li>$K_i = 0$ à chaque itération et on peut considérer que $K_i = K=0$ pour tout $i$ dans le cas le plus favorable</li>
<li>$K_i$ croit de $1$ à $n-1$ à chaque itération : <a href="../../complexit%C3%A9-calculs/complexit%C3%A9-algorithmes#r%C3%A8gle-croissance" class="interne">la règle de croissance</a> nous indique qu'on peut considérer que $K_i = K=\mathcal{O}(n)$ pour tout $i$ dans le cas le moins favorable</li>
</ol>
<p>Ce qui donne une complexité de :</p>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
</svg>
<div class="pl-8 mr-8">
<p>La complexité de l'algorithme <code class="language-">insertion</code> est ($n$ est la taille du tableau passé en entrée) :</p>
<ul>
<li>la <strong>complexité min</strong> est atteinte lorsque le tableau est déjà trié et vaut $\mathcal{O}(n)$</li>
<li>la <strong>complexité (max)</strong> est atteinte lorsque le tableau est trié par ordre décroissant et vaut $\mathcal{O}(n^2)$</li>
</ul>
</div></div>

<p>La complexité min est différente de la complexité maximale. On va donc calculer la complexité en moyenne pour connaître la complexité pour des données <em>standard</em>.
Pour savoir ce que veut dire <em>standard</em>, il faut déterminer le modèle de données : prenons le équiprobable.</p>
<p>Cela signifie que pour chaque itération $i$ :</p>
<ul>
<li><code class="language-">T[i]</code> sera bien placé pour une proportion de $\frac{1}{i + 1}$ tableaux et on aura $K_i = \mathcal{O}(1)$ pour ceux-ci.</li>
<li><code class="language-">T[i]</code> devra être positionné en $i-1$ pour une proportion de $\frac{1}{i + 1}$ tableaux, et on aura $K_i = 2\cdot\mathcal{O}(1)$ pour ceux-ci.</li>
<li>...</li>
<li><code class="language-">T[i]</code> devra être positionné en $i-j$ pour une proportion de $\frac{1}{i + 1}$ tableaux, et on aura $K_i = j\cdot\mathcal{O}(1)$ pour ceux-ci.</li>
<li>...</li>
<li><code class="language-">T[i]</code> devra être positionné en $0$ pour une proportion de $\frac{1}{i + 1}$ tableaux, et on aura $K_i = i\cdot\mathcal{O}(1)$ pour ceux-ci.</li>
</ul>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
</svg>
<div class="pl-8 mb-2 mr-8">
<p><strong>De façon intuitive</strong></p>
</div><div class="pl-8 mr-8">
<p>Si les données sont équiprobables, la boucle tant que remontera en moyenne de $\frac{i}{2}$ cases chaque <code class="language-">T[i]</code>. Le nombre moyen d'itérations de $K_i$ sera égal à $\widehat{K_i} = \frac{i}{2}$</p>
</div></div>

<div class="relative drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-indigo-500 bg-indigo-100">
<details class="group" open="">
<summary class="list-none py-0.5">
<svg class="group-open:hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M9 5l7 7-7 7"></path>
</svg>
<svg class="group-open:block hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7"></path>
</svg>
<div class="pl-8 font-bold inline-block">
<p>de façon formelle</p>
</div>
<svg class="group-open:hidden inline-block pl-3 w-10 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M5 12h.01M12 12h.01M19 12h.01M6 12a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0z"></path>
</svg>
</summary>
<div class="mx-8 pb-2">
<p>On suppose que le tableau en entrée suive <a href="../reconnaissance/#d%C3%A9finition-mod%C3%A8le-tableau-al%C3%A9atoire" class="interne">le modèle aléatoire</a> et on calcule l'espérance $\widehat{K_i}$ de $K_i$ en sommant le nombre fois la probabilité pour chaque cas, ce qui donne le calcul :</p>
<div>
$$
\begin{array}{lcl}
\widehat{K_i} &=& \sum_{j=0}^{i}(\mathbb{P}(T[i] = j)\cdot j)\\
&=& \sum_{j=0}^{i}(\frac{1}{i+1}\cdot j)\\
&=& \frac{1}{i+1}\cdot \frac{(i+1)\cdot i}{2})\\
&=& \frac{i}{2}\\
\end{array}
$$
</div>
</div>
</details>     
</div>
<p>On en conclut que le nombre moyen d'itérations dans la boucle <code class="language-">tant que</code>, $\widehat{K_i}$, va croître de 0 à $\frac{n}{2}$ et on peut utiliser la <a href="../../complexit%C3%A9-calculs/complexit%C3%A9-algorithmes#r%C3%A8gle-croissance" class="interne">la règle de croissance</a> pour considérer que la complexité moyenne du tri par insertion vaut $C_\text{moyenne}(n) = \widehat{K} \cdot n$ avec $\widehat{K} = \frac{n}{2}$. On en conclut que :</p>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
</svg>
<div class="pl-8 mb-2 mr-8">
<p><strong>Proposition</strong></p>
</div><div class="pl-8 mr-8">
<p>La <strong>complexité en moyenne</strong> de l'algorithme <code class="language-">insertion</code> est $\mathcal{O}(n^2)$ où $n$ est la taille du tableau passé en entrée.</p>
</div></div>

<p>Le cas le meilleur arrive très rarement par rapport au cas le pire (parmi les $n!$ ordres possibles, il y en a très peu qui sont presque triés). Cependant, <strong>si l'on change le modèle de données</strong> et que l'on considère des tableaux <em>presque triées</em>, la complexité en moyenne va être de l'ordre de la complexité minimale, à savoir : $\mathcal{O}(n)$</p>
<div class="quote relative py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-red-700 bg-red-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-red-700" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"></path>
</svg>
<div class="pl-8 mb-2 mr-8">
<p><strong>À retenir</strong></p>
</div><div class="pl-8 mr-8">
<p>On utilise le tri par insertion lorsque nos données seront presque toujours soit déjà triées soit très peu en désordre.</p>
</div></div>

<p>Ce calcul de complexité est à ramené à la proposition suivante, qui va se révéler très utile :</p>
<p><span id="modèle-aléatoire-50"></span></p>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
</svg>
<div class="pl-8 mb-2 mr-8">
<p><strong>Proposition</strong></p>
</div><div class="pl-8 mr-8">
<p>Soit $T$ un tableau suivant <a href="../reconnaissance/#d%C3%A9finition-mod%C3%A8le-tableau-al%C3%A9atoire" class="interne">le modèle aléatoire</a>, il y a en moyenne 50% d'éléments de $T[1:]$ qui sont strictement plus grand que $T[0]$.</p>
</div></div>

<div class="relative drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-indigo-500 bg-indigo-100">
<details class="group" open="">
<summary class="list-none py-0.5">
<svg class="group-open:hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M9 5l7 7-7 7"></path>
</svg>
<svg class="group-open:block hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7"></path>
</svg>
<div class="pl-8 font-bold inline-block">
<p>preuve</p>
</div>
<svg class="group-open:hidden inline-block pl-3 w-10 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M5 12h.01M12 12h.01M19 12h.01M6 12a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0z"></path>
</svg>
</summary>
<div class="mx-8 pb-2">
<p>Soit $T$ un tableau suivant <a href="../reconnaissance/#d%C3%A9finition-mod%C3%A8le-tableau-al%C3%A9atoire" class="interne">le modèle aléatoire</a>.</p>
<p>Comme $\mathbb{P}(T[0] &gt; T[i]) = \frac{1}{2}$ pour tout $i &lt; T.\mbox{\small longueur}$, l'espérance de $\vert \{T[i] &gt; T[0] \mid i &gt; 0\}$ vaut $T.\mbox{\small longueur}/2$.</p>
</div>
</details>     
</div>
<h2>Optimisation</h2>
<p>Une implémentation courante du tri par insertion est la suivante :</p>
<pre class="language-pseudocode" tabindex="0" data-language="pseudocode"><code class="language-pseudocode"><span class="token builtin">algorithme</span> <span class="token function">insertion</span><span class="token punctuation">(</span>T<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token builtin">entier</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token operator">→</span> ∅<span class="token punctuation">:</span>
    <span class="token keyword">pour chaque</span><span class="token number"> i </span>de <span class="token punctuation">[</span><span class="token number">1</span> <span class="token punctuation">.</span><span class="token punctuation">.</span> T<span class="token punctuation">.</span>longueur<span class="token punctuation">[</span><span class="token punctuation">:</span>
        courant <span class="token operator">←</span> T<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
       <span class="token number"> j </span><span class="token operator">←</span><span class="token number"> i
</span>        <span class="token keyword">tant que</span> <span class="token punctuation">(</span>j <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">et</span> <span class="token punctuation">(</span>courant <span class="token operator">&lt;</span> T<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            T<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">←</span> T<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span>
           <span class="token number"> j </span><span class="token operator">←</span><span class="token number"> j </span><span class="token operator">-</span> <span class="token number">1</span>
        T<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">←</span> courant</code></pre>
<p>Remarquez qu'elle ne fait pas d'échange à chaque fois. Elle se contente de faire de la place pour l'élément que l'on va insérer en décalant uniquement les valeurs du tableau. Une fois la place trouvée, il suffit de placer l'élément une fois. Finaud, non ?</p>


</article>
    </main>

    <footer class="min-h-[50px] border-t-2 border-gray-200 mt-4">
      <div class="max-w-[1200px] mx-auto px-4 relative">
        <div class="min-h-[50px] flex justify-center items-center">
          <p>
            Cours d'informatique de François Brucker
          </p>
        </div>
        <div class="min-h-[50px] flex justify-center items-center absolute right-0 top-0">
          <button onclick="goTop()" id="myBtn" title="Go to top">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
              <path stroke-linecap="round" stroke-linejoin="round" d="M15 11.25l-3-3m0 0l-3 3m3-3v7.5M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
            </svg>
          </button>

          <button onclick="goBottom()" id="myBtn" title="Go to top">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
              <path stroke-linecap="round" stroke-linejoin="round" d="M9 12.75l3 3m0 0l3-3m-3 3v-7.5M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
            </svg>
          </button>
        </div>

      </div>
    </footer>

    <script>
      MathJax
        .startup
        .document
        .getMathItemsWithin(document.body);
    </script>

  </body>
</html>