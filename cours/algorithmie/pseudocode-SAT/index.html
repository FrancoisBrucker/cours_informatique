<!DOCTYPE html>
<html lang="fr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>SAT et pseudo-code</title>

    

    <link href="https://prismjs.catppuccin.com/latte.css" rel="stylesheet">

    <link href="/cours_informatique/assets/node_modules/prismjs/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet">
    <script src="/cours_informatique/assets/node_modules/prismjs/plugins/line-numbers/prism-line-numbers.min.js"></script>
    
    <link href="/cours_informatique/assets/stylesheets/main.css" rel="stylesheet">

  </head>
  <body>
    <script>
      window.MathJax = {
        tex: {
          inlineMath: [
            [
              '$', '$'
            ],
            [
              '\\(', '\\)'
            ]
          ]
        },
        svg: {
          fontCache: 'global'
        }
      };

      function goTop() {
        window.scrollTo({top: 0});
      }
      function goBottom() {
        window.scrollTo({top: document.body.scrollHeight});
      }
    </script>
    <script type="text/javascript" id="MathJax-script" src="/cours_informatique/assets/node_modules/mathjax/es5/tex-svg-full.js"></script>

    <header class="border-b-2 border-gray-200 mb-4">
      <div class="max-w-[1200px] mx-auto px-4 relative">
        <div class="min-h-[50px] flex justify-between items-center">
          <a class="mx-2" href="/cours_informatique/">Home</a>
        </div>

        <div class="min-h-[50px] flex justify-center items-center absolute right-0 top-0">
          <a class="mx-2" href="/cours_informatique/about">About</a>
          <button onclick="goTop()" id="myBtn" title="Go to top">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
              <path stroke-linecap="round" stroke-linejoin="round" d="M15 11.25l-3-3m0 0l-3 3m3-3v7.5M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
            </svg>
          </button>

          <button onclick="goBottom()" id="myBtn" title="Go to top">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
              <path stroke-linecap="round" stroke-linejoin="round" d="M9 12.75l3 3m0 0l3-3m-3 3v-7.5M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
            </svg>
          </button>
        </div>

      </div>
    </header>

    <main class="max-w-[1200px] mx-auto px-4">
      
<article>

  <h1>SAT et pseudo-code</h1>
  <div>
    

    
  </div>

  

    
<div class="quote relative  py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-purple-500 bg-purple-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-purple-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M5 19a2 2 0 01-2-2V7a2 2 0 012-2h4l2 2h4a2 2 0 012 2v1M5 19h14a2 2 0 002-2v-5a2 2 0 00-2-2H9a2 2 0 00-2 2v5a2 2 0 01-2 2z"></path>
</svg>
<div class="pl-8 mr-8">

<a class="interne" href="/cours_informatique/cours/">Cours</a><span class="px-1">/</span><a class="interne" href="/cours_informatique/cours/algorithmie/">Algorithmie</a><span class="px-1">/</span><a class="interne" href="/cours_informatique/cours/algorithmie/pseudocode-SAT/">SAT et pseudo-code</a>

</div></div>



    
  

  <blockquote>
<p>TBD plan
Le but de cette partie est de montrer que l'on peut &quot;<em>compiler</em>&quot; toute fonction de signature <code class="language-">f(e:[bit]) → [bit]</code>  pseudo-code épuré en une fonction SAT</p>
</blockquote>
<h2>Pseudo-code épuré</h2>
<p>On a vu qu'écrire un pseudo-code pouvait se résumer sans perte de généralité au fait de n'utiliser que des types <code class="language-">bit</code> et <code class="language-">[bit]</code> et l'opération logique <code class="language-">NAND</code>. On peut même aller plus loin est supposer sans perte de généralité que les seules structures de contrôle autorisées sont :</p>
<ul>
<li><code class="language-">si x: ...bloc...</code> où <code>x</code> est une variable binaire. Le bloc n'est exécuté que si <code class="language-">x = 1</code>,</li>
<li><code class="language-">tant que x: ...bloc...</code> où <code>x</code> est une variable binaire. Le bloc n'est exécuté que tant que <code class="language-">x = 1</code>.</li>
</ul>
<p>Une ligne de ce pseudo-code épuré ne peut donc être qu'un des choix suivant :</p>
<ol>
<li>création et affectation d'une variable :</li>
<li><code class="language-">x</code> où $x$ est une variable de type <code class="language-">bit</code> : création d'une variable de type <code class="language-">bit</code> et initialisation à 0</li>
<li><code class="language-">x[:K]</code> création d'une variable de type <code class="language-">[bit]</code> à $K$ éléments</li>
<li><code class="language-">x[:u(k)]</code> création d'une variable de type <code class="language-">[bit]</code> à $u(k)$ éléments</li>
<li>affectation d'une variable de type <code class="language-">bit</code> :</li>
<li><code class="language-">x ← 0</code> où $x$ est une variable de type <code class="language-">bit</code></li>
<li><code class="language-">x ← 1</code> où $x$ est une variable de type <code class="language-">bit</code></li>
<li><code class="language-">x ← y</code> où $x$ et $y$ sont des variables de type <code class="language-">bit</code></li>
<li><code class="language-">x ← y[K]</code> où $x$ est une variable de type <code class="language-">bit</code>, $y$ une variable de type <code class="language-">[bit]</code> et $K$ un entier</li>
<li><code class="language-">x ← y[u(i)]</code> où $x$ est une variable de type <code class="language-">bit</code>, $y$ et $i$ deux variables de type <code class="language-">[bit]</code></li>
<li>affectation d'une case d'un tableau de type <code class="language-">[bit]</code> avec indice constant : <code class="language-">x[K] ← y</code> où $K$ est un entier, $x$ est une variable de type <code class="language-">[bit]</code> et $y$ est une variable de type <code class="language-">bit</code></li>
<li>affectation d'une case d'un tableau de type <code class="language-">[bit]</code> avec indice déterminé par une variable : <code class="language-">x[u(i)] ← y</code> où $x$ et $i$ sont des variable de type <code class="language-">[bit]</code> et $y$ est une variable de type <code class="language-">bit</code></li>
<li>instruction de contrôle :</li>
<li><code class="language-">si x:</code> où $x$ est une variable de type <code class="language-">bit</code></li>
<li><code class="language-">tant que x:</code> où $x$ est une variable de type <code class="language-">bit</code></li>
<li>opération <code class="language-">x ← NAND(y, z)</code> où $x$, $y$ et $z$ sont des variables de type <code class="language-">bit</code></li>
</ol>
<p>Toutes les instructions vont nécessiter $\mathcal{O}(1)$ opérations élémentaires à part les instructions où il faut utiliser la fonction $u()$ qui ajoute $\mathcal{O}(n)$ opérations élémentaires où $n$ est la longueur du tableau en entrée.</p>
<blockquote>
<p>TBD : peut dériver le reste, comme <code class="language-">x[u(i)] ← 0</code>, <code class="language-">x[u(i)] ← y[u(j)]</code> ou encore <code class="language-">si x[u(i)]:</code> avec ces primitives.</p>
</blockquote>
<h2>Formule logique et SAT</h2>
<p>Un pseudo-code épuré est assimilable à une liste d'instructions</p>
<ol>
<li>formule logique : avec et ou non. On a vu que ça fait tout. On peut &quot;programmer&quot; le tout en remplaçant des choses plus évoluée. Et max d'un tableau.</li>
<li>transformation en CNF avec Tseitin Linéaire rappel de ce que l'on a vu</li>
</ol>
<p>s.</p>
<blockquote>
<p>TBD attention complexité spatiale et temporelle.</p>
<ul>
<li>création et affectation d'une variable :</li>
</ul>
</blockquote>
<ul>
<li><code class="language-">x ← 0</code> où $x$ est une variable de type <code class="language-">bit</code> : création d'une variable de type <code class="language-">bit</code> et initialisation à 0</li>
<li><code class="language-">x[:K] ← 0</code> création d'une variable de type <code class="language-">[bit]</code> à $K$ éléments et initialisation de chacun de ses éléments à 0</li>
<li><code class="language-">x[:u(k)] ← 0</code> création d'une variable de type <code class="language-">[bit]</code> à $u(k)$ éléments et initialisation de chacun de ses éléments à 0</li>
</ul>
<blockquote>
<p>TBD faire la fonction associe un déplacement pour contraindre toute case allouée à être utilisée avec un dictionnaire de taille la complexité, change rien si poly on  est en complexité au carré.
TBD mais cases non initialisé implique résultat pas déterministe (aussi dans la vraie vie...) donc on alloue = bonne pratique et on force ici: <code>t[:n] ← 0</code> pour allouer. NB ne change rien. en vrai mais plus propre. même en code.</p>
</blockquote>
<h2>Pseudo-code et transcription vers une formule logique</h2>
<ol start="3">
<li>pseudo-code = pseudo-code binaire = instructions minimales</li>
<li>pseudo-code = formule logique = SAT (taille des tableaux = complexité)</li>
</ol>
<blockquote>
<p>TBD attention à la taille des tableaux. Elle doit être connue à la &quot;compilation&quot; donc doit uniquement dépendre de la taille des entrées
à chaque étape toute les variables.</p>
</blockquote>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
</svg>
<div class="pl-8 mb-2 mr-8">
<p><strong>Proposition</strong></p>
</div><div class="pl-8 mr-8">
<p>Un pseudo-code utilisant uniquement :</p>
<ul>
<li>des variables binaires ou des tableaux binaires</li>
<li>l'opération logique <code class="language-">NAND</code></li>
<li>des affectations de bit (variable binaire ou une case de tableaux)</li>
<li>des boucles <code class="language-">tant que x: &lt;bloc&gt;</code> avec $x$ une variable binaire :  le bloc n'est exécuté que si $x = 1$.</li>
<li>des instructions conditionnelles de la forme <code class="language-">si x: &lt;bloc&gt;</code> avec $x$ une variable binaire :  le bloc n'est exécuté que si $x = 1$.</li>
</ul>
<p>A la même expressivité que <a href="../pseudo-code/" class="interne">le pseudo-code classique</a>.</p>
</div></div>

<blockquote>
<p>TBD tout algo est un sat.
TBD on a vue que les opérations peuvent être mise sous forme logique. C'est aussi vrai pour les structures de contrôle.
TBD on vu que toute fonction est un sat et que tout circuit logique est un sat. Le problème SAT va être fondamental.
TBD dire que toute fonction booléenne vectorielle s'écrit comme une conjonction de clause. et que comme on passe d'un problème à l'autre, on peut le faire puisque nos entrées sont données.</p>
</blockquote>
<blockquote>
<p>TBD dire taille des variables dépendant de la taille des entrées. Au pire = complexité. Ne change pas si dans P.</p>
</blockquote>
<blockquote>
<p>TBD : Dire, mais laisser la démo pour plus tard, que SAT est supérieur à tout et donner exemple de réduction ≤ SAT et aussi ≥ SAT mais pas le sac à dos.</p>
</blockquote>
<h2>Inversibilité de SAT</h2>
<ol start="5">
<li>résoudre sortie = résoudre entrée !</li>
<li>ce n'est pas encore Cook et Levin car pas polynomial.</li>
</ol>
<blockquote>
<p>Inversibilité du problème SAT</p>
</blockquote>
<blockquote>
<p>TBD fct booléenne de l'addition ou du produit. Comme c'est une fonction booléenne cela permet d'avoir une réponse mais aussi d'avoir les entrées.</p>
<p>TBD on y reviendra mais en crypto c'est crucial de ne pas pouvoir  faire... Par exemple pour les produit de 2 nombres premiers. On revient au fait que factor doit être de complexité importante.</p>
<p>polylog circuit et sat : <a href="https://www.youtube.com/watch?v=6OPsH8PK7xM">https://www.youtube.com/watch?v=6OPsH8PK7xM</a></p>
</blockquote>
<blockquote>
<p>exemple réduction :</p>
</blockquote>


</article>
    </main>

    <footer class="min-h-[50px] border-t-2 border-gray-200 mt-4">
      <div class="max-w-[1200px] mx-auto px-4 relative">
        <div class="min-h-[50px] flex justify-center items-center">
          <p>
            Cours d'informatique de François Brucker
          </p>
        </div>
        <div class="min-h-[50px] flex justify-center items-center absolute right-0 top-0">
          <button onclick="goTop()" id="myBtn" title="Go to top">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
              <path stroke-linecap="round" stroke-linejoin="round" d="M15 11.25l-3-3m0 0l-3 3m3-3v7.5M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
            </svg>
          </button>

          <button onclick="goBottom()" id="myBtn" title="Go to top">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
              <path stroke-linecap="round" stroke-linejoin="round" d="M9 12.75l3 3m0 0l3-3m-3 3v-7.5M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
            </svg>
          </button>
        </div>

      </div>
    </footer>

    <script>
      MathJax
        .startup
        .document
        .getMathItemsWithin(document.body);
    </script>

  </body>
</html>